{"ast":null,"code":"import { EMPTY_OBJ, isArray, isMap, isIntegerKey, isSymbol, extend, hasOwn, isObject, hasChanged, capitalize, toRawType, def, isFunction, NOOP } from '@vue/shared';\nconst targetMap = new WeakMap();\nconst effectStack = [];\nlet activeEffect;\nconst ITERATE_KEY = Symbol(process.env.NODE_ENV !== 'production' ? 'iterate' : '');\nconst MAP_KEY_ITERATE_KEY = Symbol(process.env.NODE_ENV !== 'production' ? 'Map key iterate' : '');\n\nfunction isEffect(fn) {\n  return fn && fn._isEffect === true;\n}\n\nfunction effect(fn, options = EMPTY_OBJ) {\n  if (isEffect(fn)) {\n    fn = fn.raw;\n  }\n\n  const effect = createReactiveEffect(fn, options);\n\n  if (!options.lazy) {\n    effect();\n  }\n\n  return effect;\n}\n\nfunction stop(effect) {\n  if (effect.active) {\n    cleanup(effect);\n\n    if (effect.options.onStop) {\n      effect.options.onStop();\n    }\n\n    effect.active = false;\n  }\n}\n\nlet uid = 0;\n\nfunction createReactiveEffect(fn, options) {\n  const effect = function reactiveEffect() {\n    if (!effect.active) {\n      return options.scheduler ? undefined : fn();\n    }\n\n    if (!effectStack.includes(effect)) {\n      cleanup(effect);\n\n      try {\n        enableTracking();\n        effectStack.push(effect);\n        activeEffect = effect;\n        return fn();\n      } finally {\n        effectStack.pop();\n        resetTracking();\n        activeEffect = effectStack[effectStack.length - 1];\n      }\n    }\n  };\n\n  effect.id = uid++;\n  effect.allowRecurse = !!options.allowRecurse;\n  effect._isEffect = true;\n  effect.active = true;\n  effect.raw = fn;\n  effect.deps = [];\n  effect.options = options;\n  return effect;\n}\n\nfunction cleanup(effect) {\n  const {\n    deps\n  } = effect;\n\n  if (deps.length) {\n    for (let i = 0; i < deps.length; i++) {\n      deps[i].delete(effect);\n    }\n\n    deps.length = 0;\n  }\n}\n\nlet shouldTrack = true;\nconst trackStack = [];\n\nfunction pauseTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = false;\n}\n\nfunction enableTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = true;\n}\n\nfunction resetTracking() {\n  const last = trackStack.pop();\n  shouldTrack = last === undefined ? true : last;\n}\n\nfunction track(target, type, key) {\n  if (!shouldTrack || activeEffect === undefined) {\n    return;\n  }\n\n  let depsMap = targetMap.get(target);\n\n  if (!depsMap) {\n    targetMap.set(target, depsMap = new Map());\n  }\n\n  let dep = depsMap.get(key);\n\n  if (!dep) {\n    depsMap.set(key, dep = new Set());\n  }\n\n  if (!dep.has(activeEffect)) {\n    dep.add(activeEffect);\n    activeEffect.deps.push(dep);\n\n    if (process.env.NODE_ENV !== 'production' && activeEffect.options.onTrack) {\n      activeEffect.options.onTrack({\n        effect: activeEffect,\n        target,\n        type,\n        key\n      });\n    }\n  }\n}\n\nfunction trigger(target, type, key, newValue, oldValue, oldTarget) {\n  const depsMap = targetMap.get(target);\n\n  if (!depsMap) {\n    // never been tracked\n    return;\n  }\n\n  const effects = new Set();\n\n  const add = effectsToAdd => {\n    if (effectsToAdd) {\n      effectsToAdd.forEach(effect => {\n        if (effect !== activeEffect || effect.allowRecurse) {\n          effects.add(effect);\n        }\n      });\n    }\n  };\n\n  if (type === \"clear\"\n  /* CLEAR */\n  ) {\n      // collection being cleared\n      // trigger all effects for target\n      depsMap.forEach(add);\n    } else if (key === 'length' && isArray(target)) {\n    depsMap.forEach((dep, key) => {\n      if (key === 'length' || key >= newValue) {\n        add(dep);\n      }\n    });\n  } else {\n    // schedule runs for SET | ADD | DELETE\n    if (key !== void 0) {\n      add(depsMap.get(key));\n    } // also run for iteration key on ADD | DELETE | Map.SET\n\n\n    switch (type) {\n      case \"add\"\n      /* ADD */\n      :\n        if (!isArray(target)) {\n          add(depsMap.get(ITERATE_KEY));\n\n          if (isMap(target)) {\n            add(depsMap.get(MAP_KEY_ITERATE_KEY));\n          }\n        } else if (isIntegerKey(key)) {\n          // new index added to array -> length changes\n          add(depsMap.get('length'));\n        }\n\n        break;\n\n      case \"delete\"\n      /* DELETE */\n      :\n        if (!isArray(target)) {\n          add(depsMap.get(ITERATE_KEY));\n\n          if (isMap(target)) {\n            add(depsMap.get(MAP_KEY_ITERATE_KEY));\n          }\n        }\n\n        break;\n\n      case \"set\"\n      /* SET */\n      :\n        if (isMap(target)) {\n          add(depsMap.get(ITERATE_KEY));\n        }\n\n        break;\n    }\n  }\n\n  const run = effect => {\n    if (process.env.NODE_ENV !== 'production' && effect.options.onTrigger) {\n      effect.options.onTrigger({\n        effect,\n        target,\n        key,\n        type,\n        newValue,\n        oldValue,\n        oldTarget\n      });\n    }\n\n    if (effect.options.scheduler) {\n      effect.options.scheduler(effect);\n    } else {\n      effect();\n    }\n  };\n\n  effects.forEach(run);\n}\n\nconst builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol).map(key => Symbol[key]).filter(isSymbol));\nconst get = /*#__PURE__*/createGetter();\nconst shallowGet = /*#__PURE__*/createGetter(false, true);\nconst readonlyGet = /*#__PURE__*/createGetter(true);\nconst shallowReadonlyGet = /*#__PURE__*/createGetter(true, true);\nconst arrayInstrumentations = {};\n['includes', 'indexOf', 'lastIndexOf'].forEach(key => {\n  const method = Array.prototype[key];\n\n  arrayInstrumentations[key] = function (...args) {\n    const arr = toRaw(this);\n\n    for (let i = 0, l = this.length; i < l; i++) {\n      track(arr, \"get\"\n      /* GET */\n      , i + '');\n    } // we run the method using the original args first (which may be reactive)\n\n\n    const res = method.apply(arr, args);\n\n    if (res === -1 || res === false) {\n      // if that didn't work, run it again using raw values.\n      return method.apply(arr, args.map(toRaw));\n    } else {\n      return res;\n    }\n  };\n});\n['push', 'pop', 'shift', 'unshift', 'splice'].forEach(key => {\n  const method = Array.prototype[key];\n\n  arrayInstrumentations[key] = function (...args) {\n    pauseTracking();\n    const res = method.apply(this, args);\n    resetTracking();\n    return res;\n  };\n});\n\nfunction createGetter(isReadonly = false, shallow = false) {\n  return function get(target, key, receiver) {\n    if (key === \"__v_isReactive\"\n    /* IS_REACTIVE */\n    ) {\n        return !isReadonly;\n      } else if (key === \"__v_isReadonly\"\n    /* IS_READONLY */\n    ) {\n        return isReadonly;\n      } else if (key === \"__v_raw\"\n    /* RAW */\n    && receiver === (isReadonly ? readonlyMap : reactiveMap).get(target)) {\n      return target;\n    }\n\n    const targetIsArray = isArray(target);\n\n    if (targetIsArray && hasOwn(arrayInstrumentations, key)) {\n      return Reflect.get(arrayInstrumentations, key, receiver);\n    }\n\n    const res = Reflect.get(target, key, receiver);\n\n    if (isSymbol(key) ? builtInSymbols.has(key) : key === `__proto__` || key === `__v_isRef`) {\n      return res;\n    }\n\n    if (!isReadonly) {\n      track(target, \"get\"\n      /* GET */\n      , key);\n    }\n\n    if (shallow) {\n      return res;\n    }\n\n    if (isRef(res)) {\n      // ref unwrapping - does not apply for Array + integer key.\n      const shouldUnwrap = !targetIsArray || !isIntegerKey(key);\n      return shouldUnwrap ? res.value : res;\n    }\n\n    if (isObject(res)) {\n      // Convert returned value into a proxy as well. we do the isObject check\n      // here to avoid invalid value warning. Also need to lazy access readonly\n      // and reactive here to avoid circular dependency.\n      return isReadonly ? readonly(res) : reactive(res);\n    }\n\n    return res;\n  };\n}\n\nconst set = /*#__PURE__*/createSetter();\nconst shallowSet = /*#__PURE__*/createSetter(true);\n\nfunction createSetter(shallow = false) {\n  return function set(target, key, value, receiver) {\n    const oldValue = target[key];\n\n    if (!shallow) {\n      value = toRaw(value);\n\n      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {\n        oldValue.value = value;\n        return true;\n      }\n    }\n\n    const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);\n    const result = Reflect.set(target, key, value, receiver); // don't trigger if target is something up in the prototype chain of original\n\n    if (target === toRaw(receiver)) {\n      if (!hadKey) {\n        trigger(target, \"add\"\n        /* ADD */\n        , key, value);\n      } else if (hasChanged(value, oldValue)) {\n        trigger(target, \"set\"\n        /* SET */\n        , key, value, oldValue);\n      }\n    }\n\n    return result;\n  };\n}\n\nfunction deleteProperty(target, key) {\n  const hadKey = hasOwn(target, key);\n  const oldValue = target[key];\n  const result = Reflect.deleteProperty(target, key);\n\n  if (result && hadKey) {\n    trigger(target, \"delete\"\n    /* DELETE */\n    , key, undefined, oldValue);\n  }\n\n  return result;\n}\n\nfunction has(target, key) {\n  const result = Reflect.has(target, key);\n\n  if (!isSymbol(key) || !builtInSymbols.has(key)) {\n    track(target, \"has\"\n    /* HAS */\n    , key);\n  }\n\n  return result;\n}\n\nfunction ownKeys(target) {\n  track(target, \"iterate\"\n  /* ITERATE */\n  , ITERATE_KEY);\n  return Reflect.ownKeys(target);\n}\n\nconst mutableHandlers = {\n  get,\n  set,\n  deleteProperty,\n  has,\n  ownKeys\n};\nconst readonlyHandlers = {\n  get: readonlyGet,\n\n  set(target, key) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.warn(`Set operation on key \"${String(key)}\" failed: target is readonly.`, target);\n    }\n\n    return true;\n  },\n\n  deleteProperty(target, key) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.warn(`Delete operation on key \"${String(key)}\" failed: target is readonly.`, target);\n    }\n\n    return true;\n  }\n\n};\nconst shallowReactiveHandlers = extend({}, mutableHandlers, {\n  get: shallowGet,\n  set: shallowSet\n}); // Props handlers are special in the sense that it should not unwrap top-level\n// refs (in order to allow refs to be explicitly passed down), but should\n// retain the reactivity of the normal readonly object.\n\nconst shallowReadonlyHandlers = extend({}, readonlyHandlers, {\n  get: shallowReadonlyGet\n});\n\nconst toReactive = value => isObject(value) ? reactive(value) : value;\n\nconst toReadonly = value => isObject(value) ? readonly(value) : value;\n\nconst toShallow = value => value;\n\nconst getProto = v => Reflect.getPrototypeOf(v);\n\nfunction get$1(target, key, isReadonly = false, isShallow = false) {\n  // #1772: readonly(reactive(Map)) should return readonly + reactive version\n  // of the value\n  target = target[\"__v_raw\"\n  /* RAW */\n  ];\n  const rawTarget = toRaw(target);\n  const rawKey = toRaw(key);\n\n  if (key !== rawKey) {\n    !isReadonly && track(rawTarget, \"get\"\n    /* GET */\n    , key);\n  }\n\n  !isReadonly && track(rawTarget, \"get\"\n  /* GET */\n  , rawKey);\n  const {\n    has\n  } = getProto(rawTarget);\n  const wrap = isReadonly ? toReadonly : isShallow ? toShallow : toReactive;\n\n  if (has.call(rawTarget, key)) {\n    return wrap(target.get(key));\n  } else if (has.call(rawTarget, rawKey)) {\n    return wrap(target.get(rawKey));\n  }\n}\n\nfunction has$1(key, isReadonly = false) {\n  const target = this[\"__v_raw\"\n  /* RAW */\n  ];\n  const rawTarget = toRaw(target);\n  const rawKey = toRaw(key);\n\n  if (key !== rawKey) {\n    !isReadonly && track(rawTarget, \"has\"\n    /* HAS */\n    , key);\n  }\n\n  !isReadonly && track(rawTarget, \"has\"\n  /* HAS */\n  , rawKey);\n  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);\n}\n\nfunction size(target, isReadonly = false) {\n  target = target[\"__v_raw\"\n  /* RAW */\n  ];\n  !isReadonly && track(toRaw(target), \"iterate\"\n  /* ITERATE */\n  , ITERATE_KEY);\n  return Reflect.get(target, 'size', target);\n}\n\nfunction add(value) {\n  value = toRaw(value);\n  const target = toRaw(this);\n  const proto = getProto(target);\n  const hadKey = proto.has.call(target, value);\n  const result = target.add(value);\n\n  if (!hadKey) {\n    trigger(target, \"add\"\n    /* ADD */\n    , value, value);\n  }\n\n  return result;\n}\n\nfunction set$1(key, value) {\n  value = toRaw(value);\n  const target = toRaw(this);\n  const {\n    has,\n    get\n  } = getProto(target);\n  let hadKey = has.call(target, key);\n\n  if (!hadKey) {\n    key = toRaw(key);\n    hadKey = has.call(target, key);\n  } else if (process.env.NODE_ENV !== 'production') {\n    checkIdentityKeys(target, has, key);\n  }\n\n  const oldValue = get.call(target, key);\n  const result = target.set(key, value);\n\n  if (!hadKey) {\n    trigger(target, \"add\"\n    /* ADD */\n    , key, value);\n  } else if (hasChanged(value, oldValue)) {\n    trigger(target, \"set\"\n    /* SET */\n    , key, value, oldValue);\n  }\n\n  return result;\n}\n\nfunction deleteEntry(key) {\n  const target = toRaw(this);\n  const {\n    has,\n    get\n  } = getProto(target);\n  let hadKey = has.call(target, key);\n\n  if (!hadKey) {\n    key = toRaw(key);\n    hadKey = has.call(target, key);\n  } else if (process.env.NODE_ENV !== 'production') {\n    checkIdentityKeys(target, has, key);\n  }\n\n  const oldValue = get ? get.call(target, key) : undefined; // forward the operation before queueing reactions\n\n  const result = target.delete(key);\n\n  if (hadKey) {\n    trigger(target, \"delete\"\n    /* DELETE */\n    , key, undefined, oldValue);\n  }\n\n  return result;\n}\n\nfunction clear() {\n  const target = toRaw(this);\n  const hadItems = target.size !== 0;\n  const oldTarget = process.env.NODE_ENV !== 'production' ? isMap(target) ? new Map(target) : new Set(target) : undefined; // forward the operation before queueing reactions\n\n  const result = target.clear();\n\n  if (hadItems) {\n    trigger(target, \"clear\"\n    /* CLEAR */\n    , undefined, undefined, oldTarget);\n  }\n\n  return result;\n}\n\nfunction createForEach(isReadonly, isShallow) {\n  return function forEach(callback, thisArg) {\n    const observed = this;\n    const target = observed[\"__v_raw\"\n    /* RAW */\n    ];\n    const rawTarget = toRaw(target);\n    const wrap = isReadonly ? toReadonly : isShallow ? toShallow : toReactive;\n    !isReadonly && track(rawTarget, \"iterate\"\n    /* ITERATE */\n    , ITERATE_KEY);\n    return target.forEach((value, key) => {\n      // important: make sure the callback is\n      // 1. invoked with the reactive map as `this` and 3rd arg\n      // 2. the value received should be a corresponding reactive/readonly.\n      return callback.call(thisArg, wrap(value), wrap(key), observed);\n    });\n  };\n}\n\nfunction createIterableMethod(method, isReadonly, isShallow) {\n  return function (...args) {\n    const target = this[\"__v_raw\"\n    /* RAW */\n    ];\n    const rawTarget = toRaw(target);\n    const targetIsMap = isMap(rawTarget);\n    const isPair = method === 'entries' || method === Symbol.iterator && targetIsMap;\n    const isKeyOnly = method === 'keys' && targetIsMap;\n    const innerIterator = target[method](...args);\n    const wrap = isReadonly ? toReadonly : isShallow ? toShallow : toReactive;\n    !isReadonly && track(rawTarget, \"iterate\"\n    /* ITERATE */\n    , isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY); // return a wrapped iterator which returns observed versions of the\n    // values emitted from the real iterator\n\n    return {\n      // iterator protocol\n      next() {\n        const {\n          value,\n          done\n        } = innerIterator.next();\n        return done ? {\n          value,\n          done\n        } : {\n          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\n          done\n        };\n      },\n\n      // iterable protocol\n      [Symbol.iterator]() {\n        return this;\n      }\n\n    };\n  };\n}\n\nfunction createReadonlyMethod(type) {\n  return function (...args) {\n    if (process.env.NODE_ENV !== 'production') {\n      const key = args[0] ? `on key \"${args[0]}\" ` : ``;\n      console.warn(`${capitalize(type)} operation ${key}failed: target is readonly.`, toRaw(this));\n    }\n\n    return type === \"delete\"\n    /* DELETE */\n    ? false : this;\n  };\n}\n\nconst mutableInstrumentations = {\n  get(key) {\n    return get$1(this, key);\n  },\n\n  get size() {\n    return size(this);\n  },\n\n  has: has$1,\n  add,\n  set: set$1,\n  delete: deleteEntry,\n  clear,\n  forEach: createForEach(false, false)\n};\nconst shallowInstrumentations = {\n  get(key) {\n    return get$1(this, key, false, true);\n  },\n\n  get size() {\n    return size(this);\n  },\n\n  has: has$1,\n  add,\n  set: set$1,\n  delete: deleteEntry,\n  clear,\n  forEach: createForEach(false, true)\n};\nconst readonlyInstrumentations = {\n  get(key) {\n    return get$1(this, key, true);\n  },\n\n  get size() {\n    return size(this, true);\n  },\n\n  has(key) {\n    return has$1.call(this, key, true);\n  },\n\n  add: createReadonlyMethod(\"add\"\n  /* ADD */\n  ),\n  set: createReadonlyMethod(\"set\"\n  /* SET */\n  ),\n  delete: createReadonlyMethod(\"delete\"\n  /* DELETE */\n  ),\n  clear: createReadonlyMethod(\"clear\"\n  /* CLEAR */\n  ),\n  forEach: createForEach(true, false)\n};\nconst iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator];\niteratorMethods.forEach(method => {\n  mutableInstrumentations[method] = createIterableMethod(method, false, false);\n  readonlyInstrumentations[method] = createIterableMethod(method, true, false);\n  shallowInstrumentations[method] = createIterableMethod(method, false, true);\n});\n\nfunction createInstrumentationGetter(isReadonly, shallow) {\n  const instrumentations = shallow ? shallowInstrumentations : isReadonly ? readonlyInstrumentations : mutableInstrumentations;\n  return (target, key, receiver) => {\n    if (key === \"__v_isReactive\"\n    /* IS_REACTIVE */\n    ) {\n        return !isReadonly;\n      } else if (key === \"__v_isReadonly\"\n    /* IS_READONLY */\n    ) {\n        return isReadonly;\n      } else if (key === \"__v_raw\"\n    /* RAW */\n    ) {\n        return target;\n      }\n\n    return Reflect.get(hasOwn(instrumentations, key) && key in target ? instrumentations : target, key, receiver);\n  };\n}\n\nconst mutableCollectionHandlers = {\n  get: createInstrumentationGetter(false, false)\n};\nconst shallowCollectionHandlers = {\n  get: createInstrumentationGetter(false, true)\n};\nconst readonlyCollectionHandlers = {\n  get: createInstrumentationGetter(true, false)\n};\n\nfunction checkIdentityKeys(target, has, key) {\n  const rawKey = toRaw(key);\n\n  if (rawKey !== key && has.call(target, rawKey)) {\n    const type = toRawType(target);\n    console.warn(`Reactive ${type} contains both the raw and reactive ` + `versions of the same object${type === `Map` ? ` as keys` : ``}, ` + `which can lead to inconsistencies. ` + `Avoid differentiating between the raw and reactive versions ` + `of an object and only use the reactive version if possible.`);\n  }\n}\n\nconst reactiveMap = new WeakMap();\nconst readonlyMap = new WeakMap();\n\nfunction targetTypeMap(rawType) {\n  switch (rawType) {\n    case 'Object':\n    case 'Array':\n      return 1\n      /* COMMON */\n      ;\n\n    case 'Map':\n    case 'Set':\n    case 'WeakMap':\n    case 'WeakSet':\n      return 2\n      /* COLLECTION */\n      ;\n\n    default:\n      return 0\n      /* INVALID */\n      ;\n  }\n}\n\nfunction getTargetType(value) {\n  return value[\"__v_skip\"\n  /* SKIP */\n  ] || !Object.isExtensible(value) ? 0\n  /* INVALID */\n  : targetTypeMap(toRawType(value));\n}\n\nfunction reactive(target) {\n  // if trying to observe a readonly proxy, return the readonly version.\n  if (target && target[\"__v_isReadonly\"\n  /* IS_READONLY */\n  ]) {\n    return target;\n  }\n\n  return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers);\n} // Return a reactive-copy of the original object, where only the root level\n// properties are reactive, and does NOT unwrap refs nor recursively convert\n// returned properties.\n\n\nfunction shallowReactive(target) {\n  return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers);\n}\n\nfunction readonly(target) {\n  return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers);\n} // Return a reactive-copy of the original object, where only the root level\n// properties are readonly, and does NOT unwrap refs nor recursively convert\n// returned properties.\n// This is used for creating the props proxy object for stateful components.\n\n\nfunction shallowReadonly(target) {\n  return createReactiveObject(target, true, shallowReadonlyHandlers, readonlyCollectionHandlers);\n}\n\nfunction createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers) {\n  if (!isObject(target)) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.warn(`value cannot be made reactive: ${String(target)}`);\n    }\n\n    return target;\n  } // target is already a Proxy, return it.\n  // exception: calling readonly() on a reactive object\n\n\n  if (target[\"__v_raw\"\n  /* RAW */\n  ] && !(isReadonly && target[\"__v_isReactive\"\n  /* IS_REACTIVE */\n  ])) {\n    return target;\n  } // target already has corresponding Proxy\n\n\n  const proxyMap = isReadonly ? readonlyMap : reactiveMap;\n  const existingProxy = proxyMap.get(target);\n\n  if (existingProxy) {\n    return existingProxy;\n  } // only a whitelist of value types can be observed.\n\n\n  const targetType = getTargetType(target);\n\n  if (targetType === 0\n  /* INVALID */\n  ) {\n      return target;\n    }\n\n  const proxy = new Proxy(target, targetType === 2\n  /* COLLECTION */\n  ? collectionHandlers : baseHandlers);\n  proxyMap.set(target, proxy);\n  return proxy;\n}\n\nfunction isReactive(value) {\n  if (isReadonly(value)) {\n    return isReactive(value[\"__v_raw\"\n    /* RAW */\n    ]);\n  }\n\n  return !!(value && value[\"__v_isReactive\"\n  /* IS_REACTIVE */\n  ]);\n}\n\nfunction isReadonly(value) {\n  return !!(value && value[\"__v_isReadonly\"\n  /* IS_READONLY */\n  ]);\n}\n\nfunction isProxy(value) {\n  return isReactive(value) || isReadonly(value);\n}\n\nfunction toRaw(observed) {\n  return observed && toRaw(observed[\"__v_raw\"\n  /* RAW */\n  ]) || observed;\n}\n\nfunction markRaw(value) {\n  def(value, \"__v_skip\"\n  /* SKIP */\n  , true);\n  return value;\n}\n\nconst convert = val => isObject(val) ? reactive(val) : val;\n\nfunction isRef(r) {\n  return Boolean(r && r.__v_isRef === true);\n}\n\nfunction ref(value) {\n  return createRef(value);\n}\n\nfunction shallowRef(value) {\n  return createRef(value, true);\n}\n\nclass RefImpl {\n  constructor(_rawValue, _shallow = false) {\n    this._rawValue = _rawValue;\n    this._shallow = _shallow;\n    this.__v_isRef = true;\n    this._value = _shallow ? _rawValue : convert(_rawValue);\n  }\n\n  get value() {\n    track(toRaw(this), \"get\"\n    /* GET */\n    , 'value');\n    return this._value;\n  }\n\n  set value(newVal) {\n    if (hasChanged(toRaw(newVal), this._rawValue)) {\n      this._rawValue = newVal;\n      this._value = this._shallow ? newVal : convert(newVal);\n      trigger(toRaw(this), \"set\"\n      /* SET */\n      , 'value', newVal);\n    }\n  }\n\n}\n\nfunction createRef(rawValue, shallow = false) {\n  if (isRef(rawValue)) {\n    return rawValue;\n  }\n\n  return new RefImpl(rawValue, shallow);\n}\n\nfunction triggerRef(ref) {\n  trigger(toRaw(ref), \"set\"\n  /* SET */\n  , 'value', process.env.NODE_ENV !== 'production' ? ref.value : void 0);\n}\n\nfunction unref(ref) {\n  return isRef(ref) ? ref.value : ref;\n}\n\nconst shallowUnwrapHandlers = {\n  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),\n  set: (target, key, value, receiver) => {\n    const oldValue = target[key];\n\n    if (isRef(oldValue) && !isRef(value)) {\n      oldValue.value = value;\n      return true;\n    } else {\n      return Reflect.set(target, key, value, receiver);\n    }\n  }\n};\n\nfunction proxyRefs(objectWithRefs) {\n  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);\n}\n\nclass CustomRefImpl {\n  constructor(factory) {\n    this.__v_isRef = true;\n    const {\n      get,\n      set\n    } = factory(() => track(this, \"get\"\n    /* GET */\n    , 'value'), () => trigger(this, \"set\"\n    /* SET */\n    , 'value'));\n    this._get = get;\n    this._set = set;\n  }\n\n  get value() {\n    return this._get();\n  }\n\n  set value(newVal) {\n    this._set(newVal);\n  }\n\n}\n\nfunction customRef(factory) {\n  return new CustomRefImpl(factory);\n}\n\nfunction toRefs(object) {\n  if (process.env.NODE_ENV !== 'production' && !isProxy(object)) {\n    console.warn(`toRefs() expects a reactive object but received a plain one.`);\n  }\n\n  const ret = isArray(object) ? new Array(object.length) : {};\n\n  for (const key in object) {\n    ret[key] = toRef(object, key);\n  }\n\n  return ret;\n}\n\nclass ObjectRefImpl {\n  constructor(_object, _key) {\n    this._object = _object;\n    this._key = _key;\n    this.__v_isRef = true;\n  }\n\n  get value() {\n    return this._object[this._key];\n  }\n\n  set value(newVal) {\n    this._object[this._key] = newVal;\n  }\n\n}\n\nfunction toRef(object, key) {\n  return isRef(object[key]) ? object[key] : new ObjectRefImpl(object, key);\n}\n\nclass ComputedRefImpl {\n  constructor(getter, _setter, isReadonly) {\n    this._setter = _setter;\n    this._dirty = true;\n    this.__v_isRef = true;\n    this.effect = effect(getter, {\n      lazy: true,\n      scheduler: () => {\n        if (!this._dirty) {\n          this._dirty = true;\n          trigger(toRaw(this), \"set\"\n          /* SET */\n          , 'value');\n        }\n      }\n    });\n    this[\"__v_isReadonly\"\n    /* IS_READONLY */\n    ] = isReadonly;\n  }\n\n  get value() {\n    if (this._dirty) {\n      this._value = this.effect();\n      this._dirty = false;\n    }\n\n    track(toRaw(this), \"get\"\n    /* GET */\n    , 'value');\n    return this._value;\n  }\n\n  set value(newValue) {\n    this._setter(newValue);\n  }\n\n}\n\nfunction computed(getterOrOptions) {\n  let getter;\n  let setter;\n\n  if (isFunction(getterOrOptions)) {\n    getter = getterOrOptions;\n    setter = process.env.NODE_ENV !== 'production' ? () => {\n      console.warn('Write operation failed: computed value is readonly');\n    } : NOOP;\n  } else {\n    getter = getterOrOptions.get;\n    setter = getterOrOptions.set;\n  }\n\n  return new ComputedRefImpl(getter, setter, isFunction(getterOrOptions) || !getterOrOptions.set);\n}\n\nexport { ITERATE_KEY, computed, customRef, effect, enableTracking, isProxy, isReactive, isReadonly, isRef, markRaw, pauseTracking, proxyRefs, reactive, readonly, ref, resetTracking, shallowReactive, shallowReadonly, shallowRef, stop, toRaw, toRef, toRefs, track, trigger, triggerRef, unref };","map":{"version":3,"sources":["C:/Users/ASUS/node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js"],"names":["EMPTY_OBJ","isArray","isMap","isIntegerKey","isSymbol","extend","hasOwn","isObject","hasChanged","capitalize","toRawType","def","isFunction","NOOP","targetMap","WeakMap","effectStack","activeEffect","ITERATE_KEY","Symbol","process","env","NODE_ENV","MAP_KEY_ITERATE_KEY","isEffect","fn","_isEffect","effect","options","raw","createReactiveEffect","lazy","stop","active","cleanup","onStop","uid","reactiveEffect","scheduler","undefined","includes","enableTracking","push","pop","resetTracking","length","id","allowRecurse","deps","i","delete","shouldTrack","trackStack","pauseTracking","last","track","target","type","key","depsMap","get","set","Map","dep","Set","has","add","onTrack","trigger","newValue","oldValue","oldTarget","effects","effectsToAdd","forEach","run","onTrigger","builtInSymbols","Object","getOwnPropertyNames","map","filter","createGetter","shallowGet","readonlyGet","shallowReadonlyGet","arrayInstrumentations","method","Array","prototype","args","arr","toRaw","l","res","apply","isReadonly","shallow","receiver","readonlyMap","reactiveMap","targetIsArray","Reflect","isRef","shouldUnwrap","value","readonly","reactive","createSetter","shallowSet","hadKey","Number","result","deleteProperty","ownKeys","mutableHandlers","readonlyHandlers","console","warn","String","shallowReactiveHandlers","shallowReadonlyHandlers","toReactive","toReadonly","toShallow","getProto","v","getPrototypeOf","get$1","isShallow","rawTarget","rawKey","wrap","call","has$1","size","proto","set$1","checkIdentityKeys","deleteEntry","clear","hadItems","createForEach","callback","thisArg","observed","createIterableMethod","targetIsMap","isPair","iterator","isKeyOnly","innerIterator","next","done","createReadonlyMethod","mutableInstrumentations","shallowInstrumentations","readonlyInstrumentations","iteratorMethods","createInstrumentationGetter","instrumentations","mutableCollectionHandlers","shallowCollectionHandlers","readonlyCollectionHandlers","targetTypeMap","rawType","getTargetType","isExtensible","createReactiveObject","shallowReactive","shallowReadonly","baseHandlers","collectionHandlers","proxyMap","existingProxy","targetType","proxy","Proxy","isReactive","isProxy","markRaw","convert","val","r","Boolean","__v_isRef","ref","createRef","shallowRef","RefImpl","constructor","_rawValue","_shallow","_value","newVal","rawValue","triggerRef","unref","shallowUnwrapHandlers","proxyRefs","objectWithRefs","CustomRefImpl","factory","_get","_set","customRef","toRefs","object","ret","toRef","ObjectRefImpl","_object","_key","ComputedRefImpl","getter","_setter","_dirty","computed","getterOrOptions","setter"],"mappings":"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","sourcesContent":["import { EMPTY_OBJ, isArray, isMap, isIntegerKey, isSymbol, extend, hasOwn, isObject, hasChanged, capitalize, toRawType, def, isFunction, NOOP } from '@vue/shared';\n\nconst targetMap = new WeakMap();\r\nconst effectStack = [];\r\nlet activeEffect;\r\nconst ITERATE_KEY = Symbol((process.env.NODE_ENV !== 'production') ? 'iterate' : '');\r\nconst MAP_KEY_ITERATE_KEY = Symbol((process.env.NODE_ENV !== 'production') ? 'Map key iterate' : '');\r\nfunction isEffect(fn) {\r\n    return fn && fn._isEffect === true;\r\n}\r\nfunction effect(fn, options = EMPTY_OBJ) {\r\n    if (isEffect(fn)) {\r\n        fn = fn.raw;\r\n    }\r\n    const effect = createReactiveEffect(fn, options);\r\n    if (!options.lazy) {\r\n        effect();\r\n    }\r\n    return effect;\r\n}\r\nfunction stop(effect) {\r\n    if (effect.active) {\r\n        cleanup(effect);\r\n        if (effect.options.onStop) {\r\n            effect.options.onStop();\r\n        }\r\n        effect.active = false;\r\n    }\r\n}\r\nlet uid = 0;\r\nfunction createReactiveEffect(fn, options) {\r\n    const effect = function reactiveEffect() {\r\n        if (!effect.active) {\r\n            return options.scheduler ? undefined : fn();\r\n        }\r\n        if (!effectStack.includes(effect)) {\r\n            cleanup(effect);\r\n            try {\r\n                enableTracking();\r\n                effectStack.push(effect);\r\n                activeEffect = effect;\r\n                return fn();\r\n            }\r\n            finally {\r\n                effectStack.pop();\r\n                resetTracking();\r\n                activeEffect = effectStack[effectStack.length - 1];\r\n            }\r\n        }\r\n    };\r\n    effect.id = uid++;\r\n    effect.allowRecurse = !!options.allowRecurse;\r\n    effect._isEffect = true;\r\n    effect.active = true;\r\n    effect.raw = fn;\r\n    effect.deps = [];\r\n    effect.options = options;\r\n    return effect;\r\n}\r\nfunction cleanup(effect) {\r\n    const { deps } = effect;\r\n    if (deps.length) {\r\n        for (let i = 0; i < deps.length; i++) {\r\n            deps[i].delete(effect);\r\n        }\r\n        deps.length = 0;\r\n    }\r\n}\r\nlet shouldTrack = true;\r\nconst trackStack = [];\r\nfunction pauseTracking() {\r\n    trackStack.push(shouldTrack);\r\n    shouldTrack = false;\r\n}\r\nfunction enableTracking() {\r\n    trackStack.push(shouldTrack);\r\n    shouldTrack = true;\r\n}\r\nfunction resetTracking() {\r\n    const last = trackStack.pop();\r\n    shouldTrack = last === undefined ? true : last;\r\n}\r\nfunction track(target, type, key) {\r\n    if (!shouldTrack || activeEffect === undefined) {\r\n        return;\r\n    }\r\n    let depsMap = targetMap.get(target);\r\n    if (!depsMap) {\r\n        targetMap.set(target, (depsMap = new Map()));\r\n    }\r\n    let dep = depsMap.get(key);\r\n    if (!dep) {\r\n        depsMap.set(key, (dep = new Set()));\r\n    }\r\n    if (!dep.has(activeEffect)) {\r\n        dep.add(activeEffect);\r\n        activeEffect.deps.push(dep);\r\n        if ((process.env.NODE_ENV !== 'production') && activeEffect.options.onTrack) {\r\n            activeEffect.options.onTrack({\r\n                effect: activeEffect,\r\n                target,\r\n                type,\r\n                key\r\n            });\r\n        }\r\n    }\r\n}\r\nfunction trigger(target, type, key, newValue, oldValue, oldTarget) {\r\n    const depsMap = targetMap.get(target);\r\n    if (!depsMap) {\r\n        // never been tracked\r\n        return;\r\n    }\r\n    const effects = new Set();\r\n    const add = (effectsToAdd) => {\r\n        if (effectsToAdd) {\r\n            effectsToAdd.forEach(effect => {\r\n                if (effect !== activeEffect || effect.allowRecurse) {\r\n                    effects.add(effect);\r\n                }\r\n            });\r\n        }\r\n    };\r\n    if (type === \"clear\" /* CLEAR */) {\r\n        // collection being cleared\r\n        // trigger all effects for target\r\n        depsMap.forEach(add);\r\n    }\r\n    else if (key === 'length' && isArray(target)) {\r\n        depsMap.forEach((dep, key) => {\r\n            if (key === 'length' || key >= newValue) {\r\n                add(dep);\r\n            }\r\n        });\r\n    }\r\n    else {\r\n        // schedule runs for SET | ADD | DELETE\r\n        if (key !== void 0) {\r\n            add(depsMap.get(key));\r\n        }\r\n        // also run for iteration key on ADD | DELETE | Map.SET\r\n        switch (type) {\r\n            case \"add\" /* ADD */:\r\n                if (!isArray(target)) {\r\n                    add(depsMap.get(ITERATE_KEY));\r\n                    if (isMap(target)) {\r\n                        add(depsMap.get(MAP_KEY_ITERATE_KEY));\r\n                    }\r\n                }\r\n                else if (isIntegerKey(key)) {\r\n                    // new index added to array -> length changes\r\n                    add(depsMap.get('length'));\r\n                }\r\n                break;\r\n            case \"delete\" /* DELETE */:\r\n                if (!isArray(target)) {\r\n                    add(depsMap.get(ITERATE_KEY));\r\n                    if (isMap(target)) {\r\n                        add(depsMap.get(MAP_KEY_ITERATE_KEY));\r\n                    }\r\n                }\r\n                break;\r\n            case \"set\" /* SET */:\r\n                if (isMap(target)) {\r\n                    add(depsMap.get(ITERATE_KEY));\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    const run = (effect) => {\r\n        if ((process.env.NODE_ENV !== 'production') && effect.options.onTrigger) {\r\n            effect.options.onTrigger({\r\n                effect,\r\n                target,\r\n                key,\r\n                type,\r\n                newValue,\r\n                oldValue,\r\n                oldTarget\r\n            });\r\n        }\r\n        if (effect.options.scheduler) {\r\n            effect.options.scheduler(effect);\r\n        }\r\n        else {\r\n            effect();\r\n        }\r\n    };\r\n    effects.forEach(run);\r\n}\n\nconst builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol)\r\n    .map(key => Symbol[key])\r\n    .filter(isSymbol));\r\nconst get = /*#__PURE__*/ createGetter();\r\nconst shallowGet = /*#__PURE__*/ createGetter(false, true);\r\nconst readonlyGet = /*#__PURE__*/ createGetter(true);\r\nconst shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true);\r\nconst arrayInstrumentations = {};\r\n['includes', 'indexOf', 'lastIndexOf'].forEach(key => {\r\n    const method = Array.prototype[key];\r\n    arrayInstrumentations[key] = function (...args) {\r\n        const arr = toRaw(this);\r\n        for (let i = 0, l = this.length; i < l; i++) {\r\n            track(arr, \"get\" /* GET */, i + '');\r\n        }\r\n        // we run the method using the original args first (which may be reactive)\r\n        const res = method.apply(arr, args);\r\n        if (res === -1 || res === false) {\r\n            // if that didn't work, run it again using raw values.\r\n            return method.apply(arr, args.map(toRaw));\r\n        }\r\n        else {\r\n            return res;\r\n        }\r\n    };\r\n});\r\n['push', 'pop', 'shift', 'unshift', 'splice'].forEach(key => {\r\n    const method = Array.prototype[key];\r\n    arrayInstrumentations[key] = function (...args) {\r\n        pauseTracking();\r\n        const res = method.apply(this, args);\r\n        resetTracking();\r\n        return res;\r\n    };\r\n});\r\nfunction createGetter(isReadonly = false, shallow = false) {\r\n    return function get(target, key, receiver) {\r\n        if (key === \"__v_isReactive\" /* IS_REACTIVE */) {\r\n            return !isReadonly;\r\n        }\r\n        else if (key === \"__v_isReadonly\" /* IS_READONLY */) {\r\n            return isReadonly;\r\n        }\r\n        else if (key === \"__v_raw\" /* RAW */ &&\r\n            receiver === (isReadonly ? readonlyMap : reactiveMap).get(target)) {\r\n            return target;\r\n        }\r\n        const targetIsArray = isArray(target);\r\n        if (targetIsArray && hasOwn(arrayInstrumentations, key)) {\r\n            return Reflect.get(arrayInstrumentations, key, receiver);\r\n        }\r\n        const res = Reflect.get(target, key, receiver);\r\n        if (isSymbol(key)\r\n            ? builtInSymbols.has(key)\r\n            : key === `__proto__` || key === `__v_isRef`) {\r\n            return res;\r\n        }\r\n        if (!isReadonly) {\r\n            track(target, \"get\" /* GET */, key);\r\n        }\r\n        if (shallow) {\r\n            return res;\r\n        }\r\n        if (isRef(res)) {\r\n            // ref unwrapping - does not apply for Array + integer key.\r\n            const shouldUnwrap = !targetIsArray || !isIntegerKey(key);\r\n            return shouldUnwrap ? res.value : res;\r\n        }\r\n        if (isObject(res)) {\r\n            // Convert returned value into a proxy as well. we do the isObject check\r\n            // here to avoid invalid value warning. Also need to lazy access readonly\r\n            // and reactive here to avoid circular dependency.\r\n            return isReadonly ? readonly(res) : reactive(res);\r\n        }\r\n        return res;\r\n    };\r\n}\r\nconst set = /*#__PURE__*/ createSetter();\r\nconst shallowSet = /*#__PURE__*/ createSetter(true);\r\nfunction createSetter(shallow = false) {\r\n    return function set(target, key, value, receiver) {\r\n        const oldValue = target[key];\r\n        if (!shallow) {\r\n            value = toRaw(value);\r\n            if (!isArray(target) && isRef(oldValue) && !isRef(value)) {\r\n                oldValue.value = value;\r\n                return true;\r\n            }\r\n        }\r\n        const hadKey = isArray(target) && isIntegerKey(key)\r\n            ? Number(key) < target.length\r\n            : hasOwn(target, key);\r\n        const result = Reflect.set(target, key, value, receiver);\r\n        // don't trigger if target is something up in the prototype chain of original\r\n        if (target === toRaw(receiver)) {\r\n            if (!hadKey) {\r\n                trigger(target, \"add\" /* ADD */, key, value);\r\n            }\r\n            else if (hasChanged(value, oldValue)) {\r\n                trigger(target, \"set\" /* SET */, key, value, oldValue);\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n}\r\nfunction deleteProperty(target, key) {\r\n    const hadKey = hasOwn(target, key);\r\n    const oldValue = target[key];\r\n    const result = Reflect.deleteProperty(target, key);\r\n    if (result && hadKey) {\r\n        trigger(target, \"delete\" /* DELETE */, key, undefined, oldValue);\r\n    }\r\n    return result;\r\n}\r\nfunction has(target, key) {\r\n    const result = Reflect.has(target, key);\r\n    if (!isSymbol(key) || !builtInSymbols.has(key)) {\r\n        track(target, \"has\" /* HAS */, key);\r\n    }\r\n    return result;\r\n}\r\nfunction ownKeys(target) {\r\n    track(target, \"iterate\" /* ITERATE */, ITERATE_KEY);\r\n    return Reflect.ownKeys(target);\r\n}\r\nconst mutableHandlers = {\r\n    get,\r\n    set,\r\n    deleteProperty,\r\n    has,\r\n    ownKeys\r\n};\r\nconst readonlyHandlers = {\r\n    get: readonlyGet,\r\n    set(target, key) {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            console.warn(`Set operation on key \"${String(key)}\" failed: target is readonly.`, target);\r\n        }\r\n        return true;\r\n    },\r\n    deleteProperty(target, key) {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            console.warn(`Delete operation on key \"${String(key)}\" failed: target is readonly.`, target);\r\n        }\r\n        return true;\r\n    }\r\n};\r\nconst shallowReactiveHandlers = extend({}, mutableHandlers, {\r\n    get: shallowGet,\r\n    set: shallowSet\r\n});\r\n// Props handlers are special in the sense that it should not unwrap top-level\r\n// refs (in order to allow refs to be explicitly passed down), but should\r\n// retain the reactivity of the normal readonly object.\r\nconst shallowReadonlyHandlers = extend({}, readonlyHandlers, {\r\n    get: shallowReadonlyGet\r\n});\n\nconst toReactive = (value) => isObject(value) ? reactive(value) : value;\r\nconst toReadonly = (value) => isObject(value) ? readonly(value) : value;\r\nconst toShallow = (value) => value;\r\nconst getProto = (v) => Reflect.getPrototypeOf(v);\r\nfunction get$1(target, key, isReadonly = false, isShallow = false) {\r\n    // #1772: readonly(reactive(Map)) should return readonly + reactive version\r\n    // of the value\r\n    target = target[\"__v_raw\" /* RAW */];\r\n    const rawTarget = toRaw(target);\r\n    const rawKey = toRaw(key);\r\n    if (key !== rawKey) {\r\n        !isReadonly && track(rawTarget, \"get\" /* GET */, key);\r\n    }\r\n    !isReadonly && track(rawTarget, \"get\" /* GET */, rawKey);\r\n    const { has } = getProto(rawTarget);\r\n    const wrap = isReadonly ? toReadonly : isShallow ? toShallow : toReactive;\r\n    if (has.call(rawTarget, key)) {\r\n        return wrap(target.get(key));\r\n    }\r\n    else if (has.call(rawTarget, rawKey)) {\r\n        return wrap(target.get(rawKey));\r\n    }\r\n}\r\nfunction has$1(key, isReadonly = false) {\r\n    const target = this[\"__v_raw\" /* RAW */];\r\n    const rawTarget = toRaw(target);\r\n    const rawKey = toRaw(key);\r\n    if (key !== rawKey) {\r\n        !isReadonly && track(rawTarget, \"has\" /* HAS */, key);\r\n    }\r\n    !isReadonly && track(rawTarget, \"has\" /* HAS */, rawKey);\r\n    return key === rawKey\r\n        ? target.has(key)\r\n        : target.has(key) || target.has(rawKey);\r\n}\r\nfunction size(target, isReadonly = false) {\r\n    target = target[\"__v_raw\" /* RAW */];\r\n    !isReadonly && track(toRaw(target), \"iterate\" /* ITERATE */, ITERATE_KEY);\r\n    return Reflect.get(target, 'size', target);\r\n}\r\nfunction add(value) {\r\n    value = toRaw(value);\r\n    const target = toRaw(this);\r\n    const proto = getProto(target);\r\n    const hadKey = proto.has.call(target, value);\r\n    const result = target.add(value);\r\n    if (!hadKey) {\r\n        trigger(target, \"add\" /* ADD */, value, value);\r\n    }\r\n    return result;\r\n}\r\nfunction set$1(key, value) {\r\n    value = toRaw(value);\r\n    const target = toRaw(this);\r\n    const { has, get } = getProto(target);\r\n    let hadKey = has.call(target, key);\r\n    if (!hadKey) {\r\n        key = toRaw(key);\r\n        hadKey = has.call(target, key);\r\n    }\r\n    else if ((process.env.NODE_ENV !== 'production')) {\r\n        checkIdentityKeys(target, has, key);\r\n    }\r\n    const oldValue = get.call(target, key);\r\n    const result = target.set(key, value);\r\n    if (!hadKey) {\r\n        trigger(target, \"add\" /* ADD */, key, value);\r\n    }\r\n    else if (hasChanged(value, oldValue)) {\r\n        trigger(target, \"set\" /* SET */, key, value, oldValue);\r\n    }\r\n    return result;\r\n}\r\nfunction deleteEntry(key) {\r\n    const target = toRaw(this);\r\n    const { has, get } = getProto(target);\r\n    let hadKey = has.call(target, key);\r\n    if (!hadKey) {\r\n        key = toRaw(key);\r\n        hadKey = has.call(target, key);\r\n    }\r\n    else if ((process.env.NODE_ENV !== 'production')) {\r\n        checkIdentityKeys(target, has, key);\r\n    }\r\n    const oldValue = get ? get.call(target, key) : undefined;\r\n    // forward the operation before queueing reactions\r\n    const result = target.delete(key);\r\n    if (hadKey) {\r\n        trigger(target, \"delete\" /* DELETE */, key, undefined, oldValue);\r\n    }\r\n    return result;\r\n}\r\nfunction clear() {\r\n    const target = toRaw(this);\r\n    const hadItems = target.size !== 0;\r\n    const oldTarget = (process.env.NODE_ENV !== 'production')\r\n        ? isMap(target)\r\n            ? new Map(target)\r\n            : new Set(target)\r\n        : undefined;\r\n    // forward the operation before queueing reactions\r\n    const result = target.clear();\r\n    if (hadItems) {\r\n        trigger(target, \"clear\" /* CLEAR */, undefined, undefined, oldTarget);\r\n    }\r\n    return result;\r\n}\r\nfunction createForEach(isReadonly, isShallow) {\r\n    return function forEach(callback, thisArg) {\r\n        const observed = this;\r\n        const target = observed[\"__v_raw\" /* RAW */];\r\n        const rawTarget = toRaw(target);\r\n        const wrap = isReadonly ? toReadonly : isShallow ? toShallow : toReactive;\r\n        !isReadonly && track(rawTarget, \"iterate\" /* ITERATE */, ITERATE_KEY);\r\n        return target.forEach((value, key) => {\r\n            // important: make sure the callback is\r\n            // 1. invoked with the reactive map as `this` and 3rd arg\r\n            // 2. the value received should be a corresponding reactive/readonly.\r\n            return callback.call(thisArg, wrap(value), wrap(key), observed);\r\n        });\r\n    };\r\n}\r\nfunction createIterableMethod(method, isReadonly, isShallow) {\r\n    return function (...args) {\r\n        const target = this[\"__v_raw\" /* RAW */];\r\n        const rawTarget = toRaw(target);\r\n        const targetIsMap = isMap(rawTarget);\r\n        const isPair = method === 'entries' || (method === Symbol.iterator && targetIsMap);\r\n        const isKeyOnly = method === 'keys' && targetIsMap;\r\n        const innerIterator = target[method](...args);\r\n        const wrap = isReadonly ? toReadonly : isShallow ? toShallow : toReactive;\r\n        !isReadonly &&\r\n            track(rawTarget, \"iterate\" /* ITERATE */, isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);\r\n        // return a wrapped iterator which returns observed versions of the\r\n        // values emitted from the real iterator\r\n        return {\r\n            // iterator protocol\r\n            next() {\r\n                const { value, done } = innerIterator.next();\r\n                return done\r\n                    ? { value, done }\r\n                    : {\r\n                        value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\r\n                        done\r\n                    };\r\n            },\r\n            // iterable protocol\r\n            [Symbol.iterator]() {\r\n                return this;\r\n            }\r\n        };\r\n    };\r\n}\r\nfunction createReadonlyMethod(type) {\r\n    return function (...args) {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            const key = args[0] ? `on key \"${args[0]}\" ` : ``;\r\n            console.warn(`${capitalize(type)} operation ${key}failed: target is readonly.`, toRaw(this));\r\n        }\r\n        return type === \"delete\" /* DELETE */ ? false : this;\r\n    };\r\n}\r\nconst mutableInstrumentations = {\r\n    get(key) {\r\n        return get$1(this, key);\r\n    },\r\n    get size() {\r\n        return size(this);\r\n    },\r\n    has: has$1,\r\n    add,\r\n    set: set$1,\r\n    delete: deleteEntry,\r\n    clear,\r\n    forEach: createForEach(false, false)\r\n};\r\nconst shallowInstrumentations = {\r\n    get(key) {\r\n        return get$1(this, key, false, true);\r\n    },\r\n    get size() {\r\n        return size(this);\r\n    },\r\n    has: has$1,\r\n    add,\r\n    set: set$1,\r\n    delete: deleteEntry,\r\n    clear,\r\n    forEach: createForEach(false, true)\r\n};\r\nconst readonlyInstrumentations = {\r\n    get(key) {\r\n        return get$1(this, key, true);\r\n    },\r\n    get size() {\r\n        return size(this, true);\r\n    },\r\n    has(key) {\r\n        return has$1.call(this, key, true);\r\n    },\r\n    add: createReadonlyMethod(\"add\" /* ADD */),\r\n    set: createReadonlyMethod(\"set\" /* SET */),\r\n    delete: createReadonlyMethod(\"delete\" /* DELETE */),\r\n    clear: createReadonlyMethod(\"clear\" /* CLEAR */),\r\n    forEach: createForEach(true, false)\r\n};\r\nconst iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator];\r\niteratorMethods.forEach(method => {\r\n    mutableInstrumentations[method] = createIterableMethod(method, false, false);\r\n    readonlyInstrumentations[method] = createIterableMethod(method, true, false);\r\n    shallowInstrumentations[method] = createIterableMethod(method, false, true);\r\n});\r\nfunction createInstrumentationGetter(isReadonly, shallow) {\r\n    const instrumentations = shallow\r\n        ? shallowInstrumentations\r\n        : isReadonly\r\n            ? readonlyInstrumentations\r\n            : mutableInstrumentations;\r\n    return (target, key, receiver) => {\r\n        if (key === \"__v_isReactive\" /* IS_REACTIVE */) {\r\n            return !isReadonly;\r\n        }\r\n        else if (key === \"__v_isReadonly\" /* IS_READONLY */) {\r\n            return isReadonly;\r\n        }\r\n        else if (key === \"__v_raw\" /* RAW */) {\r\n            return target;\r\n        }\r\n        return Reflect.get(hasOwn(instrumentations, key) && key in target\r\n            ? instrumentations\r\n            : target, key, receiver);\r\n    };\r\n}\r\nconst mutableCollectionHandlers = {\r\n    get: createInstrumentationGetter(false, false)\r\n};\r\nconst shallowCollectionHandlers = {\r\n    get: createInstrumentationGetter(false, true)\r\n};\r\nconst readonlyCollectionHandlers = {\r\n    get: createInstrumentationGetter(true, false)\r\n};\r\nfunction checkIdentityKeys(target, has, key) {\r\n    const rawKey = toRaw(key);\r\n    if (rawKey !== key && has.call(target, rawKey)) {\r\n        const type = toRawType(target);\r\n        console.warn(`Reactive ${type} contains both the raw and reactive ` +\r\n            `versions of the same object${type === `Map` ? ` as keys` : ``}, ` +\r\n            `which can lead to inconsistencies. ` +\r\n            `Avoid differentiating between the raw and reactive versions ` +\r\n            `of an object and only use the reactive version if possible.`);\r\n    }\r\n}\n\nconst reactiveMap = new WeakMap();\r\nconst readonlyMap = new WeakMap();\r\nfunction targetTypeMap(rawType) {\r\n    switch (rawType) {\r\n        case 'Object':\r\n        case 'Array':\r\n            return 1 /* COMMON */;\r\n        case 'Map':\r\n        case 'Set':\r\n        case 'WeakMap':\r\n        case 'WeakSet':\r\n            return 2 /* COLLECTION */;\r\n        default:\r\n            return 0 /* INVALID */;\r\n    }\r\n}\r\nfunction getTargetType(value) {\r\n    return value[\"__v_skip\" /* SKIP */] || !Object.isExtensible(value)\r\n        ? 0 /* INVALID */\r\n        : targetTypeMap(toRawType(value));\r\n}\r\nfunction reactive(target) {\r\n    // if trying to observe a readonly proxy, return the readonly version.\r\n    if (target && target[\"__v_isReadonly\" /* IS_READONLY */]) {\r\n        return target;\r\n    }\r\n    return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers);\r\n}\r\n// Return a reactive-copy of the original object, where only the root level\r\n// properties are reactive, and does NOT unwrap refs nor recursively convert\r\n// returned properties.\r\nfunction shallowReactive(target) {\r\n    return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers);\r\n}\r\nfunction readonly(target) {\r\n    return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers);\r\n}\r\n// Return a reactive-copy of the original object, where only the root level\r\n// properties are readonly, and does NOT unwrap refs nor recursively convert\r\n// returned properties.\r\n// This is used for creating the props proxy object for stateful components.\r\nfunction shallowReadonly(target) {\r\n    return createReactiveObject(target, true, shallowReadonlyHandlers, readonlyCollectionHandlers);\r\n}\r\nfunction createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers) {\r\n    if (!isObject(target)) {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            console.warn(`value cannot be made reactive: ${String(target)}`);\r\n        }\r\n        return target;\r\n    }\r\n    // target is already a Proxy, return it.\r\n    // exception: calling readonly() on a reactive object\r\n    if (target[\"__v_raw\" /* RAW */] &&\r\n        !(isReadonly && target[\"__v_isReactive\" /* IS_REACTIVE */])) {\r\n        return target;\r\n    }\r\n    // target already has corresponding Proxy\r\n    const proxyMap = isReadonly ? readonlyMap : reactiveMap;\r\n    const existingProxy = proxyMap.get(target);\r\n    if (existingProxy) {\r\n        return existingProxy;\r\n    }\r\n    // only a whitelist of value types can be observed.\r\n    const targetType = getTargetType(target);\r\n    if (targetType === 0 /* INVALID */) {\r\n        return target;\r\n    }\r\n    const proxy = new Proxy(target, targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers);\r\n    proxyMap.set(target, proxy);\r\n    return proxy;\r\n}\r\nfunction isReactive(value) {\r\n    if (isReadonly(value)) {\r\n        return isReactive(value[\"__v_raw\" /* RAW */]);\r\n    }\r\n    return !!(value && value[\"__v_isReactive\" /* IS_REACTIVE */]);\r\n}\r\nfunction isReadonly(value) {\r\n    return !!(value && value[\"__v_isReadonly\" /* IS_READONLY */]);\r\n}\r\nfunction isProxy(value) {\r\n    return isReactive(value) || isReadonly(value);\r\n}\r\nfunction toRaw(observed) {\r\n    return ((observed && toRaw(observed[\"__v_raw\" /* RAW */])) || observed);\r\n}\r\nfunction markRaw(value) {\r\n    def(value, \"__v_skip\" /* SKIP */, true);\r\n    return value;\r\n}\n\nconst convert = (val) => isObject(val) ? reactive(val) : val;\r\nfunction isRef(r) {\r\n    return Boolean(r && r.__v_isRef === true);\r\n}\r\nfunction ref(value) {\r\n    return createRef(value);\r\n}\r\nfunction shallowRef(value) {\r\n    return createRef(value, true);\r\n}\r\nclass RefImpl {\r\n    constructor(_rawValue, _shallow = false) {\r\n        this._rawValue = _rawValue;\r\n        this._shallow = _shallow;\r\n        this.__v_isRef = true;\r\n        this._value = _shallow ? _rawValue : convert(_rawValue);\r\n    }\r\n    get value() {\r\n        track(toRaw(this), \"get\" /* GET */, 'value');\r\n        return this._value;\r\n    }\r\n    set value(newVal) {\r\n        if (hasChanged(toRaw(newVal), this._rawValue)) {\r\n            this._rawValue = newVal;\r\n            this._value = this._shallow ? newVal : convert(newVal);\r\n            trigger(toRaw(this), \"set\" /* SET */, 'value', newVal);\r\n        }\r\n    }\r\n}\r\nfunction createRef(rawValue, shallow = false) {\r\n    if (isRef(rawValue)) {\r\n        return rawValue;\r\n    }\r\n    return new RefImpl(rawValue, shallow);\r\n}\r\nfunction triggerRef(ref) {\r\n    trigger(toRaw(ref), \"set\" /* SET */, 'value', (process.env.NODE_ENV !== 'production') ? ref.value : void 0);\r\n}\r\nfunction unref(ref) {\r\n    return isRef(ref) ? ref.value : ref;\r\n}\r\nconst shallowUnwrapHandlers = {\r\n    get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),\r\n    set: (target, key, value, receiver) => {\r\n        const oldValue = target[key];\r\n        if (isRef(oldValue) && !isRef(value)) {\r\n            oldValue.value = value;\r\n            return true;\r\n        }\r\n        else {\r\n            return Reflect.set(target, key, value, receiver);\r\n        }\r\n    }\r\n};\r\nfunction proxyRefs(objectWithRefs) {\r\n    return isReactive(objectWithRefs)\r\n        ? objectWithRefs\r\n        : new Proxy(objectWithRefs, shallowUnwrapHandlers);\r\n}\r\nclass CustomRefImpl {\r\n    constructor(factory) {\r\n        this.__v_isRef = true;\r\n        const { get, set } = factory(() => track(this, \"get\" /* GET */, 'value'), () => trigger(this, \"set\" /* SET */, 'value'));\r\n        this._get = get;\r\n        this._set = set;\r\n    }\r\n    get value() {\r\n        return this._get();\r\n    }\r\n    set value(newVal) {\r\n        this._set(newVal);\r\n    }\r\n}\r\nfunction customRef(factory) {\r\n    return new CustomRefImpl(factory);\r\n}\r\nfunction toRefs(object) {\r\n    if ((process.env.NODE_ENV !== 'production') && !isProxy(object)) {\r\n        console.warn(`toRefs() expects a reactive object but received a plain one.`);\r\n    }\r\n    const ret = isArray(object) ? new Array(object.length) : {};\r\n    for (const key in object) {\r\n        ret[key] = toRef(object, key);\r\n    }\r\n    return ret;\r\n}\r\nclass ObjectRefImpl {\r\n    constructor(_object, _key) {\r\n        this._object = _object;\r\n        this._key = _key;\r\n        this.__v_isRef = true;\r\n    }\r\n    get value() {\r\n        return this._object[this._key];\r\n    }\r\n    set value(newVal) {\r\n        this._object[this._key] = newVal;\r\n    }\r\n}\r\nfunction toRef(object, key) {\r\n    return isRef(object[key])\r\n        ? object[key]\r\n        : new ObjectRefImpl(object, key);\r\n}\n\nclass ComputedRefImpl {\r\n    constructor(getter, _setter, isReadonly) {\r\n        this._setter = _setter;\r\n        this._dirty = true;\r\n        this.__v_isRef = true;\r\n        this.effect = effect(getter, {\r\n            lazy: true,\r\n            scheduler: () => {\r\n                if (!this._dirty) {\r\n                    this._dirty = true;\r\n                    trigger(toRaw(this), \"set\" /* SET */, 'value');\r\n                }\r\n            }\r\n        });\r\n        this[\"__v_isReadonly\" /* IS_READONLY */] = isReadonly;\r\n    }\r\n    get value() {\r\n        if (this._dirty) {\r\n            this._value = this.effect();\r\n            this._dirty = false;\r\n        }\r\n        track(toRaw(this), \"get\" /* GET */, 'value');\r\n        return this._value;\r\n    }\r\n    set value(newValue) {\r\n        this._setter(newValue);\r\n    }\r\n}\r\nfunction computed(getterOrOptions) {\r\n    let getter;\r\n    let setter;\r\n    if (isFunction(getterOrOptions)) {\r\n        getter = getterOrOptions;\r\n        setter = (process.env.NODE_ENV !== 'production')\r\n            ? () => {\r\n                console.warn('Write operation failed: computed value is readonly');\r\n            }\r\n            : NOOP;\r\n    }\r\n    else {\r\n        getter = getterOrOptions.get;\r\n        setter = getterOrOptions.set;\r\n    }\r\n    return new ComputedRefImpl(getter, setter, isFunction(getterOrOptions) || !getterOrOptions.set);\r\n}\n\nexport { ITERATE_KEY, computed, customRef, effect, enableTracking, isProxy, isReactive, isReadonly, isRef, markRaw, pauseTracking, proxyRefs, reactive, readonly, ref, resetTracking, shallowReactive, shallowReadonly, shallowRef, stop, toRaw, toRef, toRefs, track, trigger, triggerRef, unref };\n"]},"metadata":{},"sourceType":"module"}