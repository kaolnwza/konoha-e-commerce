{"ast":null,"code":"import { pauseTracking, resetTracking, isRef, toRaw, shallowReactive, trigger, isReactive, effect, stop, isProxy, reactive, shallowReadonly, track, proxyRefs, computed as computed$1, ref, isReadonly } from '@vue/reactivity';\nexport { customRef, isProxy, isReactive, isReadonly, isRef, markRaw, proxyRefs, reactive, readonly, ref, shallowReactive, shallowReadonly, shallowRef, toRaw, toRef, toRefs, triggerRef, unref } from '@vue/reactivity';\nimport { isString, isFunction, isPromise, isArray, extend, EMPTY_OBJ, capitalize, hyphenate, camelize, isOn, hasOwn, isModelListener, toNumber, def, isReservedProp, EMPTY_ARR, isObject, toRawType, makeMap, remove, NOOP, hasChanged, isSet, isMap, invokeArrayFns, NO, getGlobalThis, normalizeClass, normalizeStyle, isGloballyWhitelisted } from '@vue/shared';\nexport { camelize, capitalize, toDisplayString } from '@vue/shared';\nconst stack = [];\n\nfunction pushWarningContext(vnode) {\n  stack.push(vnode);\n}\n\nfunction popWarningContext() {\n  stack.pop();\n}\n\nfunction warn(msg, ...args) {\n  // avoid props formatting or warn handler tracking deps that might be mutated\n  // during patch, leading to infinite recursion.\n  pauseTracking();\n  const instance = stack.length ? stack[stack.length - 1].component : null;\n  const appWarnHandler = instance && instance.appContext.config.warnHandler;\n  const trace = getComponentTrace();\n\n  if (appWarnHandler) {\n    callWithErrorHandling(appWarnHandler, instance, 11\n    /* APP_WARN_HANDLER */\n    , [msg + args.join(''), instance && instance.proxy, trace.map(({\n      vnode\n    }) => `at <${formatComponentName(instance, vnode.type)}>`).join('\\n'), trace]);\n  } else {\n    const warnArgs = [`[Vue warn]: ${msg}`, ...args];\n    /* istanbul ignore if */\n\n    if (trace.length && // avoid spamming console during tests\n    !false) {\n      warnArgs.push(`\\n`, ...formatTrace(trace));\n    }\n\n    console.warn(...warnArgs);\n  }\n\n  resetTracking();\n}\n\nfunction getComponentTrace() {\n  let currentVNode = stack[stack.length - 1];\n\n  if (!currentVNode) {\n    return [];\n  } // we can't just use the stack because it will be incomplete during updates\n  // that did not start from the root. Re-construct the parent chain using\n  // instance parent pointers.\n\n\n  const normalizedStack = [];\n\n  while (currentVNode) {\n    const last = normalizedStack[0];\n\n    if (last && last.vnode === currentVNode) {\n      last.recurseCount++;\n    } else {\n      normalizedStack.push({\n        vnode: currentVNode,\n        recurseCount: 0\n      });\n    }\n\n    const parentInstance = currentVNode.component && currentVNode.component.parent;\n    currentVNode = parentInstance && parentInstance.vnode;\n  }\n\n  return normalizedStack;\n}\n/* istanbul ignore next */\n\n\nfunction formatTrace(trace) {\n  const logs = [];\n  trace.forEach((entry, i) => {\n    logs.push(...(i === 0 ? [] : [`\\n`]), ...formatTraceEntry(entry));\n  });\n  return logs;\n}\n\nfunction formatTraceEntry({\n  vnode,\n  recurseCount\n}) {\n  const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;\n  const isRoot = vnode.component ? vnode.component.parent == null : false;\n  const open = ` at <${formatComponentName(vnode.component, vnode.type, isRoot)}`;\n  const close = `>` + postfix;\n  return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];\n}\n/* istanbul ignore next */\n\n\nfunction formatProps(props) {\n  const res = [];\n  const keys = Object.keys(props);\n  keys.slice(0, 3).forEach(key => {\n    res.push(...formatProp(key, props[key]));\n  });\n\n  if (keys.length > 3) {\n    res.push(` ...`);\n  }\n\n  return res;\n}\n/* istanbul ignore next */\n\n\nfunction formatProp(key, value, raw) {\n  if (isString(value)) {\n    value = JSON.stringify(value);\n    return raw ? value : [`${key}=${value}`];\n  } else if (typeof value === 'number' || typeof value === 'boolean' || value == null) {\n    return raw ? value : [`${key}=${value}`];\n  } else if (isRef(value)) {\n    value = formatProp(key, toRaw(value.value), true);\n    return raw ? value : [`${key}=Ref<`, value, `>`];\n  } else if (isFunction(value)) {\n    return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];\n  } else {\n    value = toRaw(value);\n    return raw ? value : [`${key}=`, value];\n  }\n}\n\nconst ErrorTypeStrings = {\n  [\"bc\"\n  /* BEFORE_CREATE */\n  ]: 'beforeCreate hook',\n  [\"c\"\n  /* CREATED */\n  ]: 'created hook',\n  [\"bm\"\n  /* BEFORE_MOUNT */\n  ]: 'beforeMount hook',\n  [\"m\"\n  /* MOUNTED */\n  ]: 'mounted hook',\n  [\"bu\"\n  /* BEFORE_UPDATE */\n  ]: 'beforeUpdate hook',\n  [\"u\"\n  /* UPDATED */\n  ]: 'updated',\n  [\"bum\"\n  /* BEFORE_UNMOUNT */\n  ]: 'beforeUnmount hook',\n  [\"um\"\n  /* UNMOUNTED */\n  ]: 'unmounted hook',\n  [\"a\"\n  /* ACTIVATED */\n  ]: 'activated hook',\n  [\"da\"\n  /* DEACTIVATED */\n  ]: 'deactivated hook',\n  [\"ec\"\n  /* ERROR_CAPTURED */\n  ]: 'errorCaptured hook',\n  [\"rtc\"\n  /* RENDER_TRACKED */\n  ]: 'renderTracked hook',\n  [\"rtg\"\n  /* RENDER_TRIGGERED */\n  ]: 'renderTriggered hook',\n  [0\n  /* SETUP_FUNCTION */\n  ]: 'setup function',\n  [1\n  /* RENDER_FUNCTION */\n  ]: 'render function',\n  [2\n  /* WATCH_GETTER */\n  ]: 'watcher getter',\n  [3\n  /* WATCH_CALLBACK */\n  ]: 'watcher callback',\n  [4\n  /* WATCH_CLEANUP */\n  ]: 'watcher cleanup function',\n  [5\n  /* NATIVE_EVENT_HANDLER */\n  ]: 'native event handler',\n  [6\n  /* COMPONENT_EVENT_HANDLER */\n  ]: 'component event handler',\n  [7\n  /* VNODE_HOOK */\n  ]: 'vnode hook',\n  [8\n  /* DIRECTIVE_HOOK */\n  ]: 'directive hook',\n  [9\n  /* TRANSITION_HOOK */\n  ]: 'transition hook',\n  [10\n  /* APP_ERROR_HANDLER */\n  ]: 'app errorHandler',\n  [11\n  /* APP_WARN_HANDLER */\n  ]: 'app warnHandler',\n  [12\n  /* FUNCTION_REF */\n  ]: 'ref function',\n  [13\n  /* ASYNC_COMPONENT_LOADER */\n  ]: 'async component loader',\n  [14\n  /* SCHEDULER */\n  ]: 'scheduler flush. This is likely a Vue internals bug. ' + 'Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/vue-next'\n};\n\nfunction callWithErrorHandling(fn, instance, type, args) {\n  let res;\n\n  try {\n    res = args ? fn(...args) : fn();\n  } catch (err) {\n    handleError(err, instance, type);\n  }\n\n  return res;\n}\n\nfunction callWithAsyncErrorHandling(fn, instance, type, args) {\n  if (isFunction(fn)) {\n    const res = callWithErrorHandling(fn, instance, type, args);\n\n    if (res && isPromise(res)) {\n      res.catch(err => {\n        handleError(err, instance, type);\n      });\n    }\n\n    return res;\n  }\n\n  const values = [];\n\n  for (let i = 0; i < fn.length; i++) {\n    values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));\n  }\n\n  return values;\n}\n\nfunction handleError(err, instance, type, throwInDev = true) {\n  const contextVNode = instance ? instance.vnode : null;\n\n  if (instance) {\n    let cur = instance.parent; // the exposed instance is the render proxy to keep it consistent with 2.x\n\n    const exposedInstance = instance.proxy; // in production the hook receives only the error code\n\n    const errorInfo = process.env.NODE_ENV !== 'production' ? ErrorTypeStrings[type] : type;\n\n    while (cur) {\n      const errorCapturedHooks = cur.ec;\n\n      if (errorCapturedHooks) {\n        for (let i = 0; i < errorCapturedHooks.length; i++) {\n          if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {\n            return;\n          }\n        }\n      }\n\n      cur = cur.parent;\n    } // app-level handling\n\n\n    const appErrorHandler = instance.appContext.config.errorHandler;\n\n    if (appErrorHandler) {\n      callWithErrorHandling(appErrorHandler, null, 10\n      /* APP_ERROR_HANDLER */\n      , [err, exposedInstance, errorInfo]);\n      return;\n    }\n  }\n\n  logError(err, type, contextVNode, throwInDev);\n}\n\nfunction logError(err, type, contextVNode, throwInDev = true) {\n  if (process.env.NODE_ENV !== 'production') {\n    const info = ErrorTypeStrings[type];\n\n    if (contextVNode) {\n      pushWarningContext(contextVNode);\n    }\n\n    warn(`Unhandled error${info ? ` during execution of ${info}` : ``}`);\n\n    if (contextVNode) {\n      popWarningContext();\n    } // crash in dev by default so it's more noticeable\n\n\n    if (throwInDev) {\n      throw err;\n    } else {\n      console.error(err);\n    }\n  } else {\n    // recover in prod to reduce the impact on end-user\n    console.error(err);\n  }\n}\n\nlet isFlushing = false;\nlet isFlushPending = false;\nconst queue = [];\nlet flushIndex = 0;\nconst pendingPreFlushCbs = [];\nlet activePreFlushCbs = null;\nlet preFlushIndex = 0;\nconst pendingPostFlushCbs = [];\nlet activePostFlushCbs = null;\nlet postFlushIndex = 0;\nconst resolvedPromise = Promise.resolve();\nlet currentFlushPromise = null;\nlet currentPreFlushParentJob = null;\nconst RECURSION_LIMIT = 100;\n\nfunction nextTick(fn) {\n  const p = currentFlushPromise || resolvedPromise;\n  return fn ? p.then(this ? fn.bind(this) : fn) : p;\n}\n\nfunction queueJob(job) {\n  // the dedupe search uses the startIndex argument of Array.includes()\n  // by default the search index includes the current job that is being run\n  // so it cannot recursively trigger itself again.\n  // if the job is a watch() callback, the search will start with a +1 index to\n  // allow it recursively trigger itself - it is the user's responsibility to\n  // ensure it doesn't end up in an infinite loop.\n  if ((!queue.length || !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) && job !== currentPreFlushParentJob) {\n    queue.push(job);\n    queueFlush();\n  }\n}\n\nfunction queueFlush() {\n  if (!isFlushing && !isFlushPending) {\n    isFlushPending = true;\n    currentFlushPromise = resolvedPromise.then(flushJobs);\n  }\n}\n\nfunction invalidateJob(job) {\n  const i = queue.indexOf(job);\n\n  if (i > -1) {\n    queue[i] = null;\n  }\n}\n\nfunction queueCb(cb, activeQueue, pendingQueue, index) {\n  if (!isArray(cb)) {\n    if (!activeQueue || !activeQueue.includes(cb, cb.allowRecurse ? index + 1 : index)) {\n      pendingQueue.push(cb);\n    }\n  } else {\n    // if cb is an array, it is a component lifecycle hook which can only be\n    // triggered by a job, which is already deduped in the main queue, so\n    // we can skip duplicate check here to improve perf\n    pendingQueue.push(...cb);\n  }\n\n  queueFlush();\n}\n\nfunction queuePreFlushCb(cb) {\n  queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex);\n}\n\nfunction queuePostFlushCb(cb) {\n  queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex);\n}\n\nfunction flushPreFlushCbs(seen, parentJob = null) {\n  if (pendingPreFlushCbs.length) {\n    currentPreFlushParentJob = parentJob;\n    activePreFlushCbs = [...new Set(pendingPreFlushCbs)];\n    pendingPreFlushCbs.length = 0;\n\n    if (process.env.NODE_ENV !== 'production') {\n      seen = seen || new Map();\n    }\n\n    for (preFlushIndex = 0; preFlushIndex < activePreFlushCbs.length; preFlushIndex++) {\n      if (process.env.NODE_ENV !== 'production') {\n        checkRecursiveUpdates(seen, activePreFlushCbs[preFlushIndex]);\n      }\n\n      activePreFlushCbs[preFlushIndex]();\n    }\n\n    activePreFlushCbs = null;\n    preFlushIndex = 0;\n    currentPreFlushParentJob = null; // recursively flush until it drains\n\n    flushPreFlushCbs(seen, parentJob);\n  }\n}\n\nfunction flushPostFlushCbs(seen) {\n  if (pendingPostFlushCbs.length) {\n    const deduped = [...new Set(pendingPostFlushCbs)];\n    pendingPostFlushCbs.length = 0; // #1947 already has active queue, nested flushPostFlushCbs call\n\n    if (activePostFlushCbs) {\n      activePostFlushCbs.push(...deduped);\n      return;\n    }\n\n    activePostFlushCbs = deduped;\n\n    if (process.env.NODE_ENV !== 'production') {\n      seen = seen || new Map();\n    }\n\n    activePostFlushCbs.sort((a, b) => getId(a) - getId(b));\n\n    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {\n      if (process.env.NODE_ENV !== 'production') {\n        checkRecursiveUpdates(seen, activePostFlushCbs[postFlushIndex]);\n      }\n\n      activePostFlushCbs[postFlushIndex]();\n    }\n\n    activePostFlushCbs = null;\n    postFlushIndex = 0;\n  }\n}\n\nconst getId = job => job.id == null ? Infinity : job.id;\n\nfunction flushJobs(seen) {\n  isFlushPending = false;\n  isFlushing = true;\n\n  if (process.env.NODE_ENV !== 'production') {\n    seen = seen || new Map();\n  }\n\n  flushPreFlushCbs(seen); // Sort queue before flush.\n  // This ensures that:\n  // 1. Components are updated from parent to child. (because parent is always\n  //    created before the child so its render effect will have smaller\n  //    priority number)\n  // 2. If a component is unmounted during a parent component's update,\n  //    its update can be skipped.\n  // Jobs can never be null before flush starts, since they are only invalidated\n  // during execution of another flushed job.\n\n  queue.sort((a, b) => getId(a) - getId(b));\n\n  try {\n    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {\n      const job = queue[flushIndex];\n\n      if (job) {\n        if (process.env.NODE_ENV !== 'production') {\n          checkRecursiveUpdates(seen, job);\n        }\n\n        callWithErrorHandling(job, null, 14\n        /* SCHEDULER */\n        );\n      }\n    }\n  } finally {\n    flushIndex = 0;\n    queue.length = 0;\n    flushPostFlushCbs(seen);\n    isFlushing = false;\n    currentFlushPromise = null; // some postFlushCb queued jobs!\n    // keep flushing until it drains.\n\n    if (queue.length || pendingPostFlushCbs.length) {\n      flushJobs(seen);\n    }\n  }\n}\n\nfunction checkRecursiveUpdates(seen, fn) {\n  if (!seen.has(fn)) {\n    seen.set(fn, 1);\n  } else {\n    const count = seen.get(fn);\n\n    if (count > RECURSION_LIMIT) {\n      throw new Error(`Maximum recursive updates exceeded. ` + `This means you have a reactive effect that is mutating its own ` + `dependencies and thus recursively triggering itself. Possible sources ` + `include component template, render function, updated hook or ` + `watcher source function.`);\n    } else {\n      seen.set(fn, count + 1);\n    }\n  }\n}\n/* eslint-disable no-restricted-globals */\n\n\nlet isHmrUpdating = false;\nconst hmrDirtyComponents = new Set(); // Expose the HMR runtime on the global object\n// This makes it entirely tree-shakable without polluting the exports and makes\n// it easier to be used in toolings like vue-loader\n// Note: for a component to be eligible for HMR it also needs the __hmrId option\n// to be set so that its instances can be registered / removed.\n\nif (process.env.NODE_ENV !== 'production' && true) {\n  const globalObject = typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {};\n  globalObject.__VUE_HMR_RUNTIME__ = {\n    createRecord: tryWrap(createRecord),\n    rerender: tryWrap(rerender),\n    reload: tryWrap(reload)\n  };\n}\n\nconst map = new Map();\n\nfunction registerHMR(instance) {\n  const id = instance.type.__hmrId;\n  let record = map.get(id);\n\n  if (!record) {\n    createRecord(id);\n    record = map.get(id);\n  }\n\n  record.add(instance);\n}\n\nfunction unregisterHMR(instance) {\n  map.get(instance.type.__hmrId).delete(instance);\n}\n\nfunction createRecord(id) {\n  if (map.has(id)) {\n    return false;\n  }\n\n  map.set(id, new Set());\n  return true;\n}\n\nfunction rerender(id, newRender) {\n  const record = map.get(id);\n  if (!record) return; // Array.from creates a snapshot which avoids the set being mutated during\n  // updates\n\n  Array.from(record).forEach(instance => {\n    if (newRender) {\n      instance.render = newRender;\n    }\n\n    instance.renderCache = []; // this flag forces child components with slot content to update\n\n    isHmrUpdating = true;\n    instance.update();\n    isHmrUpdating = false;\n  });\n}\n\nfunction reload(id, newComp) {\n  const record = map.get(id);\n  if (!record) return; // Array.from creates a snapshot which avoids the set being mutated during\n  // updates\n\n  Array.from(record).forEach(instance => {\n    const comp = instance.type;\n\n    if (!hmrDirtyComponents.has(comp)) {\n      // 1. Update existing comp definition to match new one\n      newComp = isClassComponent(newComp) ? newComp.__vccOpts : newComp;\n      extend(comp, newComp);\n\n      for (const key in comp) {\n        if (!(key in newComp)) {\n          delete comp[key];\n        }\n      } // 2. Mark component dirty. This forces the renderer to replace the component\n      // on patch.\n\n\n      hmrDirtyComponents.add(comp); // 3. Make sure to unmark the component after the reload.\n\n      queuePostFlushCb(() => {\n        hmrDirtyComponents.delete(comp);\n      });\n    }\n\n    if (instance.parent) {\n      // 4. Force the parent instance to re-render. This will cause all updated\n      // components to be unmounted and re-mounted. Queue the update so that we\n      // don't end up forcing the same parent to re-render multiple times.\n      queueJob(instance.parent.update);\n    } else if (instance.appContext.reload) {\n      // root instance mounted via createApp() has a reload method\n      instance.appContext.reload();\n    } else if (typeof window !== 'undefined') {\n      // root instance inside tree created via raw render(). Force reload.\n      window.location.reload();\n    } else {\n      console.warn('[HMR] Root or manually mounted instance modified. Full reload required.');\n    }\n  });\n}\n\nfunction tryWrap(fn) {\n  return (id, arg) => {\n    try {\n      return fn(id, arg);\n    } catch (e) {\n      console.error(e);\n      console.warn(`[HMR] Something went wrong during Vue component hot-reload. ` + `Full reload required.`);\n    }\n  };\n}\n\nlet devtools;\n\nfunction setDevtoolsHook(hook) {\n  devtools = hook;\n}\n\nfunction devtoolsInitApp(app, version) {\n  // TODO queue if devtools is undefined\n  if (!devtools) return;\n  devtools.emit(\"app:init\"\n  /* APP_INIT */\n  , app, version, {\n    Fragment,\n    Text,\n    Comment,\n    Static\n  });\n}\n\nfunction devtoolsUnmountApp(app) {\n  if (!devtools) return;\n  devtools.emit(\"app:unmount\"\n  /* APP_UNMOUNT */\n  , app);\n}\n\nconst devtoolsComponentAdded = /*#__PURE__*/createDevtoolsComponentHook(\"component:added\"\n/* COMPONENT_ADDED */\n);\nconst devtoolsComponentUpdated = /*#__PURE__*/createDevtoolsComponentHook(\"component:updated\"\n/* COMPONENT_UPDATED */\n);\nconst devtoolsComponentRemoved = /*#__PURE__*/createDevtoolsComponentHook(\"component:removed\"\n/* COMPONENT_REMOVED */\n);\n\nfunction createDevtoolsComponentHook(hook) {\n  return component => {\n    if (!devtools) return;\n    devtools.emit(hook, component.appContext.app, component.uid, component.parent ? component.parent.uid : undefined);\n  };\n}\n\nfunction devtoolsComponentEmit(component, event, params) {\n  if (!devtools) return;\n  devtools.emit(\"component:emit\"\n  /* COMPONENT_EMIT */\n  , component.appContext.app, component, event, params);\n}\n\nfunction emit(instance, event, ...args) {\n  const props = instance.vnode.props || EMPTY_OBJ;\n\n  if (process.env.NODE_ENV !== 'production') {\n    const {\n      emitsOptions,\n      propsOptions: [propsOptions]\n    } = instance;\n\n    if (emitsOptions) {\n      if (!(event in emitsOptions)) {\n        if (!propsOptions || !(`on` + capitalize(event) in propsOptions)) {\n          warn(`Component emitted event \"${event}\" but it is neither declared in ` + `the emits option nor as an \"on${capitalize(event)}\" prop.`);\n        }\n      } else {\n        const validator = emitsOptions[event];\n\n        if (isFunction(validator)) {\n          const isValid = validator(...args);\n\n          if (!isValid) {\n            warn(`Invalid event arguments: event validation failed for event \"${event}\".`);\n          }\n        }\n      }\n    }\n  }\n\n  if (process.env.NODE_ENV !== 'production' || __VUE_PROD_DEVTOOLS__) {\n    devtoolsComponentEmit(instance, event, args);\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    const lowerCaseEvent = event.toLowerCase();\n\n    if (lowerCaseEvent !== event && props[`on` + capitalize(lowerCaseEvent)]) {\n      warn(`Event \"${lowerCaseEvent}\" is emitted in component ` + `${formatComponentName(instance, instance.type)} but the handler is registered for \"${event}\". ` + `Note that HTML attributes are case-insensitive and you cannot use ` + `v-on to listen to camelCase events when using in-DOM templates. ` + `You should probably use \"${hyphenate(event)}\" instead of \"${event}\".`);\n    }\n  } // convert handler name to camelCase. See issue #2249\n\n\n  let handlerName = `on${capitalize(camelize(event))}`;\n  let handler = props[handlerName]; // for v-model update:xxx events, also trigger kebab-case equivalent\n  // for props passed via kebab-case\n\n  if (!handler && event.startsWith('update:')) {\n    handlerName = `on${capitalize(hyphenate(event))}`;\n    handler = props[handlerName];\n  }\n\n  if (!handler) {\n    handler = props[handlerName + `Once`];\n\n    if (!instance.emitted) {\n      (instance.emitted = {})[handlerName] = true;\n    } else if (instance.emitted[handlerName]) {\n      return;\n    }\n  }\n\n  if (handler) {\n    callWithAsyncErrorHandling(handler, instance, 6\n    /* COMPONENT_EVENT_HANDLER */\n    , args);\n  }\n}\n\nfunction normalizeEmitsOptions(comp, appContext, asMixin = false) {\n  if (!appContext.deopt && comp.__emits !== undefined) {\n    return comp.__emits;\n  }\n\n  const raw = comp.emits;\n  let normalized = {}; // apply mixin/extends props\n\n  let hasExtends = false;\n\n  if (__VUE_OPTIONS_API__ && !isFunction(comp)) {\n    const extendEmits = raw => {\n      hasExtends = true;\n      extend(normalized, normalizeEmitsOptions(raw, appContext, true));\n    };\n\n    if (!asMixin && appContext.mixins.length) {\n      appContext.mixins.forEach(extendEmits);\n    }\n\n    if (comp.extends) {\n      extendEmits(comp.extends);\n    }\n\n    if (comp.mixins) {\n      comp.mixins.forEach(extendEmits);\n    }\n  }\n\n  if (!raw && !hasExtends) {\n    return comp.__emits = null;\n  }\n\n  if (isArray(raw)) {\n    raw.forEach(key => normalized[key] = null);\n  } else {\n    extend(normalized, raw);\n  }\n\n  return comp.__emits = normalized;\n} // Check if an incoming prop key is a declared emit event listener.\n// e.g. With `emits: { click: null }`, props named `onClick` and `onclick` are\n// both considered matched listeners.\n\n\nfunction isEmitListener(options, key) {\n  if (!options || !isOn(key)) {\n    return false;\n  }\n\n  key = key.replace(/Once$/, '');\n  return hasOwn(options, key[2].toLowerCase() + key.slice(3)) || hasOwn(options, key.slice(2));\n} // mark the current rendering instance for asset resolution (e.g.\n// resolveComponent, resolveDirective) during render\n\n\nlet currentRenderingInstance = null;\n\nfunction setCurrentRenderingInstance(instance) {\n  currentRenderingInstance = instance;\n} // dev only flag to track whether $attrs was used during render.\n// If $attrs was used during render then the warning for failed attrs\n// fallthrough can be suppressed.\n\n\nlet accessedAttrs = false;\n\nfunction markAttrsAccessed() {\n  accessedAttrs = true;\n}\n\nfunction renderComponentRoot(instance) {\n  const {\n    type: Component,\n    vnode,\n    proxy,\n    withProxy,\n    props,\n    propsOptions: [propsOptions],\n    slots,\n    attrs,\n    emit,\n    render,\n    renderCache,\n    data,\n    setupState,\n    ctx\n  } = instance;\n  let result;\n  currentRenderingInstance = instance;\n\n  if (process.env.NODE_ENV !== 'production') {\n    accessedAttrs = false;\n  }\n\n  try {\n    let fallthroughAttrs;\n\n    if (vnode.shapeFlag & 4\n    /* STATEFUL_COMPONENT */\n    ) {\n        // withProxy is a proxy with a different `has` trap only for\n        // runtime-compiled render functions using `with` block.\n        const proxyToUse = withProxy || proxy;\n        result = normalizeVNode(render.call(proxyToUse, proxyToUse, renderCache, props, setupState, data, ctx));\n        fallthroughAttrs = attrs;\n      } else {\n      // functional\n      const render = Component; // in dev, mark attrs accessed if optional props (attrs === props)\n\n      if (process.env.NODE_ENV !== 'production' && attrs === props) {\n        markAttrsAccessed();\n      }\n\n      result = normalizeVNode(render.length > 1 ? render(props, process.env.NODE_ENV !== 'production' ? {\n        get attrs() {\n          markAttrsAccessed();\n          return attrs;\n        },\n\n        slots,\n        emit\n      } : {\n        attrs,\n        slots,\n        emit\n      }) : render(props, null\n      /* we know it doesn't need it */\n      ));\n      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);\n    } // attr merging\n    // in dev mode, comments are preserved, and it's possible for a template\n    // to have comments along side the root element which makes it a fragment\n\n\n    let root = result;\n    let setRoot = undefined;\n\n    if (process.env.NODE_ENV !== 'production') {\n      ;\n      [root, setRoot] = getChildRoot(result);\n    }\n\n    if (Component.inheritAttrs !== false && fallthroughAttrs) {\n      const keys = Object.keys(fallthroughAttrs);\n      const {\n        shapeFlag\n      } = root;\n\n      if (keys.length) {\n        if (shapeFlag & 1\n        /* ELEMENT */\n        || shapeFlag & 6\n        /* COMPONENT */\n        ) {\n            if (propsOptions && keys.some(isModelListener)) {\n              // If a v-model listener (onUpdate:xxx) has a corresponding declared\n              // prop, it indicates this component expects to handle v-model and\n              // it should not fallthrough.\n              // related: #1543, #1643, #1989\n              fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);\n            }\n\n            root = cloneVNode(root, fallthroughAttrs);\n          } else if (process.env.NODE_ENV !== 'production' && !accessedAttrs && root.type !== Comment) {\n          const allAttrs = Object.keys(attrs);\n          const eventAttrs = [];\n          const extraAttrs = [];\n\n          for (let i = 0, l = allAttrs.length; i < l; i++) {\n            const key = allAttrs[i];\n\n            if (isOn(key)) {\n              // ignore v-model handlers when they fail to fallthrough\n              if (!isModelListener(key)) {\n                // remove `on`, lowercase first letter to reflect event casing\n                // accurately\n                eventAttrs.push(key[2].toLowerCase() + key.slice(3));\n              }\n            } else {\n              extraAttrs.push(key);\n            }\n          }\n\n          if (extraAttrs.length) {\n            warn(`Extraneous non-props attributes (` + `${extraAttrs.join(', ')}) ` + `were passed to component but could not be automatically inherited ` + `because component renders fragment or text root nodes.`);\n          }\n\n          if (eventAttrs.length) {\n            warn(`Extraneous non-emits event listeners (` + `${eventAttrs.join(', ')}) ` + `were passed to component but could not be automatically inherited ` + `because component renders fragment or text root nodes. ` + `If the listener is intended to be a component custom event listener only, ` + `declare it using the \"emits\" option.`);\n          }\n        }\n      }\n    } // inherit directives\n\n\n    if (vnode.dirs) {\n      if (process.env.NODE_ENV !== 'production' && !isElementRoot(root)) {\n        warn(`Runtime directive used on component with non-element root node. ` + `The directives will not function as intended.`);\n      }\n\n      root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;\n    } // inherit transition data\n\n\n    if (vnode.transition) {\n      if (process.env.NODE_ENV !== 'production' && !isElementRoot(root)) {\n        warn(`Component inside <Transition> renders non-element root node ` + `that cannot be animated.`);\n      }\n\n      root.transition = vnode.transition;\n    }\n\n    if (process.env.NODE_ENV !== 'production' && setRoot) {\n      setRoot(root);\n    } else {\n      result = root;\n    }\n  } catch (err) {\n    handleError(err, instance, 1\n    /* RENDER_FUNCTION */\n    );\n    result = createVNode(Comment);\n  }\n\n  currentRenderingInstance = null;\n  return result;\n}\n/**\r\n * dev only\r\n * In dev mode, template root level comments are rendered, which turns the\r\n * template into a fragment root, but we need to locate the single element\r\n * root for attrs and scope id processing.\r\n */\n\n\nconst getChildRoot = vnode => {\n  if (vnode.type !== Fragment) {\n    return [vnode, undefined];\n  }\n\n  const rawChildren = vnode.children;\n  const dynamicChildren = vnode.dynamicChildren;\n  const childRoot = filterSingleRoot(rawChildren);\n\n  if (!childRoot) {\n    return [vnode, undefined];\n  }\n\n  const index = rawChildren.indexOf(childRoot);\n  const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;\n\n  const setRoot = updatedRoot => {\n    rawChildren[index] = updatedRoot;\n\n    if (dynamicIndex > -1) {\n      dynamicChildren[dynamicIndex] = updatedRoot;\n    } else if (dynamicChildren && updatedRoot.patchFlag > 0) {\n      dynamicChildren.push(updatedRoot);\n    }\n  };\n\n  return [normalizeVNode(childRoot), setRoot];\n};\n/**\r\n * dev only\r\n */\n\n\nfunction filterSingleRoot(children) {\n  const filtered = children.filter(child => {\n    return !(isVNode(child) && child.type === Comment && child.children !== 'v-if');\n  });\n  return filtered.length === 1 && isVNode(filtered[0]) ? filtered[0] : null;\n}\n\nconst getFunctionalFallthrough = attrs => {\n  let res;\n\n  for (const key in attrs) {\n    if (key === 'class' || key === 'style' || isOn(key)) {\n      (res || (res = {}))[key] = attrs[key];\n    }\n  }\n\n  return res;\n};\n\nconst filterModelListeners = (attrs, props) => {\n  const res = {};\n\n  for (const key in attrs) {\n    if (!isModelListener(key) || !(key.slice(9) in props)) {\n      res[key] = attrs[key];\n    }\n  }\n\n  return res;\n};\n\nconst isElementRoot = vnode => {\n  return vnode.shapeFlag & 6\n  /* COMPONENT */\n  || vnode.shapeFlag & 1\n  /* ELEMENT */\n  || vnode.type === Comment // potential v-if branch switch\n  ;\n};\n\nfunction shouldUpdateComponent(prevVNode, nextVNode, optimized) {\n  const {\n    props: prevProps,\n    children: prevChildren,\n    component\n  } = prevVNode;\n  const {\n    props: nextProps,\n    children: nextChildren,\n    patchFlag\n  } = nextVNode;\n  const emits = component.emitsOptions; // Parent component's render function was hot-updated. Since this may have\n  // caused the child component's slots content to have changed, we need to\n  // force the child to update as well.\n\n  if (process.env.NODE_ENV !== 'production' && (prevChildren || nextChildren) && isHmrUpdating) {\n    return true;\n  } // force child update for runtime directive or transition on component vnode.\n\n\n  if (nextVNode.dirs || nextVNode.transition) {\n    return true;\n  }\n\n  if (optimized && patchFlag > 0) {\n    if (patchFlag & 1024\n    /* DYNAMIC_SLOTS */\n    ) {\n        // slot content that references values that might have changed,\n        // e.g. in a v-for\n        return true;\n      }\n\n    if (patchFlag & 16\n    /* FULL_PROPS */\n    ) {\n        if (!prevProps) {\n          return !!nextProps;\n        } // presence of this flag indicates props are always non-null\n\n\n        return hasPropsChanged(prevProps, nextProps, emits);\n      } else if (patchFlag & 8\n    /* PROPS */\n    ) {\n        const dynamicProps = nextVNode.dynamicProps;\n\n        for (let i = 0; i < dynamicProps.length; i++) {\n          const key = dynamicProps[i];\n\n          if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {\n            return true;\n          }\n        }\n      }\n  } else {\n    // this path is only taken by manually written render functions\n    // so presence of any children leads to a forced update\n    if (prevChildren || nextChildren) {\n      if (!nextChildren || !nextChildren.$stable) {\n        return true;\n      }\n    }\n\n    if (prevProps === nextProps) {\n      return false;\n    }\n\n    if (!prevProps) {\n      return !!nextProps;\n    }\n\n    if (!nextProps) {\n      return true;\n    }\n\n    return hasPropsChanged(prevProps, nextProps, emits);\n  }\n\n  return false;\n}\n\nfunction hasPropsChanged(prevProps, nextProps, emitsOptions) {\n  const nextKeys = Object.keys(nextProps);\n\n  if (nextKeys.length !== Object.keys(prevProps).length) {\n    return true;\n  }\n\n  for (let i = 0; i < nextKeys.length; i++) {\n    const key = nextKeys[i];\n\n    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction updateHOCHostEl({\n  vnode,\n  parent\n}, el // HostNode\n) {\n  while (parent && parent.subTree === vnode) {\n    (vnode = parent.vnode).el = el;\n    parent = parent.parent;\n  }\n}\n\nconst isSuspense = type => type.__isSuspense; // Suspense exposes a component-like API, and is treated like a component\n// in the compiler, but internally it's a special built-in type that hooks\n// directly into the renderer.\n\n\nconst SuspenseImpl = {\n  // In order to make Suspense tree-shakable, we need to avoid importing it\n  // directly in the renderer. The renderer checks for the __isSuspense flag\n  // on a vnode's type and calls the `process` method, passing in renderer\n  // internals.\n  __isSuspense: true,\n\n  process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized, // platform-specific impl passed from renderer\n  rendererInternals) {\n    if (n1 == null) {\n      mountSuspense(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized, rendererInternals);\n    } else {\n      patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, optimized, rendererInternals);\n    }\n  },\n\n  hydrate: hydrateSuspense,\n  create: createSuspenseBoundary\n}; // Force-casted public typing for h and TSX props inference\n\nconst Suspense = SuspenseImpl;\n\nfunction mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, isSVG, optimized, rendererInternals) {\n  const {\n    p: patch,\n    o: {\n      createElement\n    }\n  } = rendererInternals;\n  const hiddenContainer = createElement('div');\n  const suspense = vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, isSVG, optimized, rendererInternals); // start mounting the content subtree in an off-dom container\n\n  patch(null, suspense.pendingBranch = vnode.ssContent, hiddenContainer, null, parentComponent, suspense, isSVG, optimized); // now check if we have encountered any async deps\n\n  if (suspense.deps > 0) {\n    // has async\n    // mount the fallback tree\n    patch(null, vnode.ssFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context\n    isSVG, optimized);\n    setActiveBranch(suspense, vnode.ssFallback);\n  } else {\n    // Suspense has no async deps. Just resolve.\n    suspense.resolve();\n  }\n}\n\nfunction patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, optimized, {\n  p: patch,\n  um: unmount,\n  o: {\n    createElement\n  }\n}) {\n  const suspense = n2.suspense = n1.suspense;\n  suspense.vnode = n2;\n  n2.el = n1.el;\n  const newBranch = n2.ssContent;\n  const newFallback = n2.ssFallback;\n  const {\n    activeBranch,\n    pendingBranch,\n    isInFallback,\n    isHydrating\n  } = suspense;\n\n  if (pendingBranch) {\n    suspense.pendingBranch = newBranch;\n\n    if (isSameVNodeType(newBranch, pendingBranch)) {\n      // same root type but content may have changed.\n      patch(pendingBranch, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, optimized);\n\n      if (suspense.deps <= 0) {\n        suspense.resolve();\n      } else if (isInFallback) {\n        patch(activeBranch, newFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context\n        isSVG, optimized);\n        setActiveBranch(suspense, newFallback);\n      }\n    } else {\n      // toggled before pending tree is resolved\n      suspense.pendingId++;\n\n      if (isHydrating) {\n        // if toggled before hydration is finished, the current DOM tree is\n        // no longer valid. set it as the active branch so it will be unmounted\n        // when resolved\n        suspense.isHydrating = false;\n        suspense.activeBranch = pendingBranch;\n      } else {\n        unmount(pendingBranch, parentComponent, suspense);\n      } // increment pending ID. this is used to invalidate async callbacks\n      // reset suspense state\n\n\n      suspense.deps = 0; // discard effects from pending branch\n\n      suspense.effects.length = 0; // discard previous container\n\n      suspense.hiddenContainer = createElement('div');\n\n      if (isInFallback) {\n        // already in fallback state\n        patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, optimized);\n\n        if (suspense.deps <= 0) {\n          suspense.resolve();\n        } else {\n          patch(activeBranch, newFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context\n          isSVG, optimized);\n          setActiveBranch(suspense, newFallback);\n        }\n      } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {\n        // toggled \"back\" to current active branch\n        patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, optimized); // force resolve\n\n        suspense.resolve(true);\n      } else {\n        // switched to a 3rd branch\n        patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, optimized);\n\n        if (suspense.deps <= 0) {\n          suspense.resolve();\n        }\n      }\n    }\n  } else {\n    if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {\n      // root did not change, just normal patch\n      patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, optimized);\n      setActiveBranch(suspense, newBranch);\n    } else {\n      // root node toggled\n      // invoke @pending event\n      const onPending = n2.props && n2.props.onPending;\n\n      if (isFunction(onPending)) {\n        onPending();\n      } // mount pending branch in off-dom container\n\n\n      suspense.pendingBranch = newBranch;\n      suspense.pendingId++;\n      patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, optimized);\n\n      if (suspense.deps <= 0) {\n        // incoming branch has no async deps, resolve now.\n        suspense.resolve();\n      } else {\n        const {\n          timeout,\n          pendingId\n        } = suspense;\n\n        if (timeout > 0) {\n          setTimeout(() => {\n            if (suspense.pendingId === pendingId) {\n              suspense.fallback(newFallback);\n            }\n          }, timeout);\n        } else if (timeout === 0) {\n          suspense.fallback(newFallback);\n        }\n      }\n    }\n  }\n}\n\nlet hasWarned = false;\n\nfunction createSuspenseBoundary(vnode, parent, parentComponent, container, hiddenContainer, anchor, isSVG, optimized, rendererInternals, isHydrating = false) {\n  /* istanbul ignore if */\n  if (process.env.NODE_ENV !== 'production' && !false && !hasWarned) {\n    hasWarned = true; // @ts-ignore `console.info` cannot be null error\n\n    console[console.info ? 'info' : 'log'](`<Suspense> is an experimental feature and its API will likely change.`);\n  }\n\n  const {\n    p: patch,\n    m: move,\n    um: unmount,\n    n: next,\n    o: {\n      parentNode,\n      remove\n    }\n  } = rendererInternals;\n  const timeout = toNumber(vnode.props && vnode.props.timeout);\n  const suspense = {\n    vnode,\n    parent,\n    parentComponent,\n    isSVG,\n    optimized,\n    container,\n    hiddenContainer,\n    anchor,\n    deps: 0,\n    pendingId: 0,\n    timeout: typeof timeout === 'number' ? timeout : -1,\n    activeBranch: null,\n    pendingBranch: null,\n    isInFallback: true,\n    isHydrating,\n    isUnmounted: false,\n    effects: [],\n\n    resolve(resume = false) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (!resume && !suspense.pendingBranch) {\n          throw new Error(`suspense.resolve() is called without a pending branch.`);\n        }\n\n        if (suspense.isUnmounted) {\n          throw new Error(`suspense.resolve() is called on an already unmounted suspense boundary.`);\n        }\n      }\n\n      const {\n        vnode,\n        activeBranch,\n        pendingBranch,\n        pendingId,\n        effects,\n        parentComponent,\n        container\n      } = suspense;\n\n      if (suspense.isHydrating) {\n        suspense.isHydrating = false;\n      } else if (!resume) {\n        const delayEnter = activeBranch && pendingBranch.transition && pendingBranch.transition.mode === 'out-in';\n\n        if (delayEnter) {\n          activeBranch.transition.afterLeave = () => {\n            if (pendingId === suspense.pendingId) {\n              move(pendingBranch, container, anchor, 0\n              /* ENTER */\n              );\n            }\n          };\n        } // this is initial anchor on mount\n\n\n        let {\n          anchor\n        } = suspense; // unmount current active tree\n\n        if (activeBranch) {\n          // if the fallback tree was mounted, it may have been moved\n          // as part of a parent suspense. get the latest anchor for insertion\n          anchor = next(activeBranch);\n          unmount(activeBranch, parentComponent, suspense, true);\n        }\n\n        if (!delayEnter) {\n          // move content from off-dom container to actual container\n          move(pendingBranch, container, anchor, 0\n          /* ENTER */\n          );\n        }\n      }\n\n      setActiveBranch(suspense, pendingBranch);\n      suspense.pendingBranch = null;\n      suspense.isInFallback = false; // flush buffered effects\n      // check if there is a pending parent suspense\n\n      let parent = suspense.parent;\n      let hasUnresolvedAncestor = false;\n\n      while (parent) {\n        if (parent.pendingBranch) {\n          // found a pending parent suspense, merge buffered post jobs\n          // into that parent\n          parent.effects.push(...effects);\n          hasUnresolvedAncestor = true;\n          break;\n        }\n\n        parent = parent.parent;\n      } // no pending parent suspense, flush all jobs\n\n\n      if (!hasUnresolvedAncestor) {\n        queuePostFlushCb(effects);\n      }\n\n      suspense.effects = []; // invoke @resolve event\n\n      const onResolve = vnode.props && vnode.props.onResolve;\n\n      if (isFunction(onResolve)) {\n        onResolve();\n      }\n    },\n\n    fallback(fallbackVNode) {\n      if (!suspense.pendingBranch) {\n        return;\n      }\n\n      const {\n        vnode,\n        activeBranch,\n        parentComponent,\n        container,\n        isSVG,\n        optimized\n      } = suspense; // invoke @fallback event\n\n      const onFallback = vnode.props && vnode.props.onFallback;\n\n      if (isFunction(onFallback)) {\n        onFallback();\n      }\n\n      const anchor = next(activeBranch);\n\n      const mountFallback = () => {\n        if (!suspense.isInFallback) {\n          return;\n        } // mount the fallback tree\n\n\n        patch(null, fallbackVNode, container, anchor, parentComponent, null, // fallback tree will not have suspense context\n        isSVG, optimized);\n        setActiveBranch(suspense, fallbackVNode);\n      };\n\n      const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === 'out-in';\n\n      if (delayEnter) {\n        activeBranch.transition.afterLeave = mountFallback;\n      } // unmount current active branch\n\n\n      unmount(activeBranch, parentComponent, null, // no suspense so unmount hooks fire now\n      true // shouldRemove\n      );\n      suspense.isInFallback = true;\n\n      if (!delayEnter) {\n        mountFallback();\n      }\n    },\n\n    move(container, anchor, type) {\n      suspense.activeBranch && move(suspense.activeBranch, container, anchor, type);\n      suspense.container = container;\n    },\n\n    next() {\n      return suspense.activeBranch && next(suspense.activeBranch);\n    },\n\n    registerDep(instance, setupRenderEffect) {\n      if (!suspense.pendingBranch) {\n        return;\n      }\n\n      const hydratedEl = instance.vnode.el;\n      suspense.deps++;\n      instance.asyncDep.catch(err => {\n        handleError(err, instance, 0\n        /* SETUP_FUNCTION */\n        );\n      }).then(asyncSetupResult => {\n        // retry when the setup() promise resolves.\n        // component may have been unmounted before resolve.\n        if (instance.isUnmounted || suspense.isUnmounted || suspense.pendingId !== instance.suspenseId) {\n          return;\n        }\n\n        suspense.deps--; // retry from this component\n\n        instance.asyncResolved = true;\n        const {\n          vnode\n        } = instance;\n\n        if (process.env.NODE_ENV !== 'production') {\n          pushWarningContext(vnode);\n        }\n\n        handleSetupResult(instance, asyncSetupResult);\n\n        if (hydratedEl) {\n          // vnode may have been replaced if an update happened before the\n          // async dep is resolved.\n          vnode.el = hydratedEl;\n        }\n\n        const placeholder = !hydratedEl && instance.subTree.el;\n        setupRenderEffect(instance, vnode, // component may have been moved before resolve.\n        // if this is not a hydration, instance.subTree will be the comment\n        // placeholder.\n        parentNode(hydratedEl || instance.subTree.el), // anchor will not be used if this is hydration, so only need to\n        // consider the comment placeholder case.\n        hydratedEl ? null : next(instance.subTree), suspense, isSVG, optimized);\n\n        if (placeholder) {\n          remove(placeholder);\n        }\n\n        updateHOCHostEl(instance, vnode.el);\n\n        if (process.env.NODE_ENV !== 'production') {\n          popWarningContext();\n        }\n\n        if (suspense.deps === 0) {\n          suspense.resolve();\n        }\n      });\n    },\n\n    unmount(parentSuspense, doRemove) {\n      suspense.isUnmounted = true;\n\n      if (suspense.activeBranch) {\n        unmount(suspense.activeBranch, parentComponent, parentSuspense, doRemove);\n      }\n\n      if (suspense.pendingBranch) {\n        unmount(suspense.pendingBranch, parentComponent, parentSuspense, doRemove);\n      }\n    }\n\n  };\n  return suspense;\n}\n\nfunction hydrateSuspense(node, vnode, parentComponent, parentSuspense, isSVG, optimized, rendererInternals, hydrateNode) {\n  /* eslint-disable no-restricted-globals */\n  const suspense = vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, node.parentNode, document.createElement('div'), null, isSVG, optimized, rendererInternals, true\n  /* hydrating */\n  ); // there are two possible scenarios for server-rendered suspense:\n  // - success: ssr content should be fully resolved\n  // - failure: ssr content should be the fallback branch.\n  // however, on the client we don't really know if it has failed or not\n  // attempt to hydrate the DOM assuming it has succeeded, but we still\n  // need to construct a suspense boundary first\n\n  const result = hydrateNode(node, suspense.pendingBranch = vnode.ssContent, parentComponent, suspense, optimized);\n\n  if (suspense.deps === 0) {\n    suspense.resolve();\n  }\n\n  return result;\n  /* eslint-enable no-restricted-globals */\n}\n\nfunction normalizeSuspenseChildren(vnode) {\n  const {\n    shapeFlag,\n    children\n  } = vnode;\n  let content;\n  let fallback;\n\n  if (shapeFlag & 32\n  /* SLOTS_CHILDREN */\n  ) {\n      content = normalizeSuspenseSlot(children.default);\n      fallback = normalizeSuspenseSlot(children.fallback);\n    } else {\n    content = normalizeSuspenseSlot(children);\n    fallback = normalizeVNode(null);\n  }\n\n  return {\n    content,\n    fallback\n  };\n}\n\nfunction normalizeSuspenseSlot(s) {\n  if (isFunction(s)) {\n    s = s();\n  }\n\n  if (isArray(s)) {\n    const singleChild = filterSingleRoot(s);\n\n    if (process.env.NODE_ENV !== 'production' && !singleChild) {\n      warn(`<Suspense> slots expect a single root node.`);\n    }\n\n    s = singleChild;\n  }\n\n  return normalizeVNode(s);\n}\n\nfunction queueEffectWithSuspense(fn, suspense) {\n  if (suspense && suspense.pendingBranch) {\n    if (isArray(fn)) {\n      suspense.effects.push(...fn);\n    } else {\n      suspense.effects.push(fn);\n    }\n  } else {\n    queuePostFlushCb(fn);\n  }\n}\n\nfunction setActiveBranch(suspense, branch) {\n  suspense.activeBranch = branch;\n  const {\n    vnode,\n    parentComponent\n  } = suspense;\n  const el = vnode.el = branch.el; // in case suspense is the root node of a component,\n  // recursively update the HOC el\n\n  if (parentComponent && parentComponent.subTree === vnode) {\n    parentComponent.vnode.el = el;\n    updateHOCHostEl(parentComponent, el);\n  }\n}\n\nlet isRenderingCompiledSlot = 0;\n\nconst setCompiledSlotRendering = n => isRenderingCompiledSlot += n;\n/**\r\n * Compiler runtime helper for rendering `<slot/>`\r\n * @private\r\n */\n\n\nfunction renderSlot(slots, name, props = {}, // this is not a user-facing function, so the fallback is always generated by\n// the compiler and guaranteed to be a function returning an array\nfallback) {\n  let slot = slots[name];\n\n  if (process.env.NODE_ENV !== 'production' && slot && slot.length > 1) {\n    warn(`SSR-optimized slot function detected in a non-SSR-optimized render ` + `function. You need to mark this component with $dynamic-slots in the ` + `parent template.`);\n\n    slot = () => [];\n  } // a compiled slot disables block tracking by default to avoid manual\n  // invocation interfering with template-based block tracking, but in\n  // `renderSlot` we can be sure that it's template-based so we can force\n  // enable it.\n\n\n  isRenderingCompiledSlot++;\n  const rendered = (openBlock(), createBlock(Fragment, {\n    key: props.key\n  }, slot ? slot(props) : fallback ? fallback() : [], slots._ === 1\n  /* STABLE */\n  ? 64\n  /* STABLE_FRAGMENT */\n  : -2\n  /* BAIL */\n  ));\n  isRenderingCompiledSlot--;\n  return rendered;\n}\n/**\r\n * Wrap a slot function to memoize current rendering instance\r\n * @private\r\n */\n\n\nfunction withCtx(fn, ctx = currentRenderingInstance) {\n  if (!ctx) return fn;\n\n  const renderFnWithContext = (...args) => {\n    // If a user calls a compiled slot inside a template expression (#1745), it\n    // can mess up block tracking, so by default we need to push a null block to\n    // avoid that. This isn't necessary if rendering a compiled `<slot>`.\n    if (!isRenderingCompiledSlot) {\n      openBlock(true\n      /* null block that disables tracking */\n      );\n    }\n\n    const owner = currentRenderingInstance;\n    setCurrentRenderingInstance(ctx);\n    const res = fn(...args);\n    setCurrentRenderingInstance(owner);\n\n    if (!isRenderingCompiledSlot) {\n      closeBlock();\n    }\n\n    return res;\n  };\n\n  renderFnWithContext._c = true;\n  return renderFnWithContext;\n} // SFC scoped style ID management.\n\n\nlet currentScopeId = null;\nconst scopeIdStack = [];\n/**\r\n * @private\r\n */\n\nfunction pushScopeId(id) {\n  scopeIdStack.push(currentScopeId = id);\n}\n/**\r\n * @private\r\n */\n\n\nfunction popScopeId() {\n  scopeIdStack.pop();\n  currentScopeId = scopeIdStack[scopeIdStack.length - 1] || null;\n}\n/**\r\n * @private\r\n */\n\n\nfunction withScopeId(id) {\n  return fn => withCtx(function () {\n    pushScopeId(id);\n    const res = fn.apply(this, arguments);\n    popScopeId();\n    return res;\n  });\n}\n\nfunction initProps(instance, rawProps, isStateful, // result of bitwise flag comparison\nisSSR = false) {\n  const props = {};\n  const attrs = {};\n  def(attrs, InternalObjectKey, 1);\n  setFullProps(instance, rawProps, props, attrs); // validation\n\n  if (process.env.NODE_ENV !== 'production') {\n    validateProps(props, instance);\n  }\n\n  if (isStateful) {\n    // stateful\n    instance.props = isSSR ? props : shallowReactive(props);\n  } else {\n    if (!instance.type.props) {\n      // functional w/ optional props, props === attrs\n      instance.props = attrs;\n    } else {\n      // functional w/ declared props\n      instance.props = props;\n    }\n  }\n\n  instance.attrs = attrs;\n}\n\nfunction updateProps(instance, rawProps, rawPrevProps, optimized) {\n  const {\n    props,\n    attrs,\n    vnode: {\n      patchFlag\n    }\n  } = instance;\n  const rawCurrentProps = toRaw(props);\n  const [options] = instance.propsOptions;\n\n  if ( // always force full diff in dev\n  // - #1942 if hmr is enabled with sfc component\n  // - vite#872 non-sfc component used by sfc component\n  !(process.env.NODE_ENV !== 'production' && (instance.type.__hmrId || instance.parent && instance.parent.type.__hmrId)) && (optimized || patchFlag > 0) && !(patchFlag & 16\n  /* FULL_PROPS */\n  )) {\n    if (patchFlag & 8\n    /* PROPS */\n    ) {\n        // Compiler-generated props & no keys change, just set the updated\n        // the props.\n        const propsToUpdate = instance.vnode.dynamicProps;\n\n        for (let i = 0; i < propsToUpdate.length; i++) {\n          const key = propsToUpdate[i]; // PROPS flag guarantees rawProps to be non-null\n\n          const value = rawProps[key];\n\n          if (options) {\n            // attr / props separation was done on init and will be consistent\n            // in this code path, so just check if attrs have it.\n            if (hasOwn(attrs, key)) {\n              attrs[key] = value;\n            } else {\n              const camelizedKey = camelize(key);\n              props[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value, instance);\n            }\n          } else {\n            attrs[key] = value;\n          }\n        }\n      }\n  } else {\n    // full props update.\n    setFullProps(instance, rawProps, props, attrs); // in case of dynamic props, check if we need to delete keys from\n    // the props object\n\n    let kebabKey;\n\n    for (const key in rawCurrentProps) {\n      if (!rawProps || // for camelCase\n      !hasOwn(rawProps, key) && ( // it's possible the original props was passed in as kebab-case\n      // and converted to camelCase (#955)\n      (kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {\n        if (options) {\n          if (rawPrevProps && ( // for camelCase\n          rawPrevProps[key] !== undefined || // for kebab-case\n          rawPrevProps[kebabKey] !== undefined)) {\n            props[key] = resolvePropValue(options, rawProps || EMPTY_OBJ, key, undefined, instance);\n          }\n        } else {\n          delete props[key];\n        }\n      }\n    } // in the case of functional component w/o props declaration, props and\n    // attrs point to the same object so it should already have been updated.\n\n\n    if (attrs !== rawCurrentProps) {\n      for (const key in attrs) {\n        if (!rawProps || !hasOwn(rawProps, key)) {\n          delete attrs[key];\n        }\n      }\n    }\n  } // trigger updates for $attrs in case it's used in component slots\n\n\n  trigger(instance, \"set\"\n  /* SET */\n  , '$attrs');\n\n  if (process.env.NODE_ENV !== 'production' && rawProps) {\n    validateProps(props, instance);\n  }\n}\n\nfunction setFullProps(instance, rawProps, props, attrs) {\n  const [options, needCastKeys] = instance.propsOptions;\n\n  if (rawProps) {\n    for (const key in rawProps) {\n      const value = rawProps[key]; // key, ref are reserved and never passed down\n\n      if (isReservedProp(key)) {\n        continue;\n      } // prop option names are camelized during normalization, so to support\n      // kebab -> camel conversion here we need to camelize the key.\n\n\n      let camelKey;\n\n      if (options && hasOwn(options, camelKey = camelize(key))) {\n        props[camelKey] = value;\n      } else if (!isEmitListener(instance.emitsOptions, key)) {\n        // Any non-declared (either as a prop or an emitted event) props are put\n        // into a separate `attrs` object for spreading. Make sure to preserve\n        // original key casing\n        attrs[key] = value;\n      }\n    }\n  }\n\n  if (needCastKeys) {\n    const rawCurrentProps = toRaw(props);\n\n    for (let i = 0; i < needCastKeys.length; i++) {\n      const key = needCastKeys[i];\n      props[key] = resolvePropValue(options, rawCurrentProps, key, rawCurrentProps[key], instance);\n    }\n  }\n}\n\nfunction resolvePropValue(options, props, key, value, instance) {\n  const opt = options[key];\n\n  if (opt != null) {\n    const hasDefault = hasOwn(opt, 'default'); // default values\n\n    if (hasDefault && value === undefined) {\n      const defaultValue = opt.default;\n\n      if (opt.type !== Function && isFunction(defaultValue)) {\n        setCurrentInstance(instance);\n        value = defaultValue(props);\n        setCurrentInstance(null);\n      } else {\n        value = defaultValue;\n      }\n    } // boolean casting\n\n\n    if (opt[0\n    /* shouldCast */\n    ]) {\n      if (!hasOwn(props, key) && !hasDefault) {\n        value = false;\n      } else if (opt[1\n      /* shouldCastTrue */\n      ] && (value === '' || value === hyphenate(key))) {\n        value = true;\n      }\n    }\n  }\n\n  return value;\n}\n\nfunction normalizePropsOptions(comp, appContext, asMixin = false) {\n  if (!appContext.deopt && comp.__props) {\n    return comp.__props;\n  }\n\n  const raw = comp.props;\n  const normalized = {};\n  const needCastKeys = []; // apply mixin/extends props\n\n  let hasExtends = false;\n\n  if (__VUE_OPTIONS_API__ && !isFunction(comp)) {\n    const extendProps = raw => {\n      hasExtends = true;\n      const [props, keys] = normalizePropsOptions(raw, appContext, true);\n      extend(normalized, props);\n      if (keys) needCastKeys.push(...keys);\n    };\n\n    if (!asMixin && appContext.mixins.length) {\n      appContext.mixins.forEach(extendProps);\n    }\n\n    if (comp.extends) {\n      extendProps(comp.extends);\n    }\n\n    if (comp.mixins) {\n      comp.mixins.forEach(extendProps);\n    }\n  }\n\n  if (!raw && !hasExtends) {\n    return comp.__props = EMPTY_ARR;\n  }\n\n  if (isArray(raw)) {\n    for (let i = 0; i < raw.length; i++) {\n      if (process.env.NODE_ENV !== 'production' && !isString(raw[i])) {\n        warn(`props must be strings when using array syntax.`, raw[i]);\n      }\n\n      const normalizedKey = camelize(raw[i]);\n\n      if (validatePropName(normalizedKey)) {\n        normalized[normalizedKey] = EMPTY_OBJ;\n      }\n    }\n  } else if (raw) {\n    if (process.env.NODE_ENV !== 'production' && !isObject(raw)) {\n      warn(`invalid props options`, raw);\n    }\n\n    for (const key in raw) {\n      const normalizedKey = camelize(key);\n\n      if (validatePropName(normalizedKey)) {\n        const opt = raw[key];\n        const prop = normalized[normalizedKey] = isArray(opt) || isFunction(opt) ? {\n          type: opt\n        } : opt;\n\n        if (prop) {\n          const booleanIndex = getTypeIndex(Boolean, prop.type);\n          const stringIndex = getTypeIndex(String, prop.type);\n          prop[0\n          /* shouldCast */\n          ] = booleanIndex > -1;\n          prop[1\n          /* shouldCastTrue */\n          ] = stringIndex < 0 || booleanIndex < stringIndex; // if the prop needs boolean casting or default value\n\n          if (booleanIndex > -1 || hasOwn(prop, 'default')) {\n            needCastKeys.push(normalizedKey);\n          }\n        }\n      }\n    }\n  }\n\n  return comp.__props = [normalized, needCastKeys];\n}\n\nfunction validatePropName(key) {\n  if (key[0] !== '$') {\n    return true;\n  } else if (process.env.NODE_ENV !== 'production') {\n    warn(`Invalid prop name: \"${key}\" is a reserved property.`);\n  }\n\n  return false;\n} // use function string name to check type constructors\n// so that it works across vms / iframes.\n\n\nfunction getType(ctor) {\n  const match = ctor && ctor.toString().match(/^\\s*function (\\w+)/);\n  return match ? match[1] : '';\n}\n\nfunction isSameType(a, b) {\n  return getType(a) === getType(b);\n}\n\nfunction getTypeIndex(type, expectedTypes) {\n  if (isArray(expectedTypes)) {\n    for (let i = 0, len = expectedTypes.length; i < len; i++) {\n      if (isSameType(expectedTypes[i], type)) {\n        return i;\n      }\n    }\n  } else if (isFunction(expectedTypes)) {\n    return isSameType(expectedTypes, type) ? 0 : -1;\n  }\n\n  return -1;\n}\n/**\r\n * dev only\r\n */\n\n\nfunction validateProps(props, instance) {\n  const rawValues = toRaw(props);\n  const options = instance.propsOptions[0];\n\n  for (const key in options) {\n    let opt = options[key];\n    if (opt == null) continue;\n    validateProp(key, rawValues[key], opt, !hasOwn(rawValues, key));\n  }\n}\n/**\r\n * dev only\r\n */\n\n\nfunction validateProp(name, value, prop, isAbsent) {\n  const {\n    type,\n    required,\n    validator\n  } = prop; // required!\n\n  if (required && isAbsent) {\n    warn('Missing required prop: \"' + name + '\"');\n    return;\n  } // missing but optional\n\n\n  if (value == null && !prop.required) {\n    return;\n  } // type check\n\n\n  if (type != null && type !== true) {\n    let isValid = false;\n    const types = isArray(type) ? type : [type];\n    const expectedTypes = []; // value is valid as long as one of the specified types match\n\n    for (let i = 0; i < types.length && !isValid; i++) {\n      const {\n        valid,\n        expectedType\n      } = assertType(value, types[i]);\n      expectedTypes.push(expectedType || '');\n      isValid = valid;\n    }\n\n    if (!isValid) {\n      warn(getInvalidTypeMessage(name, value, expectedTypes));\n      return;\n    }\n  } // custom validator\n\n\n  if (validator && !validator(value)) {\n    warn('Invalid prop: custom validator check failed for prop \"' + name + '\".');\n  }\n}\n\nconst isSimpleType = /*#__PURE__*/makeMap('String,Number,Boolean,Function,Symbol');\n/**\r\n * dev only\r\n */\n\nfunction assertType(value, type) {\n  let valid;\n  const expectedType = getType(type);\n\n  if (isSimpleType(expectedType)) {\n    const t = typeof value;\n    valid = t === expectedType.toLowerCase(); // for primitive wrapper objects\n\n    if (!valid && t === 'object') {\n      valid = value instanceof type;\n    }\n  } else if (expectedType === 'Object') {\n    valid = isObject(value);\n  } else if (expectedType === 'Array') {\n    valid = isArray(value);\n  } else {\n    valid = value instanceof type;\n  }\n\n  return {\n    valid,\n    expectedType\n  };\n}\n/**\r\n * dev only\r\n */\n\n\nfunction getInvalidTypeMessage(name, value, expectedTypes) {\n  let message = `Invalid prop: type check failed for prop \"${name}\".` + ` Expected ${expectedTypes.map(capitalize).join(', ')}`;\n  const expectedType = expectedTypes[0];\n  const receivedType = toRawType(value);\n  const expectedValue = styleValue(value, expectedType);\n  const receivedValue = styleValue(value, receivedType); // check if we need to specify expected value\n\n  if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) {\n    message += ` with value ${expectedValue}`;\n  }\n\n  message += `, got ${receivedType} `; // check if we need to specify received value\n\n  if (isExplicable(receivedType)) {\n    message += `with value ${receivedValue}.`;\n  }\n\n  return message;\n}\n/**\r\n * dev only\r\n */\n\n\nfunction styleValue(value, type) {\n  if (type === 'String') {\n    return `\"${value}\"`;\n  } else if (type === 'Number') {\n    return `${Number(value)}`;\n  } else {\n    return `${value}`;\n  }\n}\n/**\r\n * dev only\r\n */\n\n\nfunction isExplicable(type) {\n  const explicitTypes = ['string', 'number', 'boolean'];\n  return explicitTypes.some(elem => type.toLowerCase() === elem);\n}\n/**\r\n * dev only\r\n */\n\n\nfunction isBoolean(...args) {\n  return args.some(elem => elem.toLowerCase() === 'boolean');\n}\n\nfunction injectHook(type, hook, target = currentInstance, prepend = false) {\n  if (target) {\n    const hooks = target[type] || (target[type] = []); // cache the error handling wrapper for injected hooks so the same hook\n    // can be properly deduped by the scheduler. \"__weh\" stands for \"with error\n    // handling\".\n\n    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {\n      if (target.isUnmounted) {\n        return;\n      } // disable tracking inside all lifecycle hooks\n      // since they can potentially be called inside effects.\n\n\n      pauseTracking(); // Set currentInstance during hook invocation.\n      // This assumes the hook does not synchronously trigger other hooks, which\n      // can only be false when the user does something really funky.\n\n      setCurrentInstance(target);\n      const res = callWithAsyncErrorHandling(hook, target, type, args);\n      setCurrentInstance(null);\n      resetTracking();\n      return res;\n    });\n\n    if (prepend) {\n      hooks.unshift(wrappedHook);\n    } else {\n      hooks.push(wrappedHook);\n    }\n\n    return wrappedHook;\n  } else if (process.env.NODE_ENV !== 'production') {\n    const apiName = `on${capitalize(ErrorTypeStrings[type].replace(/ hook$/, ''))}`;\n    warn(`${apiName} is called when there is no active component instance to be ` + `associated with. ` + `Lifecycle injection APIs can only be used during execution of setup().` + (` If you are using async setup(), make sure to register lifecycle ` + `hooks before the first await statement.`));\n  }\n}\n\nconst createHook = lifecycle => (hook, target = currentInstance) => // post-create lifecycle registrations are noops during SSR\n!isInSSRComponentSetup && injectHook(lifecycle, hook, target);\n\nconst onBeforeMount = createHook(\"bm\"\n/* BEFORE_MOUNT */\n);\nconst onMounted = createHook(\"m\"\n/* MOUNTED */\n);\nconst onBeforeUpdate = createHook(\"bu\"\n/* BEFORE_UPDATE */\n);\nconst onUpdated = createHook(\"u\"\n/* UPDATED */\n);\nconst onBeforeUnmount = createHook(\"bum\"\n/* BEFORE_UNMOUNT */\n);\nconst onUnmounted = createHook(\"um\"\n/* UNMOUNTED */\n);\nconst onRenderTriggered = createHook(\"rtg\"\n/* RENDER_TRIGGERED */\n);\nconst onRenderTracked = createHook(\"rtc\"\n/* RENDER_TRACKED */\n);\n\nconst onErrorCaptured = (hook, target = currentInstance) => {\n  injectHook(\"ec\"\n  /* ERROR_CAPTURED */\n  , hook, target);\n}; // Simple effect.\n\n\nfunction watchEffect(effect, options) {\n  return doWatch(effect, null, options);\n} // initial value for watchers to trigger on undefined initial values\n\n\nconst INITIAL_WATCHER_VALUE = {}; // implementation\n\nfunction watch(source, cb, options) {\n  if (process.env.NODE_ENV !== 'production' && !isFunction(cb)) {\n    warn(`\\`watch(fn, options?)\\` signature has been moved to a separate API. ` + `Use \\`watchEffect(fn, options?)\\` instead. \\`watch\\` now only ` + `supports \\`watch(source, cb, options?) signature.`);\n  }\n\n  return doWatch(source, cb, options);\n}\n\nfunction doWatch(source, cb, {\n  immediate,\n  deep,\n  flush,\n  onTrack,\n  onTrigger\n} = EMPTY_OBJ, instance = currentInstance) {\n  if (process.env.NODE_ENV !== 'production' && !cb) {\n    if (immediate !== undefined) {\n      warn(`watch() \"immediate\" option is only respected when using the ` + `watch(source, callback, options?) signature.`);\n    }\n\n    if (deep !== undefined) {\n      warn(`watch() \"deep\" option is only respected when using the ` + `watch(source, callback, options?) signature.`);\n    }\n  }\n\n  const warnInvalidSource = s => {\n    warn(`Invalid watch source: `, s, `A watch source can only be a getter/effect function, a ref, ` + `a reactive object, or an array of these types.`);\n  };\n\n  let getter;\n  let forceTrigger = false;\n\n  if (isRef(source)) {\n    getter = () => source.value;\n\n    forceTrigger = !!source._shallow;\n  } else if (isReactive(source)) {\n    getter = () => source;\n\n    deep = true;\n  } else if (isArray(source)) {\n    getter = () => source.map(s => {\n      if (isRef(s)) {\n        return s.value;\n      } else if (isReactive(s)) {\n        return traverse(s);\n      } else if (isFunction(s)) {\n        return callWithErrorHandling(s, instance, 2\n        /* WATCH_GETTER */\n        );\n      } else {\n        process.env.NODE_ENV !== 'production' && warnInvalidSource(s);\n      }\n    });\n  } else if (isFunction(source)) {\n    if (cb) {\n      // getter with cb\n      getter = () => callWithErrorHandling(source, instance, 2\n      /* WATCH_GETTER */\n      );\n    } else {\n      // no cb -> simple effect\n      getter = () => {\n        if (instance && instance.isUnmounted) {\n          return;\n        }\n\n        if (cleanup) {\n          cleanup();\n        }\n\n        return callWithErrorHandling(source, instance, 3\n        /* WATCH_CALLBACK */\n        , [onInvalidate]);\n      };\n    }\n  } else {\n    getter = NOOP;\n    process.env.NODE_ENV !== 'production' && warnInvalidSource(source);\n  }\n\n  if (cb && deep) {\n    const baseGetter = getter;\n\n    getter = () => traverse(baseGetter());\n  }\n\n  let cleanup;\n\n  const onInvalidate = fn => {\n    cleanup = runner.options.onStop = () => {\n      callWithErrorHandling(fn, instance, 4\n      /* WATCH_CLEANUP */\n      );\n    };\n  };\n\n  let oldValue = isArray(source) ? [] : INITIAL_WATCHER_VALUE;\n\n  const job = () => {\n    if (!runner.active) {\n      return;\n    }\n\n    if (cb) {\n      // watch(source, cb)\n      const newValue = runner();\n\n      if (deep || forceTrigger || hasChanged(newValue, oldValue)) {\n        // cleanup before running cb again\n        if (cleanup) {\n          cleanup();\n        }\n\n        callWithAsyncErrorHandling(cb, instance, 3\n        /* WATCH_CALLBACK */\n        , [newValue, // pass undefined as the old value when it's changed for the first time\n        oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue, onInvalidate]);\n        oldValue = newValue;\n      }\n    } else {\n      // watchEffect\n      runner();\n    }\n  }; // important: mark the job as a watcher callback so that scheduler knows\n  // it is allowed to self-trigger (#1727)\n\n\n  job.allowRecurse = !!cb;\n  let scheduler;\n\n  if (flush === 'sync') {\n    scheduler = job;\n  } else if (flush === 'post') {\n    scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);\n  } else {\n    // default: 'pre'\n    scheduler = () => {\n      if (!instance || instance.isMounted) {\n        queuePreFlushCb(job);\n      } else {\n        // with 'pre' option, the first call must happen before\n        // the component is mounted so it is called synchronously.\n        job();\n      }\n    };\n  }\n\n  const runner = effect(getter, {\n    lazy: true,\n    onTrack,\n    onTrigger,\n    scheduler\n  });\n  recordInstanceBoundEffect(runner); // initial run\n\n  if (cb) {\n    if (immediate) {\n      job();\n    } else {\n      oldValue = runner();\n    }\n  } else if (flush === 'post') {\n    queuePostRenderEffect(runner, instance && instance.suspense);\n  } else {\n    runner();\n  }\n\n  return () => {\n    stop(runner);\n\n    if (instance) {\n      remove(instance.effects, runner);\n    }\n  };\n} // this.$watch\n\n\nfunction instanceWatch(source, cb, options) {\n  const publicThis = this.proxy;\n  const getter = isString(source) ? () => publicThis[source] : source.bind(publicThis);\n  return doWatch(getter, cb.bind(publicThis), options, this);\n}\n\nfunction traverse(value, seen = new Set()) {\n  if (!isObject(value) || seen.has(value)) {\n    return value;\n  }\n\n  seen.add(value);\n\n  if (isRef(value)) {\n    traverse(value.value, seen);\n  } else if (isArray(value)) {\n    for (let i = 0; i < value.length; i++) {\n      traverse(value[i], seen);\n    }\n  } else if (isSet(value) || isMap(value)) {\n    value.forEach(v => {\n      traverse(v, seen);\n    });\n  } else {\n    for (const key in value) {\n      traverse(value[key], seen);\n    }\n  }\n\n  return value;\n}\n\nfunction useTransitionState() {\n  const state = {\n    isMounted: false,\n    isLeaving: false,\n    isUnmounting: false,\n    leavingVNodes: new Map()\n  };\n  onMounted(() => {\n    state.isMounted = true;\n  });\n  onBeforeUnmount(() => {\n    state.isUnmounting = true;\n  });\n  return state;\n}\n\nconst TransitionHookValidator = [Function, Array];\nconst BaseTransitionImpl = {\n  name: `BaseTransition`,\n  props: {\n    mode: String,\n    appear: Boolean,\n    persisted: Boolean,\n    // enter\n    onBeforeEnter: TransitionHookValidator,\n    onEnter: TransitionHookValidator,\n    onAfterEnter: TransitionHookValidator,\n    onEnterCancelled: TransitionHookValidator,\n    // leave\n    onBeforeLeave: TransitionHookValidator,\n    onLeave: TransitionHookValidator,\n    onAfterLeave: TransitionHookValidator,\n    onLeaveCancelled: TransitionHookValidator,\n    // appear\n    onBeforeAppear: TransitionHookValidator,\n    onAppear: TransitionHookValidator,\n    onAfterAppear: TransitionHookValidator,\n    onAppearCancelled: TransitionHookValidator\n  },\n\n  setup(props, {\n    slots\n  }) {\n    const instance = getCurrentInstance();\n    const state = useTransitionState();\n    let prevTransitionKey;\n    return () => {\n      const children = slots.default && getTransitionRawChildren(slots.default(), true);\n\n      if (!children || !children.length) {\n        return;\n      } // warn multiple elements\n\n\n      if (process.env.NODE_ENV !== 'production' && children.length > 1) {\n        warn('<transition> can only be used on a single element or component. Use ' + '<transition-group> for lists.');\n      } // there's no need to track reactivity for these props so use the raw\n      // props for a bit better perf\n\n\n      const rawProps = toRaw(props);\n      const {\n        mode\n      } = rawProps; // check mode\n\n      if (process.env.NODE_ENV !== 'production' && mode && !['in-out', 'out-in', 'default'].includes(mode)) {\n        warn(`invalid <transition> mode: ${mode}`);\n      } // at this point children has a guaranteed length of 1.\n\n\n      const child = children[0];\n\n      if (state.isLeaving) {\n        return emptyPlaceholder(child);\n      } // in the case of <transition><keep-alive/></transition>, we need to\n      // compare the type of the kept-alive children.\n\n\n      const innerChild = getKeepAliveChild(child);\n\n      if (!innerChild) {\n        return emptyPlaceholder(child);\n      }\n\n      const enterHooks = resolveTransitionHooks(innerChild, rawProps, state, instance);\n      setTransitionHooks(innerChild, enterHooks);\n      const oldChild = instance.subTree;\n      const oldInnerChild = oldChild && getKeepAliveChild(oldChild);\n      let transitionKeyChanged = false;\n      const {\n        getTransitionKey\n      } = innerChild.type;\n\n      if (getTransitionKey) {\n        const key = getTransitionKey();\n\n        if (prevTransitionKey === undefined) {\n          prevTransitionKey = key;\n        } else if (key !== prevTransitionKey) {\n          prevTransitionKey = key;\n          transitionKeyChanged = true;\n        }\n      } // handle mode\n\n\n      if (oldInnerChild && oldInnerChild.type !== Comment && (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {\n        const leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance); // update old tree's hooks in case of dynamic transition\n\n        setTransitionHooks(oldInnerChild, leavingHooks); // switching between different views\n\n        if (mode === 'out-in') {\n          state.isLeaving = true; // return placeholder node and queue update when leave finishes\n\n          leavingHooks.afterLeave = () => {\n            state.isLeaving = false;\n            instance.update();\n          };\n\n          return emptyPlaceholder(child);\n        } else if (mode === 'in-out') {\n          leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {\n            const leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);\n            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild; // early removal callback\n\n            el._leaveCb = () => {\n              earlyRemove();\n              el._leaveCb = undefined;\n              delete enterHooks.delayedLeave;\n            };\n\n            enterHooks.delayedLeave = delayedLeave;\n          };\n        }\n      }\n\n      return child;\n    };\n  }\n\n}; // export the public type for h/tsx inference\n// also to avoid inline import() in generated d.ts files\n\nconst BaseTransition = BaseTransitionImpl;\n\nfunction getLeavingNodesForType(state, vnode) {\n  const {\n    leavingVNodes\n  } = state;\n  let leavingVNodesCache = leavingVNodes.get(vnode.type);\n\n  if (!leavingVNodesCache) {\n    leavingVNodesCache = Object.create(null);\n    leavingVNodes.set(vnode.type, leavingVNodesCache);\n  }\n\n  return leavingVNodesCache;\n} // The transition hooks are attached to the vnode as vnode.transition\n// and will be called at appropriate timing in the renderer.\n\n\nfunction resolveTransitionHooks(vnode, props, state, instance) {\n  const {\n    appear,\n    mode,\n    persisted = false,\n    onBeforeEnter,\n    onEnter,\n    onAfterEnter,\n    onEnterCancelled,\n    onBeforeLeave,\n    onLeave,\n    onAfterLeave,\n    onLeaveCancelled,\n    onBeforeAppear,\n    onAppear,\n    onAfterAppear,\n    onAppearCancelled\n  } = props;\n  const key = String(vnode.key);\n  const leavingVNodesCache = getLeavingNodesForType(state, vnode);\n\n  const callHook = (hook, args) => {\n    hook && callWithAsyncErrorHandling(hook, instance, 9\n    /* TRANSITION_HOOK */\n    , args);\n  };\n\n  const hooks = {\n    mode,\n    persisted,\n\n    beforeEnter(el) {\n      let hook = onBeforeEnter;\n\n      if (!state.isMounted) {\n        if (appear) {\n          hook = onBeforeAppear || onBeforeEnter;\n        } else {\n          return;\n        }\n      } // for same element (v-show)\n\n\n      if (el._leaveCb) {\n        el._leaveCb(true\n        /* cancelled */\n        );\n      } // for toggled element with same key (v-if)\n\n\n      const leavingVNode = leavingVNodesCache[key];\n\n      if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el._leaveCb) {\n        // force early removal (not cancelled)\n        leavingVNode.el._leaveCb();\n      }\n\n      callHook(hook, [el]);\n    },\n\n    enter(el) {\n      let hook = onEnter;\n      let afterHook = onAfterEnter;\n      let cancelHook = onEnterCancelled;\n\n      if (!state.isMounted) {\n        if (appear) {\n          hook = onAppear || onEnter;\n          afterHook = onAfterAppear || onAfterEnter;\n          cancelHook = onAppearCancelled || onEnterCancelled;\n        } else {\n          return;\n        }\n      }\n\n      let called = false;\n\n      const done = el._enterCb = cancelled => {\n        if (called) return;\n        called = true;\n\n        if (cancelled) {\n          callHook(cancelHook, [el]);\n        } else {\n          callHook(afterHook, [el]);\n        }\n\n        if (hooks.delayedLeave) {\n          hooks.delayedLeave();\n        }\n\n        el._enterCb = undefined;\n      };\n\n      if (hook) {\n        hook(el, done);\n\n        if (hook.length <= 1) {\n          done();\n        }\n      } else {\n        done();\n      }\n    },\n\n    leave(el, remove) {\n      const key = String(vnode.key);\n\n      if (el._enterCb) {\n        el._enterCb(true\n        /* cancelled */\n        );\n      }\n\n      if (state.isUnmounting) {\n        return remove();\n      }\n\n      callHook(onBeforeLeave, [el]);\n      let called = false;\n\n      const done = el._leaveCb = cancelled => {\n        if (called) return;\n        called = true;\n        remove();\n\n        if (cancelled) {\n          callHook(onLeaveCancelled, [el]);\n        } else {\n          callHook(onAfterLeave, [el]);\n        }\n\n        el._leaveCb = undefined;\n\n        if (leavingVNodesCache[key] === vnode) {\n          delete leavingVNodesCache[key];\n        }\n      };\n\n      leavingVNodesCache[key] = vnode;\n\n      if (onLeave) {\n        onLeave(el, done);\n\n        if (onLeave.length <= 1) {\n          done();\n        }\n      } else {\n        done();\n      }\n    },\n\n    clone(vnode) {\n      return resolveTransitionHooks(vnode, props, state, instance);\n    }\n\n  };\n  return hooks;\n} // the placeholder really only handles one special case: KeepAlive\n// in the case of a KeepAlive in a leave phase we need to return a KeepAlive\n// placeholder with empty content to avoid the KeepAlive instance from being\n// unmounted.\n\n\nfunction emptyPlaceholder(vnode) {\n  if (isKeepAlive(vnode)) {\n    vnode = cloneVNode(vnode);\n    vnode.children = null;\n    return vnode;\n  }\n}\n\nfunction getKeepAliveChild(vnode) {\n  return isKeepAlive(vnode) ? vnode.children ? vnode.children[0] : undefined : vnode;\n}\n\nfunction setTransitionHooks(vnode, hooks) {\n  if (vnode.shapeFlag & 6\n  /* COMPONENT */\n  && vnode.component) {\n    setTransitionHooks(vnode.component.subTree, hooks);\n  } else if (vnode.shapeFlag & 128\n  /* SUSPENSE */\n  ) {\n      vnode.ssContent.transition = hooks.clone(vnode.ssContent);\n      vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);\n    } else {\n    vnode.transition = hooks;\n  }\n}\n\nfunction getTransitionRawChildren(children, keepComment = false) {\n  let ret = [];\n  let keyedFragmentCount = 0;\n\n  for (let i = 0; i < children.length; i++) {\n    const child = children[i]; // handle fragment children case, e.g. v-for\n\n    if (child.type === Fragment) {\n      if (child.patchFlag & 128\n      /* KEYED_FRAGMENT */\n      ) keyedFragmentCount++;\n      ret = ret.concat(getTransitionRawChildren(child.children, keepComment));\n    } // comment placeholders should be skipped, e.g. v-if\n    else if (keepComment || child.type !== Comment) {\n        ret.push(child);\n      }\n  } // #1126 if a transition children list contains multiple sub fragments, these\n  // fragments will be merged into a flat children array. Since each v-for\n  // fragment may contain different static bindings inside, we need to de-top\n  // these children to force full diffs to ensure correct behavior.\n\n\n  if (keyedFragmentCount > 1) {\n    for (let i = 0; i < ret.length; i++) {\n      ret[i].patchFlag = -2\n      /* BAIL */\n      ;\n    }\n  }\n\n  return ret;\n}\n\nconst isKeepAlive = vnode => vnode.type.__isKeepAlive;\n\nconst KeepAliveImpl = {\n  name: `KeepAlive`,\n  // Marker for special handling inside the renderer. We are not using a ===\n  // check directly on KeepAlive in the renderer, because importing it directly\n  // would prevent it from being tree-shaken.\n  __isKeepAlive: true,\n  inheritRef: true,\n  props: {\n    include: [String, RegExp, Array],\n    exclude: [String, RegExp, Array],\n    max: [String, Number]\n  },\n\n  setup(props, {\n    slots\n  }) {\n    const cache = new Map();\n    const keys = new Set();\n    let current = null;\n    const instance = getCurrentInstance();\n    const parentSuspense = instance.suspense; // KeepAlive communicates with the instantiated renderer via the\n    // ctx where the renderer passes in its internals,\n    // and the KeepAlive instance exposes activate/deactivate implementations.\n    // The whole point of this is to avoid importing KeepAlive directly in the\n    // renderer to facilitate tree-shaking.\n\n    const sharedContext = instance.ctx;\n    const {\n      renderer: {\n        p: patch,\n        m: move,\n        um: _unmount,\n        o: {\n          createElement\n        }\n      }\n    } = sharedContext;\n    const storageContainer = createElement('div');\n\n    sharedContext.activate = (vnode, container, anchor, isSVG, optimized) => {\n      const instance = vnode.component;\n      move(vnode, container, anchor, 0\n      /* ENTER */\n      , parentSuspense); // in case props have changed\n\n      patch(instance.vnode, vnode, container, anchor, instance, parentSuspense, isSVG, optimized);\n      queuePostRenderEffect(() => {\n        instance.isDeactivated = false;\n\n        if (instance.a) {\n          invokeArrayFns(instance.a);\n        }\n\n        const vnodeHook = vnode.props && vnode.props.onVnodeMounted;\n\n        if (vnodeHook) {\n          invokeVNodeHook(vnodeHook, instance.parent, vnode);\n        }\n      }, parentSuspense);\n    };\n\n    sharedContext.deactivate = vnode => {\n      const instance = vnode.component;\n      move(vnode, storageContainer, null, 1\n      /* LEAVE */\n      , parentSuspense);\n      queuePostRenderEffect(() => {\n        if (instance.da) {\n          invokeArrayFns(instance.da);\n        }\n\n        const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;\n\n        if (vnodeHook) {\n          invokeVNodeHook(vnodeHook, instance.parent, vnode);\n        }\n\n        instance.isDeactivated = true;\n      }, parentSuspense);\n    };\n\n    function unmount(vnode) {\n      // reset the shapeFlag so it can be properly unmounted\n      resetShapeFlag(vnode);\n\n      _unmount(vnode, instance, parentSuspense);\n    }\n\n    function pruneCache(filter) {\n      cache.forEach((vnode, key) => {\n        const name = getName(vnode.type);\n\n        if (name && (!filter || !filter(name))) {\n          pruneCacheEntry(key);\n        }\n      });\n    }\n\n    function pruneCacheEntry(key) {\n      const cached = cache.get(key);\n\n      if (!current || cached.type !== current.type) {\n        unmount(cached);\n      } else if (current) {\n        // current active instance should no longer be kept-alive.\n        // we can't unmount it now but it might be later, so reset its flag now.\n        resetShapeFlag(current);\n      }\n\n      cache.delete(key);\n      keys.delete(key);\n    } // prune cache on include/exclude prop change\n\n\n    watch(() => [props.include, props.exclude], ([include, exclude]) => {\n      include && pruneCache(name => matches(include, name));\n      exclude && pruneCache(name => !matches(exclude, name));\n    }, // prune post-render after `current` has been updated\n    {\n      flush: 'post'\n    }); // cache sub tree after render\n\n    let pendingCacheKey = null;\n\n    const cacheSubtree = () => {\n      // fix #1621, the pendingCacheKey could be 0\n      if (pendingCacheKey != null) {\n        cache.set(pendingCacheKey, getInnerChild(instance.subTree));\n      }\n    };\n\n    onMounted(cacheSubtree);\n    onUpdated(cacheSubtree);\n    onBeforeUnmount(() => {\n      cache.forEach(cached => {\n        const {\n          subTree,\n          suspense\n        } = instance;\n        const vnode = getInnerChild(subTree);\n\n        if (cached.type === vnode.type) {\n          // current instance will be unmounted as part of keep-alive's unmount\n          resetShapeFlag(vnode); // but invoke its deactivated hook here\n\n          const da = vnode.component.da;\n          da && queuePostRenderEffect(da, suspense);\n          return;\n        }\n\n        unmount(cached);\n      });\n    });\n    return () => {\n      pendingCacheKey = null;\n\n      if (!slots.default) {\n        return null;\n      }\n\n      const children = slots.default();\n      const rawVNode = children[0];\n\n      if (children.length > 1) {\n        if (process.env.NODE_ENV !== 'production') {\n          warn(`KeepAlive should contain exactly one component child.`);\n        }\n\n        current = null;\n        return children;\n      } else if (!isVNode(rawVNode) || !(rawVNode.shapeFlag & 4\n      /* STATEFUL_COMPONENT */\n      ) && !(rawVNode.shapeFlag & 128\n      /* SUSPENSE */\n      )) {\n        current = null;\n        return rawVNode;\n      }\n\n      let vnode = getInnerChild(rawVNode);\n      const comp = vnode.type;\n      const name = getName(comp);\n      const {\n        include,\n        exclude,\n        max\n      } = props;\n\n      if (include && (!name || !matches(include, name)) || exclude && name && matches(exclude, name)) {\n        current = vnode;\n        return rawVNode;\n      }\n\n      const key = vnode.key == null ? comp : vnode.key;\n      const cachedVNode = cache.get(key); // clone vnode if it's reused because we are going to mutate it\n\n      if (vnode.el) {\n        vnode = cloneVNode(vnode);\n\n        if (rawVNode.shapeFlag & 128\n        /* SUSPENSE */\n        ) {\n            rawVNode.ssContent = vnode;\n          }\n      } // #1513 it's possible for the returned vnode to be cloned due to attr\n      // fallthrough or scopeId, so the vnode here may not be the final vnode\n      // that is mounted. Instead of caching it directly, we store the pending\n      // key and cache `instance.subTree` (the normalized vnode) in\n      // beforeMount/beforeUpdate hooks.\n\n\n      pendingCacheKey = key;\n\n      if (cachedVNode) {\n        // copy over mounted state\n        vnode.el = cachedVNode.el;\n        vnode.component = cachedVNode.component;\n\n        if (vnode.transition) {\n          // recursively update transition hooks on subTree\n          setTransitionHooks(vnode, vnode.transition);\n        } // avoid vnode being mounted as fresh\n\n\n        vnode.shapeFlag |= 512\n        /* COMPONENT_KEPT_ALIVE */\n        ; // make this key the freshest\n\n        keys.delete(key);\n        keys.add(key);\n      } else {\n        keys.add(key); // prune oldest entry\n\n        if (max && keys.size > parseInt(max, 10)) {\n          pruneCacheEntry(keys.values().next().value);\n        }\n      } // avoid vnode being unmounted\n\n\n      vnode.shapeFlag |= 256\n      /* COMPONENT_SHOULD_KEEP_ALIVE */\n      ;\n      current = vnode;\n      return rawVNode;\n    };\n  }\n\n}; // export the public type for h/tsx inference\n// also to avoid inline import() in generated d.ts files\n\nconst KeepAlive = KeepAliveImpl;\n\nfunction getName(comp) {\n  return comp.displayName || comp.name;\n}\n\nfunction matches(pattern, name) {\n  if (isArray(pattern)) {\n    return pattern.some(p => matches(p, name));\n  } else if (isString(pattern)) {\n    return pattern.split(',').indexOf(name) > -1;\n  } else if (pattern.test) {\n    return pattern.test(name);\n  }\n  /* istanbul ignore next */\n\n\n  return false;\n}\n\nfunction onActivated(hook, target) {\n  registerKeepAliveHook(hook, \"a\"\n  /* ACTIVATED */\n  , target);\n}\n\nfunction onDeactivated(hook, target) {\n  registerKeepAliveHook(hook, \"da\"\n  /* DEACTIVATED */\n  , target);\n}\n\nfunction registerKeepAliveHook(hook, type, target = currentInstance) {\n  // cache the deactivate branch check wrapper for injected hooks so the same\n  // hook can be properly deduped by the scheduler. \"__wdc\" stands for \"with\n  // deactivation check\".\n  const wrappedHook = hook.__wdc || (hook.__wdc = () => {\n    // only fire the hook if the target instance is NOT in a deactivated branch.\n    let current = target;\n\n    while (current) {\n      if (current.isDeactivated) {\n        return;\n      }\n\n      current = current.parent;\n    }\n\n    hook();\n  });\n\n  injectHook(type, wrappedHook, target); // In addition to registering it on the target instance, we walk up the parent\n  // chain and register it on all ancestor instances that are keep-alive roots.\n  // This avoids the need to walk the entire component tree when invoking these\n  // hooks, and more importantly, avoids the need to track child components in\n  // arrays.\n\n  if (target) {\n    let current = target.parent;\n\n    while (current && current.parent) {\n      if (isKeepAlive(current.parent.vnode)) {\n        injectToKeepAliveRoot(wrappedHook, type, target, current);\n      }\n\n      current = current.parent;\n    }\n  }\n}\n\nfunction injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {\n  // injectHook wraps the original for error handling, so make sure to remove\n  // the wrapped version.\n  const injected = injectHook(type, hook, keepAliveRoot, true\n  /* prepend */\n  );\n  onUnmounted(() => {\n    remove(keepAliveRoot[type], injected);\n  }, target);\n}\n\nfunction resetShapeFlag(vnode) {\n  let shapeFlag = vnode.shapeFlag;\n\n  if (shapeFlag & 256\n  /* COMPONENT_SHOULD_KEEP_ALIVE */\n  ) {\n      shapeFlag -= 256\n      /* COMPONENT_SHOULD_KEEP_ALIVE */\n      ;\n    }\n\n  if (shapeFlag & 512\n  /* COMPONENT_KEPT_ALIVE */\n  ) {\n      shapeFlag -= 512\n      /* COMPONENT_KEPT_ALIVE */\n      ;\n    }\n\n  vnode.shapeFlag = shapeFlag;\n}\n\nfunction getInnerChild(vnode) {\n  return vnode.shapeFlag & 128\n  /* SUSPENSE */\n  ? vnode.ssContent : vnode;\n}\n\nconst isInternalKey = key => key[0] === '_' || key === '$stable';\n\nconst normalizeSlotValue = value => isArray(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];\n\nconst normalizeSlot = (key, rawSlot, ctx) => withCtx(props => {\n  if (process.env.NODE_ENV !== 'production' && currentInstance) {\n    warn(`Slot \"${key}\" invoked outside of the render function: ` + `this will not track dependencies used in the slot. ` + `Invoke the slot function inside the render function instead.`);\n  }\n\n  return normalizeSlotValue(rawSlot(props));\n}, ctx);\n\nconst normalizeObjectSlots = (rawSlots, slots) => {\n  const ctx = rawSlots._ctx;\n\n  for (const key in rawSlots) {\n    if (isInternalKey(key)) continue;\n    const value = rawSlots[key];\n\n    if (isFunction(value)) {\n      slots[key] = normalizeSlot(key, value, ctx);\n    } else if (value != null) {\n      if (process.env.NODE_ENV !== 'production') {\n        warn(`Non-function value encountered for slot \"${key}\". ` + `Prefer function slots for better performance.`);\n      }\n\n      const normalized = normalizeSlotValue(value);\n\n      slots[key] = () => normalized;\n    }\n  }\n};\n\nconst normalizeVNodeSlots = (instance, children) => {\n  if (process.env.NODE_ENV !== 'production' && !isKeepAlive(instance.vnode)) {\n    warn(`Non-function value encountered for default slot. ` + `Prefer function slots for better performance.`);\n  }\n\n  const normalized = normalizeSlotValue(children);\n\n  instance.slots.default = () => normalized;\n};\n\nconst initSlots = (instance, children) => {\n  if (instance.vnode.shapeFlag & 32\n  /* SLOTS_CHILDREN */\n  ) {\n      const type = children._;\n\n      if (type) {\n        instance.slots = children; // make compiler marker non-enumerable\n\n        def(children, '_', type);\n      } else {\n        normalizeObjectSlots(children, instance.slots = {});\n      }\n    } else {\n    instance.slots = {};\n\n    if (children) {\n      normalizeVNodeSlots(instance, children);\n    }\n  }\n\n  def(instance.slots, InternalObjectKey, 1);\n};\n\nconst updateSlots = (instance, children) => {\n  const {\n    vnode,\n    slots\n  } = instance;\n  let needDeletionCheck = true;\n  let deletionComparisonTarget = EMPTY_OBJ;\n\n  if (vnode.shapeFlag & 32\n  /* SLOTS_CHILDREN */\n  ) {\n      const type = children._;\n\n      if (type) {\n        // compiled slots.\n        if (process.env.NODE_ENV !== 'production' && isHmrUpdating) {\n          // Parent was HMR updated so slot content may have changed.\n          // force update slots and mark instance for hmr as well\n          extend(slots, children);\n        } else if (type === 1\n        /* STABLE */\n        ) {\n            // compiled AND stable.\n            // no need to update, and skip stale slots removal.\n            needDeletionCheck = false;\n          } else {\n          // compiled but dynamic (v-if/v-for on slots) - update slots, but skip\n          // normalization.\n          extend(slots, children);\n        }\n      } else {\n        needDeletionCheck = !children.$stable;\n        normalizeObjectSlots(children, slots);\n      }\n\n      deletionComparisonTarget = children;\n    } else if (children) {\n    // non slot object children (direct value) passed to a component\n    normalizeVNodeSlots(instance, children);\n    deletionComparisonTarget = {\n      default: 1\n    };\n  } // delete stale slots\n\n\n  if (needDeletionCheck) {\n    for (const key in slots) {\n      if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {\n        delete slots[key];\n      }\n    }\n  }\n};\n/**\r\nRuntime helper for applying directives to a vnode. Example usage:\r\n\nconst comp = resolveComponent('comp')\r\nconst foo = resolveDirective('foo')\r\nconst bar = resolveDirective('bar')\r\n\nreturn withDirectives(h(comp), [\r\n  [foo, this.x],\r\n  [bar, this.y]\r\n])\r\n*/\n\n\nconst isBuiltInDirective = /*#__PURE__*/makeMap('bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text');\n\nfunction validateDirectiveName(name) {\n  if (isBuiltInDirective(name)) {\n    warn('Do not use built-in directive ids as custom directive id: ' + name);\n  }\n}\n/**\r\n * Adds directives to a VNode.\r\n */\n\n\nfunction withDirectives(vnode, directives) {\n  const internalInstance = currentRenderingInstance;\n\n  if (internalInstance === null) {\n    process.env.NODE_ENV !== 'production' && warn(`withDirectives can only be used inside render functions.`);\n    return vnode;\n  }\n\n  const instance = internalInstance.proxy;\n  const bindings = vnode.dirs || (vnode.dirs = []);\n\n  for (let i = 0; i < directives.length; i++) {\n    let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i];\n\n    if (isFunction(dir)) {\n      dir = {\n        mounted: dir,\n        updated: dir\n      };\n    }\n\n    bindings.push({\n      dir,\n      instance,\n      value,\n      oldValue: void 0,\n      arg,\n      modifiers\n    });\n  }\n\n  return vnode;\n}\n\nfunction invokeDirectiveHook(vnode, prevVNode, instance, name) {\n  const bindings = vnode.dirs;\n  const oldBindings = prevVNode && prevVNode.dirs;\n\n  for (let i = 0; i < bindings.length; i++) {\n    const binding = bindings[i];\n\n    if (oldBindings) {\n      binding.oldValue = oldBindings[i].value;\n    }\n\n    const hook = binding.dir[name];\n\n    if (hook) {\n      callWithAsyncErrorHandling(hook, instance, 8\n      /* DIRECTIVE_HOOK */\n      , [vnode.el, binding, vnode, prevVNode]);\n    }\n  }\n}\n\nfunction createAppContext() {\n  return {\n    app: null,\n    config: {\n      isNativeTag: NO,\n      performance: false,\n      globalProperties: {},\n      optionMergeStrategies: {},\n      isCustomElement: NO,\n      errorHandler: undefined,\n      warnHandler: undefined\n    },\n    mixins: [],\n    components: {},\n    directives: {},\n    provides: Object.create(null)\n  };\n}\n\nlet uid = 0;\n\nfunction createAppAPI(render, hydrate) {\n  return function createApp(rootComponent, rootProps = null) {\n    if (rootProps != null && !isObject(rootProps)) {\n      process.env.NODE_ENV !== 'production' && warn(`root props passed to app.mount() must be an object.`);\n      rootProps = null;\n    }\n\n    const context = createAppContext();\n    const installedPlugins = new Set();\n    let isMounted = false;\n    const app = context.app = {\n      _uid: uid++,\n      _component: rootComponent,\n      _props: rootProps,\n      _container: null,\n      _context: context,\n      version,\n\n      get config() {\n        return context.config;\n      },\n\n      set config(v) {\n        if (process.env.NODE_ENV !== 'production') {\n          warn(`app.config cannot be replaced. Modify individual options instead.`);\n        }\n      },\n\n      use(plugin, ...options) {\n        if (installedPlugins.has(plugin)) {\n          process.env.NODE_ENV !== 'production' && warn(`Plugin has already been applied to target app.`);\n        } else if (plugin && isFunction(plugin.install)) {\n          installedPlugins.add(plugin);\n          plugin.install(app, ...options);\n        } else if (isFunction(plugin)) {\n          installedPlugins.add(plugin);\n          plugin(app, ...options);\n        } else if (process.env.NODE_ENV !== 'production') {\n          warn(`A plugin must either be a function or an object with an \"install\" ` + `function.`);\n        }\n\n        return app;\n      },\n\n      mixin(mixin) {\n        if (__VUE_OPTIONS_API__) {\n          if (!context.mixins.includes(mixin)) {\n            context.mixins.push(mixin); // global mixin with props/emits de-optimizes props/emits\n            // normalization caching.\n\n            if (mixin.props || mixin.emits) {\n              context.deopt = true;\n            }\n          } else if (process.env.NODE_ENV !== 'production') {\n            warn('Mixin has already been applied to target app' + (mixin.name ? `: ${mixin.name}` : ''));\n          }\n        } else if (process.env.NODE_ENV !== 'production') {\n          warn('Mixins are only available in builds supporting Options API');\n        }\n\n        return app;\n      },\n\n      component(name, component) {\n        if (process.env.NODE_ENV !== 'production') {\n          validateComponentName(name, context.config);\n        }\n\n        if (!component) {\n          return context.components[name];\n        }\n\n        if (process.env.NODE_ENV !== 'production' && context.components[name]) {\n          warn(`Component \"${name}\" has already been registered in target app.`);\n        }\n\n        context.components[name] = component;\n        return app;\n      },\n\n      directive(name, directive) {\n        if (process.env.NODE_ENV !== 'production') {\n          validateDirectiveName(name);\n        }\n\n        if (!directive) {\n          return context.directives[name];\n        }\n\n        if (process.env.NODE_ENV !== 'production' && context.directives[name]) {\n          warn(`Directive \"${name}\" has already been registered in target app.`);\n        }\n\n        context.directives[name] = directive;\n        return app;\n      },\n\n      mount(rootContainer, isHydrate) {\n        if (!isMounted) {\n          const vnode = createVNode(rootComponent, rootProps); // store app context on the root VNode.\n          // this will be set on the root instance on initial mount.\n\n          vnode.appContext = context; // HMR root reload\n\n          if (process.env.NODE_ENV !== 'production') {\n            context.reload = () => {\n              render(cloneVNode(vnode), rootContainer);\n            };\n          }\n\n          if (isHydrate && hydrate) {\n            hydrate(vnode, rootContainer);\n          } else {\n            render(vnode, rootContainer);\n          }\n\n          isMounted = true;\n          app._container = rootContainer;\n          rootContainer.__vue_app__ = app;\n\n          if (process.env.NODE_ENV !== 'production' || __VUE_PROD_DEVTOOLS__) {\n            devtoolsInitApp(app, version);\n          }\n\n          return vnode.component.proxy;\n        } else if (process.env.NODE_ENV !== 'production') {\n          warn(`App has already been mounted.\\n` + `If you want to remount the same app, move your app creation logic ` + `into a factory function and create fresh app instances for each ` + `mount - e.g. \\`const createMyApp = () => createApp(App)\\``);\n        }\n      },\n\n      unmount() {\n        if (isMounted) {\n          render(null, app._container);\n\n          if (process.env.NODE_ENV !== 'production' || __VUE_PROD_DEVTOOLS__) {\n            devtoolsUnmountApp(app);\n          }\n        } else if (process.env.NODE_ENV !== 'production') {\n          warn(`Cannot unmount an app that is not mounted.`);\n        }\n      },\n\n      provide(key, value) {\n        if (process.env.NODE_ENV !== 'production' && key in context.provides) {\n          warn(`App already provides property with key \"${String(key)}\". ` + `It will be overwritten with the new value.`);\n        } // TypeScript doesn't allow symbols as index type\n        // https://github.com/Microsoft/TypeScript/issues/24587\n\n\n        context.provides[key] = value;\n        return app;\n      }\n\n    };\n    return app;\n  };\n}\n\nlet hasMismatch = false;\n\nconst isSVGContainer = container => /svg/.test(container.namespaceURI) && container.tagName !== 'foreignObject';\n\nconst isComment = node => node.nodeType === 8\n/* COMMENT */\n; // Note: hydration is DOM-specific\n// But we have to place it in core due to tight coupling with core - splitting\n// it out creates a ton of unnecessary complexity.\n// Hydration also depends on some renderer internal logic which needs to be\n// passed in via arguments.\n\n\nfunction createHydrationFunctions(rendererInternals) {\n  const {\n    mt: mountComponent,\n    p: patch,\n    o: {\n      patchProp,\n      nextSibling,\n      parentNode,\n      remove,\n      insert,\n      createComment\n    }\n  } = rendererInternals;\n\n  const hydrate = (vnode, container) => {\n    if (process.env.NODE_ENV !== 'production' && !container.hasChildNodes()) {\n      warn(`Attempting to hydrate existing markup but container is empty. ` + `Performing full mount instead.`);\n      patch(null, vnode, container);\n      return;\n    }\n\n    hasMismatch = false;\n    hydrateNode(container.firstChild, vnode, null, null);\n    flushPostFlushCbs();\n\n    if (hasMismatch && !false) {\n      // this error should show up in production\n      console.error(`Hydration completed but contains mismatches.`);\n    }\n  };\n\n  const hydrateNode = (node, vnode, parentComponent, parentSuspense, optimized = false) => {\n    const isFragmentStart = isComment(node) && node.data === '[';\n\n    const onMismatch = () => handleMismatch(node, vnode, parentComponent, parentSuspense, isFragmentStart);\n\n    const {\n      type,\n      ref,\n      shapeFlag\n    } = vnode;\n    const domType = node.nodeType;\n    vnode.el = node;\n    let nextNode = null;\n\n    switch (type) {\n      case Text:\n        if (domType !== 3\n        /* TEXT */\n        ) {\n            nextNode = onMismatch();\n          } else {\n          if (node.data !== vnode.children) {\n            hasMismatch = true;\n            process.env.NODE_ENV !== 'production' && warn(`Hydration text mismatch:` + `\\n- Client: ${JSON.stringify(node.data)}` + `\\n- Server: ${JSON.stringify(vnode.children)}`);\n            node.data = vnode.children;\n          }\n\n          nextNode = nextSibling(node);\n        }\n\n        break;\n\n      case Comment:\n        if (domType !== 8\n        /* COMMENT */\n        || isFragmentStart) {\n          nextNode = onMismatch();\n        } else {\n          nextNode = nextSibling(node);\n        }\n\n        break;\n\n      case Static:\n        if (domType !== 1\n        /* ELEMENT */\n        ) {\n            nextNode = onMismatch();\n          } else {\n          // determine anchor, adopt content\n          nextNode = node; // if the static vnode has its content stripped during build,\n          // adopt it from the server-rendered HTML.\n\n          const needToAdoptContent = !vnode.children.length;\n\n          for (let i = 0; i < vnode.staticCount; i++) {\n            if (needToAdoptContent) vnode.children += nextNode.outerHTML;\n\n            if (i === vnode.staticCount - 1) {\n              vnode.anchor = nextNode;\n            }\n\n            nextNode = nextSibling(nextNode);\n          }\n\n          return nextNode;\n        }\n\n        break;\n\n      case Fragment:\n        if (!isFragmentStart) {\n          nextNode = onMismatch();\n        } else {\n          nextNode = hydrateFragment(node, vnode, parentComponent, parentSuspense, optimized);\n        }\n\n        break;\n\n      default:\n        if (shapeFlag & 1\n        /* ELEMENT */\n        ) {\n            if (domType !== 1\n            /* ELEMENT */\n            || vnode.type !== node.tagName.toLowerCase()) {\n              nextNode = onMismatch();\n            } else {\n              nextNode = hydrateElement(node, vnode, parentComponent, parentSuspense, optimized);\n            }\n          } else if (shapeFlag & 6\n        /* COMPONENT */\n        ) {\n            // when setting up the render effect, if the initial vnode already\n            // has .el set, the component will perform hydration instead of mount\n            // on its sub-tree.\n            const container = parentNode(node);\n\n            const hydrateComponent = () => {\n              mountComponent(vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), optimized);\n            }; // async component\n\n\n            const loadAsync = vnode.type.__asyncLoader;\n\n            if (loadAsync) {\n              loadAsync().then(hydrateComponent);\n            } else {\n              hydrateComponent();\n            } // component may be async, so in the case of fragments we cannot rely\n            // on component's rendered output to determine the end of the fragment\n            // instead, we do a lookahead to find the end anchor node.\n\n\n            nextNode = isFragmentStart ? locateClosingAsyncAnchor(node) : nextSibling(node);\n          } else if (shapeFlag & 64\n        /* TELEPORT */\n        ) {\n            if (domType !== 8\n            /* COMMENT */\n            ) {\n                nextNode = onMismatch();\n              } else {\n              nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, optimized, rendererInternals, hydrateChildren);\n            }\n          } else if (shapeFlag & 128\n        /* SUSPENSE */\n        ) {\n            nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, isSVGContainer(parentNode(node)), optimized, rendererInternals, hydrateNode);\n          } else if (process.env.NODE_ENV !== 'production') {\n          warn('Invalid HostVNode type:', type, `(${typeof type})`);\n        }\n\n    }\n\n    if (ref != null && parentComponent) {\n      setRef(ref, null, parentComponent, parentSuspense, vnode);\n    }\n\n    return nextNode;\n  };\n\n  const hydrateElement = (el, vnode, parentComponent, parentSuspense, optimized) => {\n    optimized = optimized || !!vnode.dynamicChildren;\n    const {\n      props,\n      patchFlag,\n      shapeFlag,\n      dirs\n    } = vnode; // skip props & children if this is hoisted static nodes\n\n    if (patchFlag !== -1\n    /* HOISTED */\n    ) {\n        if (dirs) {\n          invokeDirectiveHook(vnode, null, parentComponent, 'created');\n        } // props\n\n\n        if (props) {\n          if (!optimized || patchFlag & 16\n          /* FULL_PROPS */\n          || patchFlag & 32\n          /* HYDRATE_EVENTS */\n          ) {\n            for (const key in props) {\n              if (!isReservedProp(key) && isOn(key)) {\n                patchProp(el, key, null, props[key]);\n              }\n            }\n          } else if (props.onClick) {\n            // Fast path for click listeners (which is most often) to avoid\n            // iterating through props.\n            patchProp(el, 'onClick', null, props.onClick);\n          }\n        } // vnode / directive hooks\n\n\n        let vnodeHooks;\n\n        if (vnodeHooks = props && props.onVnodeBeforeMount) {\n          invokeVNodeHook(vnodeHooks, parentComponent, vnode);\n        }\n\n        if (dirs) {\n          invokeDirectiveHook(vnode, null, parentComponent, 'beforeMount');\n        }\n\n        if ((vnodeHooks = props && props.onVnodeMounted) || dirs) {\n          queueEffectWithSuspense(() => {\n            vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);\n            dirs && invokeDirectiveHook(vnode, null, parentComponent, 'mounted');\n          }, parentSuspense);\n        } // children\n\n\n        if (shapeFlag & 16\n        /* ARRAY_CHILDREN */\n        && // skip if element has innerHTML / textContent\n        !(props && (props.innerHTML || props.textContent))) {\n          let next = hydrateChildren(el.firstChild, vnode, el, parentComponent, parentSuspense, optimized);\n          let hasWarned = false;\n\n          while (next) {\n            hasMismatch = true;\n\n            if (process.env.NODE_ENV !== 'production' && !hasWarned) {\n              warn(`Hydration children mismatch in <${vnode.type}>: ` + `server rendered element contains more child nodes than client vdom.`);\n              hasWarned = true;\n            } // The SSRed DOM contains more nodes than it should. Remove them.\n\n\n            const cur = next;\n            next = next.nextSibling;\n            remove(cur);\n          }\n        } else if (shapeFlag & 8\n        /* TEXT_CHILDREN */\n        ) {\n            if (el.textContent !== vnode.children) {\n              hasMismatch = true;\n              process.env.NODE_ENV !== 'production' && warn(`Hydration text content mismatch in <${vnode.type}>:\\n` + `- Client: ${el.textContent}\\n` + `- Server: ${vnode.children}`);\n              el.textContent = vnode.children;\n            }\n          }\n      }\n\n    return el.nextSibling;\n  };\n\n  const hydrateChildren = (node, parentVNode, container, parentComponent, parentSuspense, optimized) => {\n    optimized = optimized || !!parentVNode.dynamicChildren;\n    const children = parentVNode.children;\n    const l = children.length;\n    let hasWarned = false;\n\n    for (let i = 0; i < l; i++) {\n      const vnode = optimized ? children[i] : children[i] = normalizeVNode(children[i]);\n\n      if (node) {\n        node = hydrateNode(node, vnode, parentComponent, parentSuspense, optimized);\n      } else {\n        hasMismatch = true;\n\n        if (process.env.NODE_ENV !== 'production' && !hasWarned) {\n          warn(`Hydration children mismatch in <${container.tagName.toLowerCase()}>: ` + `server rendered element contains fewer child nodes than client vdom.`);\n          hasWarned = true;\n        } // the SSRed DOM didn't contain enough nodes. Mount the missing ones.\n\n\n        patch(null, vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container));\n      }\n    }\n\n    return node;\n  };\n\n  const hydrateFragment = (node, vnode, parentComponent, parentSuspense, optimized) => {\n    const container = parentNode(node);\n    const next = hydrateChildren(nextSibling(node), vnode, container, parentComponent, parentSuspense, optimized);\n\n    if (next && isComment(next) && next.data === ']') {\n      return nextSibling(vnode.anchor = next);\n    } else {\n      // fragment didn't hydrate successfully, since we didn't get a end anchor\n      // back. This should have led to node/children mismatch warnings.\n      hasMismatch = true; // since the anchor is missing, we need to create one and insert it\n\n      insert(vnode.anchor = createComment(`]`), container, next);\n      return next;\n    }\n  };\n\n  const handleMismatch = (node, vnode, parentComponent, parentSuspense, isFragment) => {\n    hasMismatch = true;\n    process.env.NODE_ENV !== 'production' && warn(`Hydration node mismatch:\\n- Client vnode:`, vnode.type, `\\n- Server rendered DOM:`, node, node.nodeType === 3\n    /* TEXT */\n    ? `(text)` : isComment(node) && node.data === '[' ? `(start of fragment)` : ``);\n    vnode.el = null;\n\n    if (isFragment) {\n      // remove excessive fragment nodes\n      const end = locateClosingAsyncAnchor(node);\n\n      while (true) {\n        const next = nextSibling(node);\n\n        if (next && next !== end) {\n          remove(next);\n        } else {\n          break;\n        }\n      }\n    }\n\n    const next = nextSibling(node);\n    const container = parentNode(node);\n    remove(node);\n    patch(null, vnode, container, next, parentComponent, parentSuspense, isSVGContainer(container));\n    return next;\n  };\n\n  const locateClosingAsyncAnchor = node => {\n    let match = 0;\n\n    while (node) {\n      node = nextSibling(node);\n\n      if (node && isComment(node)) {\n        if (node.data === '[') match++;\n\n        if (node.data === ']') {\n          if (match === 0) {\n            return nextSibling(node);\n          } else {\n            match--;\n          }\n        }\n      }\n    }\n\n    return node;\n  };\n\n  return [hydrate, hydrateNode];\n}\n\nlet supported;\nlet perf;\n\nfunction startMeasure(instance, type) {\n  if (instance.appContext.config.performance && isSupported()) {\n    perf.mark(`vue-${type}-${instance.uid}`);\n  }\n}\n\nfunction endMeasure(instance, type) {\n  if (instance.appContext.config.performance && isSupported()) {\n    const startTag = `vue-${type}-${instance.uid}`;\n    const endTag = startTag + `:end`;\n    perf.mark(endTag);\n    perf.measure(`<${formatComponentName(instance, instance.type)}> ${type}`, startTag, endTag);\n    perf.clearMarks(startTag);\n    perf.clearMarks(endTag);\n  }\n}\n\nfunction isSupported() {\n  if (supported !== undefined) {\n    return supported;\n  }\n  /* eslint-disable no-restricted-globals */\n\n\n  if (typeof window !== 'undefined' && window.performance) {\n    supported = true;\n    perf = window.performance;\n  } else {\n    supported = false;\n  }\n  /* eslint-enable no-restricted-globals */\n\n\n  return supported;\n}\n/**\r\n * This is only called in esm-bundler builds.\r\n * It is called when a renderer is created, in `baseCreateRenderer` so that\r\n * importing runtime-core is side-effects free.\r\n *\r\n * istanbul-ignore-next\r\n */\n\n\nfunction initFeatureFlags() {\n  let needWarn = false;\n\n  if (typeof __VUE_OPTIONS_API__ !== 'boolean') {\n    needWarn = true;\n    getGlobalThis().__VUE_OPTIONS_API__ = true;\n  }\n\n  if (typeof __VUE_PROD_DEVTOOLS__ !== 'boolean') {\n    needWarn = true;\n    getGlobalThis().__VUE_PROD_DEVTOOLS__ = false;\n  }\n\n  if (process.env.NODE_ENV !== 'production' && needWarn) {\n    console.warn(`You are running the esm-bundler build of Vue. It is recommended to ` + `configure your bundler to explicitly replace feature flag globals ` + `with boolean literals to get proper tree-shaking in the final bundle. ` + `See http://link.vuejs.org/feature-flags for more details.`);\n  }\n}\n\nconst prodEffectOptions = {\n  scheduler: queueJob,\n  // #1801, #2043 component render effects should allow recursive updates\n  allowRecurse: true\n};\n\nfunction createDevEffectOptions(instance) {\n  return {\n    scheduler: queueJob,\n    allowRecurse: true,\n    onTrack: instance.rtc ? e => invokeArrayFns(instance.rtc, e) : void 0,\n    onTrigger: instance.rtg ? e => invokeArrayFns(instance.rtg, e) : void 0\n  };\n}\n\nconst queuePostRenderEffect = queueEffectWithSuspense;\n\nconst setRef = (rawRef, oldRawRef, parentComponent, parentSuspense, vnode) => {\n  if (isArray(rawRef)) {\n    rawRef.forEach((r, i) => setRef(r, oldRawRef && (isArray(oldRawRef) ? oldRawRef[i] : oldRawRef), parentComponent, parentSuspense, vnode));\n    return;\n  }\n\n  let value;\n\n  if (!vnode) {\n    value = null;\n  } else {\n    if (vnode.shapeFlag & 4\n    /* STATEFUL_COMPONENT */\n    ) {\n        value = vnode.component.proxy;\n      } else {\n      value = vnode.el;\n    }\n  }\n\n  const {\n    i: owner,\n    r: ref\n  } = rawRef;\n\n  if (process.env.NODE_ENV !== 'production' && !owner) {\n    warn(`Missing ref owner context. ref cannot be used on hoisted vnodes. ` + `A vnode with ref must be created inside the render function.`);\n    return;\n  }\n\n  const oldRef = oldRawRef && oldRawRef.r;\n  const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;\n  const setupState = owner.setupState; // unset old ref\n\n  if (oldRef != null && oldRef !== ref) {\n    if (isString(oldRef)) {\n      refs[oldRef] = null;\n\n      if (hasOwn(setupState, oldRef)) {\n        setupState[oldRef] = null;\n      }\n    } else if (isRef(oldRef)) {\n      oldRef.value = null;\n    }\n  }\n\n  if (isString(ref)) {\n    const doSet = () => {\n      refs[ref] = value;\n\n      if (hasOwn(setupState, ref)) {\n        setupState[ref] = value;\n      }\n    }; // #1789: for non-null values, set them after render\n    // null values means this is unmount and it should not overwrite another\n    // ref with the same key\n\n\n    if (value) {\n      doSet.id = -1;\n      queuePostRenderEffect(doSet, parentSuspense);\n    } else {\n      doSet();\n    }\n  } else if (isRef(ref)) {\n    const doSet = () => {\n      ref.value = value;\n    };\n\n    if (value) {\n      doSet.id = -1;\n      queuePostRenderEffect(doSet, parentSuspense);\n    } else {\n      doSet();\n    }\n  } else if (isFunction(ref)) {\n    callWithErrorHandling(ref, parentComponent, 12\n    /* FUNCTION_REF */\n    , [value, refs]);\n  } else if (process.env.NODE_ENV !== 'production') {\n    warn('Invalid template ref type:', value, `(${typeof value})`);\n  }\n};\n/**\r\n * The createRenderer function accepts two generic arguments:\r\n * HostNode and HostElement, corresponding to Node and Element types in the\r\n * host environment. For example, for runtime-dom, HostNode would be the DOM\r\n * `Node` interface and HostElement would be the DOM `Element` interface.\r\n *\r\n * Custom renderers can pass in the platform specific types like this:\r\n *\r\n * ``` js\r\n * const { render, createApp } = createRenderer<Node, Element>({\r\n *   patchProp,\r\n *   ...nodeOps\r\n * })\r\n * ```\r\n */\n\n\nfunction createRenderer(options) {\n  return baseCreateRenderer(options);\n} // Separate API for creating hydration-enabled renderer.\n// Hydration logic is only used when calling this function, making it\n// tree-shakable.\n\n\nfunction createHydrationRenderer(options) {\n  return baseCreateRenderer(options, createHydrationFunctions);\n} // implementation\n\n\nfunction baseCreateRenderer(options, createHydrationFns) {\n  // compile-time feature flags check\n  {\n    initFeatureFlags();\n  }\n  const {\n    insert: hostInsert,\n    remove: hostRemove,\n    patchProp: hostPatchProp,\n    forcePatchProp: hostForcePatchProp,\n    createElement: hostCreateElement,\n    createText: hostCreateText,\n    createComment: hostCreateComment,\n    setText: hostSetText,\n    setElementText: hostSetElementText,\n    parentNode: hostParentNode,\n    nextSibling: hostNextSibling,\n    setScopeId: hostSetScopeId = NOOP,\n    cloneNode: hostCloneNode,\n    insertStaticContent: hostInsertStaticContent\n  } = options; // Note: functions inside this closure should use `const xxx = () => {}`\n  // style in order to prevent being inlined by minifiers.\n\n  const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, optimized = false) => {\n    // patching & not same type, unmount old tree\n    if (n1 && !isSameVNodeType(n1, n2)) {\n      anchor = getNextHostNode(n1);\n      unmount(n1, parentComponent, parentSuspense, true);\n      n1 = null;\n    }\n\n    if (n2.patchFlag === -2\n    /* BAIL */\n    ) {\n        optimized = false;\n        n2.dynamicChildren = null;\n      }\n\n    const {\n      type,\n      ref,\n      shapeFlag\n    } = n2;\n\n    switch (type) {\n      case Text:\n        processText(n1, n2, container, anchor);\n        break;\n\n      case Comment:\n        processCommentNode(n1, n2, container, anchor);\n        break;\n\n      case Static:\n        if (n1 == null) {\n          mountStaticNode(n2, container, anchor, isSVG);\n        } else if (process.env.NODE_ENV !== 'production') {\n          patchStaticNode(n1, n2, container, isSVG);\n        }\n\n        break;\n\n      case Fragment:\n        processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\n        break;\n\n      default:\n        if (shapeFlag & 1\n        /* ELEMENT */\n        ) {\n            processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\n          } else if (shapeFlag & 6\n        /* COMPONENT */\n        ) {\n            processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\n          } else if (shapeFlag & 64\n        /* TELEPORT */\n        ) {\n            type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized, internals);\n          } else if (shapeFlag & 128\n        /* SUSPENSE */\n        ) {\n            type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized, internals);\n          } else if (process.env.NODE_ENV !== 'production') {\n          warn('Invalid VNode type:', type, `(${typeof type})`);\n        }\n\n    } // set ref\n\n\n    if (ref != null && parentComponent) {\n      setRef(ref, n1 && n1.ref, parentComponent, parentSuspense, n2);\n    }\n  };\n\n  const processText = (n1, n2, container, anchor) => {\n    if (n1 == null) {\n      hostInsert(n2.el = hostCreateText(n2.children), container, anchor);\n    } else {\n      const el = n2.el = n1.el;\n\n      if (n2.children !== n1.children) {\n        hostSetText(el, n2.children);\n      }\n    }\n  };\n\n  const processCommentNode = (n1, n2, container, anchor) => {\n    if (n1 == null) {\n      hostInsert(n2.el = hostCreateComment(n2.children || ''), container, anchor);\n    } else {\n      // there's no support for dynamic comments\n      n2.el = n1.el;\n    }\n  };\n\n  const mountStaticNode = (n2, container, anchor, isSVG) => {\n    [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG);\n  };\n  /**\r\n   * Dev / HMR only\r\n   */\n\n\n  const patchStaticNode = (n1, n2, container, isSVG) => {\n    // static nodes are only patched during dev for HMR\n    if (n2.children !== n1.children) {\n      const anchor = hostNextSibling(n1.anchor); // remove existing\n\n      removeStaticNode(n1);\n      [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG);\n    } else {\n      n2.el = n1.el;\n      n2.anchor = n1.anchor;\n    }\n  };\n  /**\r\n   * Dev / HMR only\r\n   */\n\n\n  const moveStaticNode = (vnode, container, anchor) => {\n    let cur = vnode.el;\n    const end = vnode.anchor;\n\n    while (cur && cur !== end) {\n      const next = hostNextSibling(cur);\n      hostInsert(cur, container, anchor);\n      cur = next;\n    }\n\n    hostInsert(end, container, anchor);\n  };\n  /**\r\n   * Dev / HMR only\r\n   */\n\n\n  const removeStaticNode = vnode => {\n    let cur = vnode.el;\n\n    while (cur && cur !== vnode.anchor) {\n      const next = hostNextSibling(cur);\n      hostRemove(cur);\n      cur = next;\n    }\n\n    hostRemove(vnode.anchor);\n  };\n\n  const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {\n    isSVG = isSVG || n2.type === 'svg';\n\n    if (n1 == null) {\n      mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\n    } else {\n      patchElement(n1, n2, parentComponent, parentSuspense, isSVG, optimized);\n    }\n  };\n\n  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {\n    let el;\n    let vnodeHook;\n    const {\n      type,\n      props,\n      shapeFlag,\n      transition,\n      scopeId,\n      patchFlag,\n      dirs\n    } = vnode;\n\n    if (!(process.env.NODE_ENV !== 'production') && vnode.el && hostCloneNode !== undefined && patchFlag === -1\n    /* HOISTED */\n    ) {\n        // If a vnode has non-null el, it means it's being reused.\n        // Only static vnodes can be reused, so its mounted DOM nodes should be\n        // exactly the same, and we can simply do a clone here.\n        // only do this in production since cloned trees cannot be HMR updated.\n        el = vnode.el = hostCloneNode(vnode.el);\n      } else {\n      el = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is); // mount children first, since some props may rely on child content\n      // being already rendered, e.g. `<select value>`\n\n      if (shapeFlag & 8\n      /* TEXT_CHILDREN */\n      ) {\n          hostSetElementText(el, vnode.children);\n        } else if (shapeFlag & 16\n      /* ARRAY_CHILDREN */\n      ) {\n          mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG && type !== 'foreignObject', optimized || !!vnode.dynamicChildren);\n        }\n\n      if (dirs) {\n        invokeDirectiveHook(vnode, null, parentComponent, 'created');\n      } // props\n\n\n      if (props) {\n        for (const key in props) {\n          if (!isReservedProp(key)) {\n            hostPatchProp(el, key, null, props[key], isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);\n          }\n        }\n\n        if (vnodeHook = props.onVnodeBeforeMount) {\n          invokeVNodeHook(vnodeHook, parentComponent, vnode);\n        }\n      } // scopeId\n\n\n      setScopeId(el, scopeId, vnode, parentComponent);\n    }\n\n    if (process.env.NODE_ENV !== 'production' || __VUE_PROD_DEVTOOLS__) {\n      Object.defineProperty(el, '__vnode', {\n        value: vnode,\n        enumerable: false\n      });\n      Object.defineProperty(el, '__vueParentComponent', {\n        value: parentComponent,\n        enumerable: false\n      });\n    }\n\n    if (dirs) {\n      invokeDirectiveHook(vnode, null, parentComponent, 'beforeMount');\n    } // #1583 For inside suspense + suspense not resolved case, enter hook should call when suspense resolved\n    // #1689 For inside suspense + suspense resolved case, just call it\n\n\n    const needCallTransitionHooks = (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;\n\n    if (needCallTransitionHooks) {\n      transition.beforeEnter(el);\n    }\n\n    hostInsert(el, container, anchor);\n\n    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {\n      queuePostRenderEffect(() => {\n        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);\n        needCallTransitionHooks && transition.enter(el);\n        dirs && invokeDirectiveHook(vnode, null, parentComponent, 'mounted');\n      }, parentSuspense);\n    }\n  };\n\n  const setScopeId = (el, scopeId, vnode, parentComponent) => {\n    if (scopeId) {\n      hostSetScopeId(el, scopeId);\n    }\n\n    if (parentComponent) {\n      const treeOwnerId = parentComponent.type.__scopeId; // vnode's own scopeId and the current patched component's scopeId is\n      // different - this is a slot content node.\n\n      if (treeOwnerId && treeOwnerId !== scopeId) {\n        hostSetScopeId(el, treeOwnerId + '-s');\n      }\n\n      let subTree = parentComponent.subTree;\n\n      if (process.env.NODE_ENV !== 'production' && subTree.type === Fragment) {\n        subTree = filterSingleRoot(subTree.children) || subTree;\n      }\n\n      if (vnode === subTree) {\n        setScopeId(el, parentComponent.vnode.scopeId, parentComponent.vnode, parentComponent.parent);\n      }\n    }\n  };\n\n  const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, optimized, start = 0) => {\n    for (let i = start; i < children.length; i++) {\n      const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);\n      patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\n    }\n  };\n\n  const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, optimized) => {\n    const el = n2.el = n1.el;\n    let {\n      patchFlag,\n      dynamicChildren,\n      dirs\n    } = n2; // #1426 take the old vnode's patch flag into account since user may clone a\n    // compiler-generated vnode, which de-opts to FULL_PROPS\n\n    patchFlag |= n1.patchFlag & 16\n    /* FULL_PROPS */\n    ;\n    const oldProps = n1.props || EMPTY_OBJ;\n    const newProps = n2.props || EMPTY_OBJ;\n    let vnodeHook;\n\n    if (vnodeHook = newProps.onVnodeBeforeUpdate) {\n      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);\n    }\n\n    if (dirs) {\n      invokeDirectiveHook(n2, n1, parentComponent, 'beforeUpdate');\n    }\n\n    if (process.env.NODE_ENV !== 'production' && true && isHmrUpdating) {\n      // HMR updated, force full diff\n      patchFlag = 0;\n      optimized = false;\n      dynamicChildren = null;\n    }\n\n    if (patchFlag > 0) {\n      // the presence of a patchFlag means this element's render code was\n      // generated by the compiler and can take the fast path.\n      // in this path old node and new node are guaranteed to have the same shape\n      // (i.e. at the exact same position in the source template)\n      if (patchFlag & 16\n      /* FULL_PROPS */\n      ) {\n          // element props contain dynamic keys, full diff needed\n          patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);\n        } else {\n        // class\n        // this flag is matched when the element has dynamic class bindings.\n        if (patchFlag & 2\n        /* CLASS */\n        ) {\n            if (oldProps.class !== newProps.class) {\n              hostPatchProp(el, 'class', null, newProps.class, isSVG);\n            }\n          } // style\n        // this flag is matched when the element has dynamic style bindings\n\n\n        if (patchFlag & 4\n        /* STYLE */\n        ) {\n            hostPatchProp(el, 'style', oldProps.style, newProps.style, isSVG);\n          } // props\n        // This flag is matched when the element has dynamic prop/attr bindings\n        // other than class and style. The keys of dynamic prop/attrs are saved for\n        // faster iteration.\n        // Note dynamic keys like :[foo]=\"bar\" will cause this optimization to\n        // bail out and go through a full diff because we need to unset the old key\n\n\n        if (patchFlag & 8\n        /* PROPS */\n        ) {\n            // if the flag is present then dynamicProps must be non-null\n            const propsToUpdate = n2.dynamicProps;\n\n            for (let i = 0; i < propsToUpdate.length; i++) {\n              const key = propsToUpdate[i];\n              const prev = oldProps[key];\n              const next = newProps[key];\n\n              if (next !== prev || hostForcePatchProp && hostForcePatchProp(el, key)) {\n                hostPatchProp(el, key, prev, next, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);\n              }\n            }\n          }\n      } // text\n      // This flag is matched when the element has only dynamic text children.\n\n\n      if (patchFlag & 1\n      /* TEXT */\n      ) {\n          if (n1.children !== n2.children) {\n            hostSetElementText(el, n2.children);\n          }\n        }\n    } else if (!optimized && dynamicChildren == null) {\n      // unoptimized, full diff\n      patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);\n    }\n\n    const areChildrenSVG = isSVG && n2.type !== 'foreignObject';\n\n    if (dynamicChildren) {\n      patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG);\n\n      if (process.env.NODE_ENV !== 'production' && true && parentComponent && parentComponent.type.__hmrId) {\n        traverseStaticChildren(n1, n2);\n      }\n    } else if (!optimized) {\n      // full diff\n      patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG);\n    }\n\n    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {\n      queuePostRenderEffect(() => {\n        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);\n        dirs && invokeDirectiveHook(n2, n1, parentComponent, 'updated');\n      }, parentSuspense);\n    }\n  }; // The fast path for blocks.\n\n\n  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG) => {\n    for (let i = 0; i < newChildren.length; i++) {\n      const oldVNode = oldChildren[i];\n      const newVNode = newChildren[i]; // Determine the container (parent element) for the patch.\n\n      const container = // - In the case of a Fragment, we need to provide the actual parent\n      // of the Fragment itself so it can move its children.\n      oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement\n      // which also requires the correct parent container\n      !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.\n      oldVNode.shapeFlag & 6\n      /* COMPONENT */\n      || oldVNode.shapeFlag & 64\n      /* TELEPORT */\n      ? hostParentNode(oldVNode.el) : // In other cases, the parent container is not actually used so we\n      // just pass the block element here to avoid a DOM parentNode call.\n      fallbackContainer;\n      patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, true);\n    }\n  };\n\n  const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {\n    if (oldProps !== newProps) {\n      for (const key in newProps) {\n        if (isReservedProp(key)) continue;\n        const next = newProps[key];\n        const prev = oldProps[key];\n\n        if (next !== prev || hostForcePatchProp && hostForcePatchProp(el, key)) {\n          hostPatchProp(el, key, prev, next, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);\n        }\n      }\n\n      if (oldProps !== EMPTY_OBJ) {\n        for (const key in oldProps) {\n          if (!isReservedProp(key) && !(key in newProps)) {\n            hostPatchProp(el, key, oldProps[key], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);\n          }\n        }\n      }\n    }\n  };\n\n  const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {\n    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText('');\n    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText('');\n    let {\n      patchFlag,\n      dynamicChildren\n    } = n2;\n\n    if (patchFlag > 0) {\n      optimized = true;\n    }\n\n    if (process.env.NODE_ENV !== 'production' && isHmrUpdating) {\n      // HMR updated, force full diff\n      patchFlag = 0;\n      optimized = false;\n      dynamicChildren = null;\n    }\n\n    if (n1 == null) {\n      hostInsert(fragmentStartAnchor, container, anchor);\n      hostInsert(fragmentEndAnchor, container, anchor); // a fragment can only have array children\n      // since they are either generated by the compiler, or implicitly created\n      // from arrays.\n\n      mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, optimized);\n    } else {\n      if (patchFlag > 0 && patchFlag & 64\n      /* STABLE_FRAGMENT */\n      && dynamicChildren) {\n        // a stable fragment (template root or <template v-for>) doesn't need to\n        // patch children order, but it may contain dynamicChildren.\n        patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG);\n\n        if (process.env.NODE_ENV !== 'production' && parentComponent && parentComponent.type.__hmrId) {\n          traverseStaticChildren(n1, n2);\n        } else if ( // #2080 if the stable fragment has a key, it's a <template v-for> that may\n        //  get moved around. Make sure all root level vnodes inherit el.\n        // #2134 or if it's a component root, it may also get moved around\n        // as the component is being moved.\n        n2.key != null || parentComponent && n2 === parentComponent.subTree) {\n          traverseStaticChildren(n1, n2, true\n          /* shallow */\n          );\n        }\n      } else {\n        // keyed / unkeyed, or manual fragments.\n        // for keyed & unkeyed, since they are compiler generated from v-for,\n        // each child is guaranteed to be a block so the fragment will never\n        // have dynamicChildren.\n        patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, optimized);\n      }\n    }\n  };\n\n  const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {\n    if (n1 == null) {\n      if (n2.shapeFlag & 512\n      /* COMPONENT_KEPT_ALIVE */\n      ) {\n          parentComponent.ctx.activate(n2, container, anchor, isSVG, optimized);\n        } else {\n        mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\n      }\n    } else {\n      updateComponent(n1, n2, optimized);\n    }\n  };\n\n  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {\n    const instance = initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense);\n\n    if (process.env.NODE_ENV !== 'production' && true && instance.type.__hmrId) {\n      registerHMR(instance);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      pushWarningContext(initialVNode);\n      startMeasure(instance, `mount`);\n    } // inject renderer internals for keepAlive\n\n\n    if (isKeepAlive(initialVNode)) {\n      instance.ctx.renderer = internals;\n    } // resolve props and slots for setup context\n\n\n    if (process.env.NODE_ENV !== 'production') {\n      startMeasure(instance, `init`);\n    }\n\n    setupComponent(instance);\n\n    if (process.env.NODE_ENV !== 'production') {\n      endMeasure(instance, `init`);\n    } // setup() is async. This component relies on async logic to be resolved\n    // before proceeding\n\n\n    if (instance.asyncDep) {\n      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect); // Give it a placeholder if this is not hydration\n      // TODO handle self-defined fallback\n\n      if (!initialVNode.el) {\n        const placeholder = instance.subTree = createVNode(Comment);\n        processCommentNode(null, placeholder, container, anchor);\n      }\n\n      return;\n    }\n\n    setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized);\n\n    if (process.env.NODE_ENV !== 'production') {\n      popWarningContext();\n      endMeasure(instance, `mount`);\n    }\n  };\n\n  const updateComponent = (n1, n2, optimized) => {\n    const instance = n2.component = n1.component;\n\n    if (shouldUpdateComponent(n1, n2, optimized)) {\n      if (instance.asyncDep && !instance.asyncResolved) {\n        // async & still pending - just update props and slots\n        // since the component's reactive effect for render isn't set-up yet\n        if (process.env.NODE_ENV !== 'production') {\n          pushWarningContext(n2);\n        }\n\n        updateComponentPreRender(instance, n2, optimized);\n\n        if (process.env.NODE_ENV !== 'production') {\n          popWarningContext();\n        }\n\n        return;\n      } else {\n        // normal update\n        instance.next = n2; // in case the child component is also queued, remove it to avoid\n        // double updating the same child component in the same flush.\n\n        invalidateJob(instance.update); // instance.update is the reactive effect runner.\n\n        instance.update();\n      }\n    } else {\n      // no update needed. just copy over properties\n      n2.component = n1.component;\n      n2.el = n1.el;\n      instance.vnode = n2;\n    }\n  };\n\n  const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {\n    // create reactive effect for rendering\n    instance.update = effect(function componentEffect() {\n      if (!instance.isMounted) {\n        let vnodeHook;\n        const {\n          el,\n          props\n        } = initialVNode;\n        const {\n          bm,\n          m,\n          parent\n        } = instance; // beforeMount hook\n\n        if (bm) {\n          invokeArrayFns(bm);\n        } // onVnodeBeforeMount\n\n\n        if (vnodeHook = props && props.onVnodeBeforeMount) {\n          invokeVNodeHook(vnodeHook, parent, initialVNode);\n        } // render\n\n\n        if (process.env.NODE_ENV !== 'production') {\n          startMeasure(instance, `render`);\n        }\n\n        const subTree = instance.subTree = renderComponentRoot(instance);\n\n        if (process.env.NODE_ENV !== 'production') {\n          endMeasure(instance, `render`);\n        }\n\n        if (el && hydrateNode) {\n          if (process.env.NODE_ENV !== 'production') {\n            startMeasure(instance, `hydrate`);\n          } // vnode has adopted host node - perform hydration instead of mount.\n\n\n          hydrateNode(initialVNode.el, subTree, instance, parentSuspense);\n\n          if (process.env.NODE_ENV !== 'production') {\n            endMeasure(instance, `hydrate`);\n          }\n        } else {\n          if (process.env.NODE_ENV !== 'production') {\n            startMeasure(instance, `patch`);\n          }\n\n          patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);\n\n          if (process.env.NODE_ENV !== 'production') {\n            endMeasure(instance, `patch`);\n          }\n\n          initialVNode.el = subTree.el;\n        } // mounted hook\n\n\n        if (m) {\n          queuePostRenderEffect(m, parentSuspense);\n        } // onVnodeMounted\n\n\n        if (vnodeHook = props && props.onVnodeMounted) {\n          queuePostRenderEffect(() => {\n            invokeVNodeHook(vnodeHook, parent, initialVNode);\n          }, parentSuspense);\n        } // activated hook for keep-alive roots.\n        // #1742 activated hook must be accessed after first render\n        // since the hook may be injected by a child keep-alive\n\n\n        const {\n          a\n        } = instance;\n\n        if (a && initialVNode.shapeFlag & 256\n        /* COMPONENT_SHOULD_KEEP_ALIVE */\n        ) {\n            queuePostRenderEffect(a, parentSuspense);\n          }\n\n        instance.isMounted = true;\n      } else {\n        // updateComponent\n        // This is triggered by mutation of component's own state (next: null)\n        // OR parent calling processComponent (next: VNode)\n        let {\n          next,\n          bu,\n          u,\n          parent,\n          vnode\n        } = instance;\n        let originNext = next;\n        let vnodeHook;\n\n        if (process.env.NODE_ENV !== 'production') {\n          pushWarningContext(next || instance.vnode);\n        }\n\n        if (next) {\n          next.el = vnode.el;\n          updateComponentPreRender(instance, next, optimized);\n        } else {\n          next = vnode;\n        } // beforeUpdate hook\n\n\n        if (bu) {\n          invokeArrayFns(bu);\n        } // onVnodeBeforeUpdate\n\n\n        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {\n          invokeVNodeHook(vnodeHook, parent, next, vnode);\n        } // render\n\n\n        if (process.env.NODE_ENV !== 'production') {\n          startMeasure(instance, `render`);\n        }\n\n        const nextTree = renderComponentRoot(instance);\n\n        if (process.env.NODE_ENV !== 'production') {\n          endMeasure(instance, `render`);\n        }\n\n        const prevTree = instance.subTree;\n        instance.subTree = nextTree;\n\n        if (process.env.NODE_ENV !== 'production') {\n          startMeasure(instance, `patch`);\n        }\n\n        patch(prevTree, nextTree, // parent may have changed if it's in a teleport\n        hostParentNode(prevTree.el), // anchor may have changed if it's in a fragment\n        getNextHostNode(prevTree), instance, parentSuspense, isSVG);\n\n        if (process.env.NODE_ENV !== 'production') {\n          endMeasure(instance, `patch`);\n        }\n\n        next.el = nextTree.el;\n\n        if (originNext === null) {\n          // self-triggered update. In case of HOC, update parent component\n          // vnode el. HOC is indicated by parent instance's subTree pointing\n          // to child component's vnode\n          updateHOCHostEl(instance, nextTree.el);\n        } // updated hook\n\n\n        if (u) {\n          queuePostRenderEffect(u, parentSuspense);\n        } // onVnodeUpdated\n\n\n        if (vnodeHook = next.props && next.props.onVnodeUpdated) {\n          queuePostRenderEffect(() => {\n            invokeVNodeHook(vnodeHook, parent, next, vnode);\n          }, parentSuspense);\n        }\n\n        if (process.env.NODE_ENV !== 'production' || __VUE_PROD_DEVTOOLS__) {\n          devtoolsComponentUpdated(instance);\n        }\n\n        if (process.env.NODE_ENV !== 'production') {\n          popWarningContext();\n        }\n      }\n    }, process.env.NODE_ENV !== 'production' ? createDevEffectOptions(instance) : prodEffectOptions);\n  };\n\n  const updateComponentPreRender = (instance, nextVNode, optimized) => {\n    nextVNode.component = instance;\n    const prevProps = instance.vnode.props;\n    instance.vnode = nextVNode;\n    instance.next = null;\n    updateProps(instance, nextVNode.props, prevProps, optimized);\n    updateSlots(instance, nextVNode.children); // props update may have triggered pre-flush watchers.\n    // flush them before the render update.\n\n    flushPreFlushCbs(undefined, instance.update);\n  };\n\n  const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized = false) => {\n    const c1 = n1 && n1.children;\n    const prevShapeFlag = n1 ? n1.shapeFlag : 0;\n    const c2 = n2.children;\n    const {\n      patchFlag,\n      shapeFlag\n    } = n2; // fast path\n\n    if (patchFlag > 0) {\n      if (patchFlag & 128\n      /* KEYED_FRAGMENT */\n      ) {\n          // this could be either fully-keyed or mixed (some keyed some not)\n          // presence of patchFlag means children are guaranteed to be arrays\n          patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\n          return;\n        } else if (patchFlag & 256\n      /* UNKEYED_FRAGMENT */\n      ) {\n          // unkeyed\n          patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\n          return;\n        }\n    } // children has 3 possibilities: text, array or no children.\n\n\n    if (shapeFlag & 8\n    /* TEXT_CHILDREN */\n    ) {\n        // text children fast path\n        if (prevShapeFlag & 16\n        /* ARRAY_CHILDREN */\n        ) {\n            unmountChildren(c1, parentComponent, parentSuspense);\n          }\n\n        if (c2 !== c1) {\n          hostSetElementText(container, c2);\n        }\n      } else {\n      if (prevShapeFlag & 16\n      /* ARRAY_CHILDREN */\n      ) {\n          // prev children was array\n          if (shapeFlag & 16\n          /* ARRAY_CHILDREN */\n          ) {\n              // two arrays, cannot assume anything, do full diff\n              patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\n            } else {\n            // no new children, just unmount old\n            unmountChildren(c1, parentComponent, parentSuspense, true);\n          }\n        } else {\n        // prev children was text OR null\n        // new children is array OR null\n        if (prevShapeFlag & 8\n        /* TEXT_CHILDREN */\n        ) {\n            hostSetElementText(container, '');\n          } // mount new if array\n\n\n        if (shapeFlag & 16\n        /* ARRAY_CHILDREN */\n        ) {\n            mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\n          }\n      }\n    }\n  };\n\n  const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {\n    c1 = c1 || EMPTY_ARR;\n    c2 = c2 || EMPTY_ARR;\n    const oldLength = c1.length;\n    const newLength = c2.length;\n    const commonLength = Math.min(oldLength, newLength);\n    let i;\n\n    for (i = 0; i < commonLength; i++) {\n      const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);\n      patch(c1[i], nextChild, container, null, parentComponent, parentSuspense, isSVG, optimized);\n    }\n\n    if (oldLength > newLength) {\n      // remove old\n      unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);\n    } else {\n      // mount new\n      mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized, commonLength);\n    }\n  }; // can be all-keyed or mixed\n\n\n  const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized) => {\n    let i = 0;\n    const l2 = c2.length;\n    let e1 = c1.length - 1; // prev ending index\n\n    let e2 = l2 - 1; // next ending index\n    // 1. sync from start\n    // (a b) c\n    // (a b) d e\n\n    while (i <= e1 && i <= e2) {\n      const n1 = c1[i];\n      const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);\n\n      if (isSameVNodeType(n1, n2)) {\n        patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, optimized);\n      } else {\n        break;\n      }\n\n      i++;\n    } // 2. sync from end\n    // a (b c)\n    // d e (b c)\n\n\n    while (i <= e1 && i <= e2) {\n      const n1 = c1[e1];\n      const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);\n\n      if (isSameVNodeType(n1, n2)) {\n        patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, optimized);\n      } else {\n        break;\n      }\n\n      e1--;\n      e2--;\n    } // 3. common sequence + mount\n    // (a b)\n    // (a b) c\n    // i = 2, e1 = 1, e2 = 2\n    // (a b)\n    // c (a b)\n    // i = 0, e1 = -1, e2 = 0\n\n\n    if (i > e1) {\n      if (i <= e2) {\n        const nextPos = e2 + 1;\n        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;\n\n        while (i <= e2) {\n          patch(null, c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]), container, anchor, parentComponent, parentSuspense, isSVG);\n          i++;\n        }\n      }\n    } // 4. common sequence + unmount\n    // (a b) c\n    // (a b)\n    // i = 2, e1 = 2, e2 = 1\n    // a (b c)\n    // (b c)\n    // i = 0, e1 = 0, e2 = -1\n    else if (i > e2) {\n        while (i <= e1) {\n          unmount(c1[i], parentComponent, parentSuspense, true);\n          i++;\n        }\n      } // 5. unknown sequence\n      // [i ... e1 + 1]: a b [c d e] f g\n      // [i ... e2 + 1]: a b [e d c h] f g\n      // i = 2, e1 = 4, e2 = 5\n      else {\n          const s1 = i; // prev starting index\n\n          const s2 = i; // next starting index\n          // 5.1 build key:index map for newChildren\n\n          const keyToNewIndexMap = new Map();\n\n          for (i = s2; i <= e2; i++) {\n            const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);\n\n            if (nextChild.key != null) {\n              if (process.env.NODE_ENV !== 'production' && keyToNewIndexMap.has(nextChild.key)) {\n                warn(`Duplicate keys found during update:`, JSON.stringify(nextChild.key), `Make sure keys are unique.`);\n              }\n\n              keyToNewIndexMap.set(nextChild.key, i);\n            }\n          } // 5.2 loop through old children left to be patched and try to patch\n          // matching nodes & remove nodes that are no longer present\n\n\n          let j;\n          let patched = 0;\n          const toBePatched = e2 - s2 + 1;\n          let moved = false; // used to track whether any node has moved\n\n          let maxNewIndexSoFar = 0; // works as Map<newIndex, oldIndex>\n          // Note that oldIndex is offset by +1\n          // and oldIndex = 0 is a special value indicating the new node has\n          // no corresponding old node.\n          // used for determining longest stable subsequence\n\n          const newIndexToOldIndexMap = new Array(toBePatched);\n\n          for (i = 0; i < toBePatched; i++) newIndexToOldIndexMap[i] = 0;\n\n          for (i = s1; i <= e1; i++) {\n            const prevChild = c1[i];\n\n            if (patched >= toBePatched) {\n              // all new children have been patched so this can only be a removal\n              unmount(prevChild, parentComponent, parentSuspense, true);\n              continue;\n            }\n\n            let newIndex;\n\n            if (prevChild.key != null) {\n              newIndex = keyToNewIndexMap.get(prevChild.key);\n            } else {\n              // key-less node, try to locate a key-less node of the same type\n              for (j = s2; j <= e2; j++) {\n                if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {\n                  newIndex = j;\n                  break;\n                }\n              }\n            }\n\n            if (newIndex === undefined) {\n              unmount(prevChild, parentComponent, parentSuspense, true);\n            } else {\n              newIndexToOldIndexMap[newIndex - s2] = i + 1;\n\n              if (newIndex >= maxNewIndexSoFar) {\n                maxNewIndexSoFar = newIndex;\n              } else {\n                moved = true;\n              }\n\n              patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, isSVG, optimized);\n              patched++;\n            }\n          } // 5.3 move and mount\n          // generate longest stable subsequence only when nodes have moved\n\n\n          const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;\n          j = increasingNewIndexSequence.length - 1; // looping backwards so that we can use last patched node as anchor\n\n          for (i = toBePatched - 1; i >= 0; i--) {\n            const nextIndex = s2 + i;\n            const nextChild = c2[nextIndex];\n            const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;\n\n            if (newIndexToOldIndexMap[i] === 0) {\n              // mount new\n              patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG);\n            } else if (moved) {\n              // move if:\n              // There is no stable subsequence (e.g. a reverse)\n              // OR current node is not among the stable sequence\n              if (j < 0 || i !== increasingNewIndexSequence[j]) {\n                move(nextChild, container, anchor, 2\n                /* REORDER */\n                );\n              } else {\n                j--;\n              }\n            }\n          }\n        }\n  };\n\n  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {\n    const {\n      el,\n      type,\n      transition,\n      children,\n      shapeFlag\n    } = vnode;\n\n    if (shapeFlag & 6\n    /* COMPONENT */\n    ) {\n        move(vnode.component.subTree, container, anchor, moveType);\n        return;\n      }\n\n    if (shapeFlag & 128\n    /* SUSPENSE */\n    ) {\n        vnode.suspense.move(container, anchor, moveType);\n        return;\n      }\n\n    if (shapeFlag & 64\n    /* TELEPORT */\n    ) {\n        type.move(vnode, container, anchor, internals);\n        return;\n      }\n\n    if (type === Fragment) {\n      hostInsert(el, container, anchor);\n\n      for (let i = 0; i < children.length; i++) {\n        move(children[i], container, anchor, moveType);\n      }\n\n      hostInsert(vnode.anchor, container, anchor);\n      return;\n    } // static node move can only happen when force updating HMR\n\n\n    if (process.env.NODE_ENV !== 'production' && type === Static) {\n      moveStaticNode(vnode, container, anchor);\n      return;\n    } // single nodes\n\n\n    const needTransition = moveType !== 2\n    /* REORDER */\n    && shapeFlag & 1\n    /* ELEMENT */\n    && transition;\n\n    if (needTransition) {\n      if (moveType === 0\n      /* ENTER */\n      ) {\n          transition.beforeEnter(el);\n          hostInsert(el, container, anchor);\n          queuePostRenderEffect(() => transition.enter(el), parentSuspense);\n        } else {\n        const {\n          leave,\n          delayLeave,\n          afterLeave\n        } = transition;\n\n        const remove = () => hostInsert(el, container, anchor);\n\n        const performLeave = () => {\n          leave(el, () => {\n            remove();\n            afterLeave && afterLeave();\n          });\n        };\n\n        if (delayLeave) {\n          delayLeave(el, remove, performLeave);\n        } else {\n          performLeave();\n        }\n      }\n    } else {\n      hostInsert(el, container, anchor);\n    }\n  };\n\n  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {\n    const {\n      type,\n      props,\n      ref,\n      children,\n      dynamicChildren,\n      shapeFlag,\n      patchFlag,\n      dirs\n    } = vnode; // unset ref\n\n    if (ref != null && parentComponent) {\n      setRef(ref, null, parentComponent, parentSuspense, null);\n    }\n\n    if (shapeFlag & 256\n    /* COMPONENT_SHOULD_KEEP_ALIVE */\n    ) {\n        parentComponent.ctx.deactivate(vnode);\n        return;\n      }\n\n    const shouldInvokeDirs = shapeFlag & 1\n    /* ELEMENT */\n    && dirs;\n    let vnodeHook;\n\n    if (vnodeHook = props && props.onVnodeBeforeUnmount) {\n      invokeVNodeHook(vnodeHook, parentComponent, vnode);\n    }\n\n    if (shapeFlag & 6\n    /* COMPONENT */\n    ) {\n        unmountComponent(vnode.component, parentSuspense, doRemove);\n      } else {\n      if (shapeFlag & 128\n      /* SUSPENSE */\n      ) {\n          vnode.suspense.unmount(parentSuspense, doRemove);\n          return;\n        }\n\n      if (shouldInvokeDirs) {\n        invokeDirectiveHook(vnode, null, parentComponent, 'beforeUnmount');\n      }\n\n      if (dynamicChildren && ( // #1153: fast path should not be taken for non-stable (v-for) fragments\n      type !== Fragment || patchFlag > 0 && patchFlag & 64\n      /* STABLE_FRAGMENT */\n      )) {\n        // fast path for block nodes: only need to unmount dynamic children.\n        unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);\n      } else if (!optimized && shapeFlag & 16\n      /* ARRAY_CHILDREN */\n      ) {\n          unmountChildren(children, parentComponent, parentSuspense);\n        } // an unmounted teleport should always remove its children if not disabled\n\n\n      if (shapeFlag & 64\n      /* TELEPORT */\n      && (doRemove || !isTeleportDisabled(vnode.props))) {\n        vnode.type.remove(vnode, internals);\n      }\n\n      if (doRemove) {\n        remove(vnode);\n      }\n    }\n\n    if ((vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {\n      queuePostRenderEffect(() => {\n        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);\n        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, 'unmounted');\n      }, parentSuspense);\n    }\n  };\n\n  const remove = vnode => {\n    const {\n      type,\n      el,\n      anchor,\n      transition\n    } = vnode;\n\n    if (type === Fragment) {\n      removeFragment(el, anchor);\n      return;\n    }\n\n    if (process.env.NODE_ENV !== 'production' && type === Static) {\n      removeStaticNode(vnode);\n      return;\n    }\n\n    const performRemove = () => {\n      hostRemove(el);\n\n      if (transition && !transition.persisted && transition.afterLeave) {\n        transition.afterLeave();\n      }\n    };\n\n    if (vnode.shapeFlag & 1\n    /* ELEMENT */\n    && transition && !transition.persisted) {\n      const {\n        leave,\n        delayLeave\n      } = transition;\n\n      const performLeave = () => leave(el, performRemove);\n\n      if (delayLeave) {\n        delayLeave(vnode.el, performRemove, performLeave);\n      } else {\n        performLeave();\n      }\n    } else {\n      performRemove();\n    }\n  };\n\n  const removeFragment = (cur, end) => {\n    // For fragments, directly remove all contained DOM nodes.\n    // (fragment child nodes cannot have transition)\n    let next;\n\n    while (cur !== end) {\n      next = hostNextSibling(cur);\n      hostRemove(cur);\n      cur = next;\n    }\n\n    hostRemove(end);\n  };\n\n  const unmountComponent = (instance, parentSuspense, doRemove) => {\n    if (process.env.NODE_ENV !== 'production' && true && instance.type.__hmrId) {\n      unregisterHMR(instance);\n    }\n\n    const {\n      bum,\n      effects,\n      update,\n      subTree,\n      um\n    } = instance; // beforeUnmount hook\n\n    if (bum) {\n      invokeArrayFns(bum);\n    }\n\n    if (effects) {\n      for (let i = 0; i < effects.length; i++) {\n        stop(effects[i]);\n      }\n    } // update may be null if a component is unmounted before its async\n    // setup has resolved.\n\n\n    if (update) {\n      stop(update);\n      unmount(subTree, instance, parentSuspense, doRemove);\n    } // unmounted hook\n\n\n    if (um) {\n      queuePostRenderEffect(um, parentSuspense);\n    }\n\n    queuePostRenderEffect(() => {\n      instance.isUnmounted = true;\n    }, parentSuspense); // A component with async dep inside a pending suspense is unmounted before\n    // its async dep resolves. This should remove the dep from the suspense, and\n    // cause the suspense to resolve immediately if that was the last dep.\n\n    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {\n      parentSuspense.deps--;\n\n      if (parentSuspense.deps === 0) {\n        parentSuspense.resolve();\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production' || __VUE_PROD_DEVTOOLS__) {\n      devtoolsComponentRemoved(instance);\n    }\n  };\n\n  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {\n    for (let i = start; i < children.length; i++) {\n      unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);\n    }\n  };\n\n  const getNextHostNode = vnode => {\n    if (vnode.shapeFlag & 6\n    /* COMPONENT */\n    ) {\n        return getNextHostNode(vnode.component.subTree);\n      }\n\n    if (vnode.shapeFlag & 128\n    /* SUSPENSE */\n    ) {\n        return vnode.suspense.next();\n      }\n\n    return hostNextSibling(vnode.anchor || vnode.el);\n  };\n\n  const render = (vnode, container) => {\n    if (vnode == null) {\n      if (container._vnode) {\n        unmount(container._vnode, null, null, true);\n      }\n    } else {\n      patch(container._vnode || null, vnode, container);\n    }\n\n    flushPostFlushCbs();\n    container._vnode = vnode;\n  };\n\n  const internals = {\n    p: patch,\n    um: unmount,\n    m: move,\n    r: remove,\n    mt: mountComponent,\n    mc: mountChildren,\n    pc: patchChildren,\n    pbc: patchBlockChildren,\n    n: getNextHostNode,\n    o: options\n  };\n  let hydrate;\n  let hydrateNode;\n\n  if (createHydrationFns) {\n    [hydrate, hydrateNode] = createHydrationFns(internals);\n  }\n\n  return {\n    render,\n    hydrate,\n    createApp: createAppAPI(render, hydrate)\n  };\n}\n\nfunction invokeVNodeHook(hook, instance, vnode, prevVNode = null) {\n  callWithAsyncErrorHandling(hook, instance, 7\n  /* VNODE_HOOK */\n  , [vnode, prevVNode]);\n}\n/**\r\n * #1156\r\n * When a component is HMR-enabled, we need to make sure that all static nodes\r\n * inside a block also inherit the DOM element from the previous tree so that\r\n * HMR updates (which are full updates) can retrieve the element for patching.\r\n *\r\n * #2080\r\n * Inside keyed `template` fragment static children, if a fragment is moved,\r\n * the children will always moved so that need inherit el form previous nodes\r\n * to ensure correct moved position.\r\n */\n\n\nfunction traverseStaticChildren(n1, n2, shallow = false) {\n  const ch1 = n1.children;\n  const ch2 = n2.children;\n\n  if (isArray(ch1) && isArray(ch2)) {\n    for (let i = 0; i < ch1.length; i++) {\n      // this is only called in the optimized path so array children are\n      // guaranteed to be vnodes\n      const c1 = ch1[i];\n      let c2 = ch2[i];\n\n      if (c2.shapeFlag & 1\n      /* ELEMENT */\n      && !c2.dynamicChildren) {\n        if (c2.patchFlag <= 0 || c2.patchFlag === 32\n        /* HYDRATE_EVENTS */\n        ) {\n            c2 = ch2[i] = cloneIfMounted(ch2[i]);\n            c2.el = c1.el;\n          }\n\n        if (!shallow) traverseStaticChildren(c1, c2);\n      } // also inherit for comment nodes, but not placeholders (e.g. v-if which\n      // would have received .el during block patch)\n\n\n      if (process.env.NODE_ENV !== 'production' && c2.type === Comment && !c2.el) {\n        c2.el = c1.el;\n      }\n    }\n  }\n} // https://en.wikipedia.org/wiki/Longest_increasing_subsequence\n\n\nfunction getSequence(arr) {\n  const p = arr.slice();\n  const result = [0];\n  let i, j, u, v, c;\n  const len = arr.length;\n\n  for (i = 0; i < len; i++) {\n    const arrI = arr[i];\n\n    if (arrI !== 0) {\n      j = result[result.length - 1];\n\n      if (arr[j] < arrI) {\n        p[i] = j;\n        result.push(i);\n        continue;\n      }\n\n      u = 0;\n      v = result.length - 1;\n\n      while (u < v) {\n        c = (u + v) / 2 | 0;\n\n        if (arr[result[c]] < arrI) {\n          u = c + 1;\n        } else {\n          v = c;\n        }\n      }\n\n      if (arrI < arr[result[u]]) {\n        if (u > 0) {\n          p[i] = result[u - 1];\n        }\n\n        result[u] = i;\n      }\n    }\n  }\n\n  u = result.length;\n  v = result[u - 1];\n\n  while (u-- > 0) {\n    result[u] = v;\n    v = p[v];\n  }\n\n  return result;\n}\n\nconst isTeleport = type => type.__isTeleport;\n\nconst isTeleportDisabled = props => props && (props.disabled || props.disabled === '');\n\nconst resolveTarget = (props, select) => {\n  const targetSelector = props && props.to;\n\n  if (isString(targetSelector)) {\n    if (!select) {\n      process.env.NODE_ENV !== 'production' && warn(`Current renderer does not support string target for Teleports. ` + `(missing querySelector renderer option)`);\n      return null;\n    } else {\n      const target = select(targetSelector);\n\n      if (!target) {\n        process.env.NODE_ENV !== 'production' && warn(`Failed to locate Teleport target with selector \"${targetSelector}\". ` + `Note the target element must exist before the component is mounted - ` + `i.e. the target cannot be rendered by the component itself, and ` + `ideally should be outside of the entire Vue component tree.`);\n      }\n\n      return target;\n    }\n  } else {\n    if (process.env.NODE_ENV !== 'production' && !targetSelector && !isTeleportDisabled(props)) {\n      warn(`Invalid Teleport target: ${targetSelector}`);\n    }\n\n    return targetSelector;\n  }\n};\n\nconst TeleportImpl = {\n  __isTeleport: true,\n\n  process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized, internals) {\n    const {\n      mc: mountChildren,\n      pc: patchChildren,\n      pbc: patchBlockChildren,\n      o: {\n        insert,\n        querySelector,\n        createText,\n        createComment\n      }\n    } = internals;\n    const disabled = isTeleportDisabled(n2.props);\n    const {\n      shapeFlag,\n      children\n    } = n2;\n\n    if (n1 == null) {\n      // insert anchors in the main view\n      const placeholder = n2.el = process.env.NODE_ENV !== 'production' ? createComment('teleport start') : createText('');\n      const mainAnchor = n2.anchor = process.env.NODE_ENV !== 'production' ? createComment('teleport end') : createText('');\n      insert(placeholder, container, anchor);\n      insert(mainAnchor, container, anchor);\n      const target = n2.target = resolveTarget(n2.props, querySelector);\n      const targetAnchor = n2.targetAnchor = createText('');\n\n      if (target) {\n        insert(targetAnchor, target);\n      } else if (process.env.NODE_ENV !== 'production' && !disabled) {\n        warn('Invalid Teleport target on mount:', target, `(${typeof target})`);\n      }\n\n      const mount = (container, anchor) => {\n        // Teleport *always* has Array children. This is enforced in both the\n        // compiler and vnode children normalization.\n        if (shapeFlag & 16\n        /* ARRAY_CHILDREN */\n        ) {\n            mountChildren(children, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\n          }\n      };\n\n      if (disabled) {\n        mount(container, mainAnchor);\n      } else if (target) {\n        mount(target, targetAnchor);\n      }\n    } else {\n      // update content\n      n2.el = n1.el;\n      const mainAnchor = n2.anchor = n1.anchor;\n      const target = n2.target = n1.target;\n      const targetAnchor = n2.targetAnchor = n1.targetAnchor;\n      const wasDisabled = isTeleportDisabled(n1.props);\n      const currentContainer = wasDisabled ? container : target;\n      const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;\n\n      if (n2.dynamicChildren) {\n        // fast path when the teleport happens to be a block root\n        patchBlockChildren(n1.dynamicChildren, n2.dynamicChildren, currentContainer, parentComponent, parentSuspense, isSVG); // even in block tree mode we need to make sure all root-level nodes\n        // in the teleport inherit previous DOM references so that they can\n        // be moved in future patches.\n\n        traverseStaticChildren(n1, n2, true);\n      } else if (!optimized) {\n        patchChildren(n1, n2, currentContainer, currentAnchor, parentComponent, parentSuspense, isSVG);\n      }\n\n      if (disabled) {\n        if (!wasDisabled) {\n          // enabled -> disabled\n          // move into main container\n          moveTeleport(n2, container, mainAnchor, internals, 1\n          /* TOGGLE */\n          );\n        }\n      } else {\n        // target changed\n        if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {\n          const nextTarget = n2.target = resolveTarget(n2.props, querySelector);\n\n          if (nextTarget) {\n            moveTeleport(n2, nextTarget, null, internals, 0\n            /* TARGET_CHANGE */\n            );\n          } else if (process.env.NODE_ENV !== 'production') {\n            warn('Invalid Teleport target on update:', target, `(${typeof target})`);\n          }\n        } else if (wasDisabled) {\n          // disabled -> enabled\n          // move into teleport target\n          moveTeleport(n2, target, targetAnchor, internals, 1\n          /* TOGGLE */\n          );\n        }\n      }\n    }\n  },\n\n  remove(vnode, {\n    r: remove,\n    o: {\n      remove: hostRemove\n    }\n  }) {\n    const {\n      shapeFlag,\n      children,\n      anchor\n    } = vnode;\n    hostRemove(anchor);\n\n    if (shapeFlag & 16\n    /* ARRAY_CHILDREN */\n    ) {\n        for (let i = 0; i < children.length; i++) {\n          remove(children[i]);\n        }\n      }\n  },\n\n  move: moveTeleport,\n  hydrate: hydrateTeleport\n};\n\nfunction moveTeleport(vnode, container, parentAnchor, {\n  o: {\n    insert\n  },\n  m: move\n}, moveType = 2\n/* REORDER */\n) {\n  // move target anchor if this is a target change.\n  if (moveType === 0\n  /* TARGET_CHANGE */\n  ) {\n      insert(vnode.targetAnchor, container, parentAnchor);\n    }\n\n  const {\n    el,\n    anchor,\n    shapeFlag,\n    children,\n    props\n  } = vnode;\n  const isReorder = moveType === 2\n  /* REORDER */\n  ; // move main view anchor if this is a re-order.\n\n  if (isReorder) {\n    insert(el, container, parentAnchor);\n  } // if this is a re-order and teleport is enabled (content is in target)\n  // do not move children. So the opposite is: only move children if this\n  // is not a reorder, or the teleport is disabled\n\n\n  if (!isReorder || isTeleportDisabled(props)) {\n    // Teleport has either Array children or no children.\n    if (shapeFlag & 16\n    /* ARRAY_CHILDREN */\n    ) {\n        for (let i = 0; i < children.length; i++) {\n          move(children[i], container, parentAnchor, 2\n          /* REORDER */\n          );\n        }\n      }\n  } // move main view anchor if this is a re-order.\n\n\n  if (isReorder) {\n    insert(anchor, container, parentAnchor);\n  }\n}\n\nfunction hydrateTeleport(node, vnode, parentComponent, parentSuspense, optimized, {\n  o: {\n    nextSibling,\n    parentNode,\n    querySelector\n  }\n}, hydrateChildren) {\n  const target = vnode.target = resolveTarget(vnode.props, querySelector);\n\n  if (target) {\n    // if multiple teleports rendered to the same target element, we need to\n    // pick up from where the last teleport finished instead of the first node\n    const targetNode = target._lpa || target.firstChild;\n\n    if (vnode.shapeFlag & 16\n    /* ARRAY_CHILDREN */\n    ) {\n        if (isTeleportDisabled(vnode.props)) {\n          vnode.anchor = hydrateChildren(nextSibling(node), vnode, parentNode(node), parentComponent, parentSuspense, optimized);\n          vnode.targetAnchor = targetNode;\n        } else {\n          vnode.anchor = nextSibling(node);\n          vnode.targetAnchor = hydrateChildren(targetNode, vnode, target, parentComponent, parentSuspense, optimized);\n        }\n\n        target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);\n      }\n  }\n\n  return vnode.anchor && nextSibling(vnode.anchor);\n} // Force-casted public typing for h and TSX props inference\n\n\nconst Teleport = TeleportImpl;\nconst COMPONENTS = 'components';\nconst DIRECTIVES = 'directives';\n/**\r\n * @private\r\n */\n\nfunction resolveComponent(name) {\n  return resolveAsset(COMPONENTS, name) || name;\n}\n\nconst NULL_DYNAMIC_COMPONENT = Symbol();\n/**\r\n * @private\r\n */\n\nfunction resolveDynamicComponent(component) {\n  if (isString(component)) {\n    return resolveAsset(COMPONENTS, component, false) || component;\n  } else {\n    // invalid types will fallthrough to createVNode and raise warning\n    return component || NULL_DYNAMIC_COMPONENT;\n  }\n}\n/**\r\n * @private\r\n */\n\n\nfunction resolveDirective(name) {\n  return resolveAsset(DIRECTIVES, name);\n} // implementation\n\n\nfunction resolveAsset(type, name, warnMissing = true) {\n  const instance = currentRenderingInstance || currentInstance;\n\n  if (instance) {\n    const Component = instance.type; // self name has highest priority\n\n    if (type === COMPONENTS) {\n      const selfName = Component.displayName || Component.name;\n\n      if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize(camelize(name)))) {\n        return Component;\n      }\n    }\n\n    const res = // local registration\n    // check instance[type] first for components with mixin or extends.\n    resolve(instance[type] || Component[type], name) || // global registration\n    resolve(instance.appContext[type], name);\n\n    if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {\n      warn(`Failed to resolve ${type.slice(0, -1)}: ${name}`);\n    }\n\n    return res;\n  } else if (process.env.NODE_ENV !== 'production') {\n    warn(`resolve${capitalize(type.slice(0, -1))} ` + `can only be used in render() or setup().`);\n  }\n}\n\nfunction resolve(registry, name) {\n  return registry && (registry[name] || registry[camelize(name)] || registry[capitalize(camelize(name))]);\n}\n\nconst Fragment = Symbol(process.env.NODE_ENV !== 'production' ? 'Fragment' : undefined);\nconst Text = Symbol(process.env.NODE_ENV !== 'production' ? 'Text' : undefined);\nconst Comment = Symbol(process.env.NODE_ENV !== 'production' ? 'Comment' : undefined);\nconst Static = Symbol(process.env.NODE_ENV !== 'production' ? 'Static' : undefined); // Since v-if and v-for are the two possible ways node structure can dynamically\n// change, once we consider v-if branches and each v-for fragment a block, we\n// can divide a template into nested blocks, and within each block the node\n// structure would be stable. This allows us to skip most children diffing\n// and only worry about the dynamic nodes (indicated by patch flags).\n\nconst blockStack = [];\nlet currentBlock = null;\n/**\r\n * Open a block.\r\n * This must be called before `createBlock`. It cannot be part of `createBlock`\r\n * because the children of the block are evaluated before `createBlock` itself\r\n * is called. The generated code typically looks like this:\r\n *\r\n * ```js\r\n * function render() {\r\n *   return (openBlock(),createBlock('div', null, [...]))\r\n * }\r\n * ```\r\n * disableTracking is true when creating a v-for fragment block, since a v-for\r\n * fragment always diffs its children.\r\n *\r\n * @private\r\n */\n\nfunction openBlock(disableTracking = false) {\n  blockStack.push(currentBlock = disableTracking ? null : []);\n}\n\nfunction closeBlock() {\n  blockStack.pop();\n  currentBlock = blockStack[blockStack.length - 1] || null;\n} // Whether we should be tracking dynamic child nodes inside a block.\n// Only tracks when this value is > 0\n// We are not using a simple boolean because this value may need to be\n// incremented/decremented by nested usage of v-once (see below)\n\n\nlet shouldTrack = 1;\n/**\r\n * Block tracking sometimes needs to be disabled, for example during the\r\n * creation of a tree that needs to be cached by v-once. The compiler generates\r\n * code like this:\r\n *\r\n * ``` js\r\n * _cache[1] || (\r\n *   setBlockTracking(-1),\r\n *   _cache[1] = createVNode(...),\r\n *   setBlockTracking(1),\r\n *   _cache[1]\r\n * )\r\n * ```\r\n *\r\n * @private\r\n */\n\nfunction setBlockTracking(value) {\n  shouldTrack += value;\n}\n/**\r\n * Create a block root vnode. Takes the same exact arguments as `createVNode`.\r\n * A block root keeps track of dynamic nodes within the block in the\r\n * `dynamicChildren` array.\r\n *\r\n * @private\r\n */\n\n\nfunction createBlock(type, props, children, patchFlag, dynamicProps) {\n  const vnode = createVNode(type, props, children, patchFlag, dynamicProps, true\n  /* isBlock: prevent a block from tracking itself */\n  ); // save current block children on the block vnode\n\n  vnode.dynamicChildren = currentBlock || EMPTY_ARR; // close block\n\n  closeBlock(); // a block is always going to be patched, so track it as a child of its\n  // parent block\n\n  if (shouldTrack > 0 && currentBlock) {\n    currentBlock.push(vnode);\n  }\n\n  return vnode;\n}\n\nfunction isVNode(value) {\n  return value ? value.__v_isVNode === true : false;\n}\n\nfunction isSameVNodeType(n1, n2) {\n  if (process.env.NODE_ENV !== 'production' && n2.shapeFlag & 6\n  /* COMPONENT */\n  && hmrDirtyComponents.has(n2.type)) {\n    // HMR only: if the component has been hot-updated, force a reload.\n    return false;\n  }\n\n  return n1.type === n2.type && n1.key === n2.key;\n}\n\nlet vnodeArgsTransformer;\n/**\r\n * Internal API for registering an arguments transform for createVNode\r\n * used for creating stubs in the test-utils\r\n * It is *internal* but needs to be exposed for test-utils to pick up proper\r\n * typings\r\n */\n\nfunction transformVNodeArgs(transformer) {\n  vnodeArgsTransformer = transformer;\n}\n\nconst createVNodeWithArgsTransform = (...args) => {\n  return _createVNode(...(vnodeArgsTransformer ? vnodeArgsTransformer(args, currentRenderingInstance) : args));\n};\n\nconst InternalObjectKey = `__vInternal`;\n\nconst normalizeKey = ({\n  key\n}) => key != null ? key : null;\n\nconst normalizeRef = ({\n  ref\n}) => {\n  return ref != null ? isArray(ref) ? ref : {\n    i: currentRenderingInstance,\n    r: ref\n  } : null;\n};\n\nconst createVNode = process.env.NODE_ENV !== 'production' ? createVNodeWithArgsTransform : _createVNode;\n\nfunction _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {\n  if (!type || type === NULL_DYNAMIC_COMPONENT) {\n    if (process.env.NODE_ENV !== 'production' && !type) {\n      warn(`Invalid vnode type when creating vnode: ${type}.`);\n    }\n\n    type = Comment;\n  }\n\n  if (isVNode(type)) {\n    // createVNode receiving an existing vnode. This happens in cases like\n    // <component :is=\"vnode\"/>\n    // #2078 make sure to merge refs during the clone instead of overwriting it\n    const cloned = cloneVNode(type, props, true\n    /* mergeRef: true */\n    );\n\n    if (children) {\n      normalizeChildren(cloned, children);\n    }\n\n    return cloned;\n  } // class component normalization.\n\n\n  if (isClassComponent(type)) {\n    type = type.__vccOpts;\n  } // class & style normalization.\n\n\n  if (props) {\n    // for reactive or proxy objects, we need to clone it to enable mutation.\n    if (isProxy(props) || InternalObjectKey in props) {\n      props = extend({}, props);\n    }\n\n    let {\n      class: klass,\n      style\n    } = props;\n\n    if (klass && !isString(klass)) {\n      props.class = normalizeClass(klass);\n    }\n\n    if (isObject(style)) {\n      // reactive state objects need to be cloned since they are likely to be\n      // mutated\n      if (isProxy(style) && !isArray(style)) {\n        style = extend({}, style);\n      }\n\n      props.style = normalizeStyle(style);\n    }\n  } // encode the vnode type information into a bitmap\n\n\n  const shapeFlag = isString(type) ? 1\n  /* ELEMENT */\n  : isSuspense(type) ? 128\n  /* SUSPENSE */\n  : isTeleport(type) ? 64\n  /* TELEPORT */\n  : isObject(type) ? 4\n  /* STATEFUL_COMPONENT */\n  : isFunction(type) ? 2\n  /* FUNCTIONAL_COMPONENT */\n  : 0;\n\n  if (process.env.NODE_ENV !== 'production' && shapeFlag & 4\n  /* STATEFUL_COMPONENT */\n  && isProxy(type)) {\n    type = toRaw(type);\n    warn(`Vue received a Component which was made a reactive object. This can ` + `lead to unnecessary performance overhead, and should be avoided by ` + `marking the component with \\`markRaw\\` or using \\`shallowRef\\` ` + `instead of \\`ref\\`.`, `\\nComponent that was made reactive: `, type);\n  }\n\n  const vnode = {\n    __v_isVNode: true,\n    [\"__v_skip\"\n    /* SKIP */\n    ]: true,\n    type,\n    props,\n    key: props && normalizeKey(props),\n    ref: props && normalizeRef(props),\n    scopeId: currentScopeId,\n    children: null,\n    component: null,\n    suspense: null,\n    ssContent: null,\n    ssFallback: null,\n    dirs: null,\n    transition: null,\n    el: null,\n    anchor: null,\n    target: null,\n    targetAnchor: null,\n    staticCount: 0,\n    shapeFlag,\n    patchFlag,\n    dynamicProps,\n    dynamicChildren: null,\n    appContext: null\n  }; // validate key\n\n  if (process.env.NODE_ENV !== 'production' && vnode.key !== vnode.key) {\n    warn(`VNode created with invalid key (NaN). VNode type:`, vnode.type);\n  }\n\n  normalizeChildren(vnode, children); // normalize suspense children\n\n  if (shapeFlag & 128\n  /* SUSPENSE */\n  ) {\n      const {\n        content,\n        fallback\n      } = normalizeSuspenseChildren(vnode);\n      vnode.ssContent = content;\n      vnode.ssFallback = fallback;\n    }\n\n  if (shouldTrack > 0 && // avoid a block node from tracking itself\n  !isBlockNode && // has current parent block\n  currentBlock && ( // presence of a patch flag indicates this node needs patching on updates.\n  // component nodes also should always be patched, because even if the\n  // component doesn't need to update, it needs to persist the instance on to\n  // the next vnode so that it can be properly unmounted later.\n  patchFlag > 0 || shapeFlag & 6\n  /* COMPONENT */\n  ) && // the EVENTS flag is only for hydration and if it is the only flag, the\n  // vnode should not be considered dynamic due to handler caching.\n  patchFlag !== 32\n  /* HYDRATE_EVENTS */\n  ) {\n      currentBlock.push(vnode);\n    }\n\n  return vnode;\n}\n\nfunction cloneVNode(vnode, extraProps, mergeRef = false) {\n  // This is intentionally NOT using spread or extend to avoid the runtime\n  // key enumeration cost.\n  const {\n    props,\n    ref,\n    patchFlag\n  } = vnode;\n  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;\n  return {\n    __v_isVNode: true,\n    [\"__v_skip\"\n    /* SKIP */\n    ]: true,\n    type: vnode.type,\n    props: mergedProps,\n    key: mergedProps && normalizeKey(mergedProps),\n    ref: extraProps && extraProps.ref ? // #2078 in the case of <component :is=\"vnode\" ref=\"extra\"/>\n    // if the vnode itself already has a ref, cloneVNode will need to merge\n    // the refs so the single vnode can be set on multiple refs\n    mergeRef && ref ? isArray(ref) ? ref.concat(normalizeRef(extraProps)) : [ref, normalizeRef(extraProps)] : normalizeRef(extraProps) : ref,\n    scopeId: vnode.scopeId,\n    children: vnode.children,\n    target: vnode.target,\n    targetAnchor: vnode.targetAnchor,\n    staticCount: vnode.staticCount,\n    shapeFlag: vnode.shapeFlag,\n    // if the vnode is cloned with extra props, we can no longer assume its\n    // existing patch flag to be reliable and need to add the FULL_PROPS flag.\n    // note: perserve flag for fragments since they use the flag for children\n    // fast paths only.\n    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 // hoisted node\n    ? 16\n    /* FULL_PROPS */\n    : patchFlag | 16\n    /* FULL_PROPS */\n    : patchFlag,\n    dynamicProps: vnode.dynamicProps,\n    dynamicChildren: vnode.dynamicChildren,\n    appContext: vnode.appContext,\n    dirs: vnode.dirs,\n    transition: vnode.transition,\n    // These should technically only be non-null on mounted VNodes. However,\n    // they *should* be copied for kept-alive vnodes. So we just always copy\n    // them since them being non-null during a mount doesn't affect the logic as\n    // they will simply be overwritten.\n    component: vnode.component,\n    suspense: vnode.suspense,\n    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),\n    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),\n    el: vnode.el,\n    anchor: vnode.anchor\n  };\n}\n/**\r\n * @private\r\n */\n\n\nfunction createTextVNode(text = ' ', flag = 0) {\n  return createVNode(Text, null, text, flag);\n}\n/**\r\n * @private\r\n */\n\n\nfunction createStaticVNode(content, numberOfNodes) {\n  // A static vnode can contain multiple stringified elements, and the number\n  // of elements is necessary for hydration.\n  const vnode = createVNode(Static, null, content);\n  vnode.staticCount = numberOfNodes;\n  return vnode;\n}\n/**\r\n * @private\r\n */\n\n\nfunction createCommentVNode(text = '', // when used as the v-else branch, the comment node must be created as a\n// block to ensure correct updates.\nasBlock = false) {\n  return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);\n}\n\nfunction normalizeVNode(child) {\n  if (child == null || typeof child === 'boolean') {\n    // empty placeholder\n    return createVNode(Comment);\n  } else if (isArray(child)) {\n    // fragment\n    return createVNode(Fragment, null, child);\n  } else if (typeof child === 'object') {\n    // already vnode, this should be the most common since compiled templates\n    // always produce all-vnode children arrays\n    return child.el === null ? child : cloneVNode(child);\n  } else {\n    // strings and numbers\n    return createVNode(Text, null, String(child));\n  }\n} // optimized normalization for template-compiled render fns\n\n\nfunction cloneIfMounted(child) {\n  return child.el === null ? child : cloneVNode(child);\n}\n\nfunction normalizeChildren(vnode, children) {\n  let type = 0;\n  const {\n    shapeFlag\n  } = vnode;\n\n  if (children == null) {\n    children = null;\n  } else if (isArray(children)) {\n    type = 16\n    /* ARRAY_CHILDREN */\n    ;\n  } else if (typeof children === 'object') {\n    if (shapeFlag & 1\n    /* ELEMENT */\n    || shapeFlag & 64\n    /* TELEPORT */\n    ) {\n        // Normalize slot to plain children for plain element and Teleport\n        const slot = children.default;\n\n        if (slot) {\n          // _c marker is added by withCtx() indicating this is a compiled slot\n          slot._c && setCompiledSlotRendering(1);\n          normalizeChildren(vnode, slot());\n          slot._c && setCompiledSlotRendering(-1);\n        }\n\n        return;\n      } else {\n      type = 32\n      /* SLOTS_CHILDREN */\n      ;\n      const slotFlag = children._;\n\n      if (!slotFlag && !(InternalObjectKey in children)) {\n        children._ctx = currentRenderingInstance;\n      } else if (slotFlag === 3\n      /* FORWARDED */\n      && currentRenderingInstance) {\n        // a child component receives forwarded slots from the parent.\n        // its slot type is determined by its parent's slot type.\n        if (currentRenderingInstance.vnode.patchFlag & 1024\n        /* DYNAMIC_SLOTS */\n        ) {\n            children._ = 2\n            /* DYNAMIC */\n            ;\n            vnode.patchFlag |= 1024\n            /* DYNAMIC_SLOTS */\n            ;\n          } else {\n          children._ = 1\n          /* STABLE */\n          ;\n        }\n      }\n    }\n  } else if (isFunction(children)) {\n    children = {\n      default: children,\n      _ctx: currentRenderingInstance\n    };\n    type = 32\n    /* SLOTS_CHILDREN */\n    ;\n  } else {\n    children = String(children); // force teleport children to array so it can be moved around\n\n    if (shapeFlag & 64\n    /* TELEPORT */\n    ) {\n        type = 16\n        /* ARRAY_CHILDREN */\n        ;\n        children = [createTextVNode(children)];\n      } else {\n      type = 8\n      /* TEXT_CHILDREN */\n      ;\n    }\n  }\n\n  vnode.children = children;\n  vnode.shapeFlag |= type;\n}\n\nfunction mergeProps(...args) {\n  const ret = extend({}, args[0]);\n\n  for (let i = 1; i < args.length; i++) {\n    const toMerge = args[i];\n\n    for (const key in toMerge) {\n      if (key === 'class') {\n        if (ret.class !== toMerge.class) {\n          ret.class = normalizeClass([ret.class, toMerge.class]);\n        }\n      } else if (key === 'style') {\n        ret.style = normalizeStyle([ret.style, toMerge.style]);\n      } else if (isOn(key)) {\n        const existing = ret[key];\n        const incoming = toMerge[key];\n\n        if (existing !== incoming) {\n          ret[key] = existing ? [].concat(existing, toMerge[key]) : incoming;\n        }\n      } else {\n        ret[key] = toMerge[key];\n      }\n    }\n  }\n\n  return ret;\n}\n\nfunction provide(key, value) {\n  if (!currentInstance) {\n    if (process.env.NODE_ENV !== 'production') {\n      warn(`provide() can only be used inside setup().`);\n    }\n  } else {\n    let provides = currentInstance.provides; // by default an instance inherits its parent's provides object\n    // but when it needs to provide values of its own, it creates its\n    // own provides object using parent provides object as prototype.\n    // this way in `inject` we can simply look up injections from direct\n    // parent and let the prototype chain do the work.\n\n    const parentProvides = currentInstance.parent && currentInstance.parent.provides;\n\n    if (parentProvides === provides) {\n      provides = currentInstance.provides = Object.create(parentProvides);\n    } // TS doesn't allow symbol as index type\n\n\n    provides[key] = value;\n  }\n}\n\nfunction inject(key, defaultValue, treatDefaultAsFactory = false) {\n  // fallback to `currentRenderingInstance` so that this can be called in\n  // a functional component\n  const instance = currentInstance || currentRenderingInstance;\n\n  if (instance) {\n    const provides = instance.provides;\n\n    if (key in provides) {\n      // TS doesn't allow symbol as index type\n      return provides[key];\n    } else if (arguments.length > 1) {\n      return treatDefaultAsFactory && isFunction(defaultValue) ? defaultValue() : defaultValue;\n    } else if (process.env.NODE_ENV !== 'production') {\n      warn(`injection \"${String(key)}\" not found.`);\n    }\n  } else if (process.env.NODE_ENV !== 'production') {\n    warn(`inject() can only be used inside setup() or functional components.`);\n  }\n}\n\nfunction createDuplicateChecker() {\n  const cache = Object.create(null);\n  return (type, key) => {\n    if (cache[key]) {\n      warn(`${type} property \"${key}\" is already defined in ${cache[key]}.`);\n    } else {\n      cache[key] = type;\n    }\n  };\n}\n\nlet isInBeforeCreate = false;\n\nfunction applyOptions(instance, options, deferredData = [], deferredWatch = [], deferredProvide = [], asMixin = false) {\n  const {\n    // composition\n    mixins,\n    extends: extendsOptions,\n    // state\n    data: dataOptions,\n    computed: computedOptions,\n    methods,\n    watch: watchOptions,\n    provide: provideOptions,\n    inject: injectOptions,\n    // assets\n    components,\n    directives,\n    // lifecycle\n    beforeMount,\n    mounted,\n    beforeUpdate,\n    updated,\n    activated,\n    deactivated,\n    beforeDestroy,\n    beforeUnmount,\n    destroyed,\n    unmounted,\n    render,\n    renderTracked,\n    renderTriggered,\n    errorCaptured\n  } = options;\n  const publicThis = instance.proxy;\n  const ctx = instance.ctx;\n  const globalMixins = instance.appContext.mixins;\n\n  if (asMixin && render && instance.render === NOOP) {\n    instance.render = render;\n  } // applyOptions is called non-as-mixin once per instance\n\n\n  if (!asMixin) {\n    isInBeforeCreate = true;\n    callSyncHook('beforeCreate', \"bc\"\n    /* BEFORE_CREATE */\n    , options, instance, globalMixins);\n    isInBeforeCreate = false; // global mixins are applied first\n\n    applyMixins(instance, globalMixins, deferredData, deferredWatch, deferredProvide);\n  } // extending a base component...\n\n\n  if (extendsOptions) {\n    applyOptions(instance, extendsOptions, deferredData, deferredWatch, deferredProvide, true);\n  } // local mixins\n\n\n  if (mixins) {\n    applyMixins(instance, mixins, deferredData, deferredWatch, deferredProvide);\n  }\n\n  const checkDuplicateProperties = process.env.NODE_ENV !== 'production' ? createDuplicateChecker() : null;\n\n  if (process.env.NODE_ENV !== 'production') {\n    const [propsOptions] = instance.propsOptions;\n\n    if (propsOptions) {\n      for (const key in propsOptions) {\n        checkDuplicateProperties(\"Props\"\n        /* PROPS */\n        , key);\n      }\n    }\n  } // options initialization order (to be consistent with Vue 2):\n  // - props (already done outside of this function)\n  // - inject\n  // - methods\n  // - data (deferred since it relies on `this` access)\n  // - computed\n  // - watch (deferred since it relies on `this` access)\n\n\n  if (injectOptions) {\n    if (isArray(injectOptions)) {\n      for (let i = 0; i < injectOptions.length; i++) {\n        const key = injectOptions[i];\n        ctx[key] = inject(key);\n\n        if (process.env.NODE_ENV !== 'production') {\n          checkDuplicateProperties(\"Inject\"\n          /* INJECT */\n          , key);\n        }\n      }\n    } else {\n      for (const key in injectOptions) {\n        const opt = injectOptions[key];\n\n        if (isObject(opt)) {\n          ctx[key] = inject(opt.from || key, opt.default, true\n          /* treat default function as factory */\n          );\n        } else {\n          ctx[key] = inject(opt);\n        }\n\n        if (process.env.NODE_ENV !== 'production') {\n          checkDuplicateProperties(\"Inject\"\n          /* INJECT */\n          , key);\n        }\n      }\n    }\n  }\n\n  if (methods) {\n    for (const key in methods) {\n      const methodHandler = methods[key];\n\n      if (isFunction(methodHandler)) {\n        ctx[key] = methodHandler.bind(publicThis);\n\n        if (process.env.NODE_ENV !== 'production') {\n          checkDuplicateProperties(\"Methods\"\n          /* METHODS */\n          , key);\n        }\n      } else if (process.env.NODE_ENV !== 'production') {\n        warn(`Method \"${key}\" has type \"${typeof methodHandler}\" in the component definition. ` + `Did you reference the function correctly?`);\n      }\n    }\n  }\n\n  if (!asMixin) {\n    if (deferredData.length) {\n      deferredData.forEach(dataFn => resolveData(instance, dataFn, publicThis));\n    }\n\n    if (dataOptions) {\n      resolveData(instance, dataOptions, publicThis);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      const rawData = toRaw(instance.data);\n\n      for (const key in rawData) {\n        checkDuplicateProperties(\"Data\"\n        /* DATA */\n        , key); // expose data on ctx during dev\n\n        if (key[0] !== '$' && key[0] !== '_') {\n          Object.defineProperty(ctx, key, {\n            configurable: true,\n            enumerable: true,\n            get: () => rawData[key],\n            set: NOOP\n          });\n        }\n      }\n    }\n  } else if (dataOptions) {\n    deferredData.push(dataOptions);\n  }\n\n  if (computedOptions) {\n    for (const key in computedOptions) {\n      const opt = computedOptions[key];\n      const get = isFunction(opt) ? opt.bind(publicThis, publicThis) : isFunction(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;\n\n      if (process.env.NODE_ENV !== 'production' && get === NOOP) {\n        warn(`Computed property \"${key}\" has no getter.`);\n      }\n\n      const set = !isFunction(opt) && isFunction(opt.set) ? opt.set.bind(publicThis) : process.env.NODE_ENV !== 'production' ? () => {\n        warn(`Write operation failed: computed property \"${key}\" is readonly.`);\n      } : NOOP;\n      const c = computed({\n        get,\n        set\n      });\n      Object.defineProperty(ctx, key, {\n        enumerable: true,\n        configurable: true,\n        get: () => c.value,\n        set: v => c.value = v\n      });\n\n      if (process.env.NODE_ENV !== 'production') {\n        checkDuplicateProperties(\"Computed\"\n        /* COMPUTED */\n        , key);\n      }\n    }\n  }\n\n  if (watchOptions) {\n    deferredWatch.push(watchOptions);\n  }\n\n  if (!asMixin && deferredWatch.length) {\n    deferredWatch.forEach(watchOptions => {\n      for (const key in watchOptions) {\n        createWatcher(watchOptions[key], ctx, publicThis, key);\n      }\n    });\n  }\n\n  if (provideOptions) {\n    deferredProvide.push(provideOptions);\n  }\n\n  if (!asMixin && deferredProvide.length) {\n    deferredProvide.forEach(provideOptions => {\n      const provides = isFunction(provideOptions) ? provideOptions.call(publicThis) : provideOptions;\n\n      for (const key in provides) {\n        provide(key, provides[key]);\n      }\n    });\n  } // asset options.\n  // To reduce memory usage, only components with mixins or extends will have\n  // resolved asset registry attached to instance.\n\n\n  if (asMixin) {\n    if (components) {\n      extend(instance.components || (instance.components = extend({}, instance.type.components)), components);\n    }\n\n    if (directives) {\n      extend(instance.directives || (instance.directives = extend({}, instance.type.directives)), directives);\n    }\n  } // lifecycle options\n\n\n  if (!asMixin) {\n    callSyncHook('created', \"c\"\n    /* CREATED */\n    , options, instance, globalMixins);\n  }\n\n  if (beforeMount) {\n    onBeforeMount(beforeMount.bind(publicThis));\n  }\n\n  if (mounted) {\n    onMounted(mounted.bind(publicThis));\n  }\n\n  if (beforeUpdate) {\n    onBeforeUpdate(beforeUpdate.bind(publicThis));\n  }\n\n  if (updated) {\n    onUpdated(updated.bind(publicThis));\n  }\n\n  if (activated) {\n    onActivated(activated.bind(publicThis));\n  }\n\n  if (deactivated) {\n    onDeactivated(deactivated.bind(publicThis));\n  }\n\n  if (errorCaptured) {\n    onErrorCaptured(errorCaptured.bind(publicThis));\n  }\n\n  if (renderTracked) {\n    onRenderTracked(renderTracked.bind(publicThis));\n  }\n\n  if (renderTriggered) {\n    onRenderTriggered(renderTriggered.bind(publicThis));\n  }\n\n  if (process.env.NODE_ENV !== 'production' && beforeDestroy) {\n    warn(`\\`beforeDestroy\\` has been renamed to \\`beforeUnmount\\`.`);\n  }\n\n  if (beforeUnmount) {\n    onBeforeUnmount(beforeUnmount.bind(publicThis));\n  }\n\n  if (process.env.NODE_ENV !== 'production' && destroyed) {\n    warn(`\\`destroyed\\` has been renamed to \\`unmounted\\`.`);\n  }\n\n  if (unmounted) {\n    onUnmounted(unmounted.bind(publicThis));\n  }\n}\n\nfunction callSyncHook(name, type, options, instance, globalMixins) {\n  callHookFromMixins(name, type, globalMixins, instance);\n  const {\n    extends: base,\n    mixins\n  } = options;\n\n  if (base) {\n    callHookFromExtends(name, type, base, instance);\n  }\n\n  if (mixins) {\n    callHookFromMixins(name, type, mixins, instance);\n  }\n\n  const selfHook = options[name];\n\n  if (selfHook) {\n    callWithAsyncErrorHandling(selfHook.bind(instance.proxy), instance, type);\n  }\n}\n\nfunction callHookFromExtends(name, type, base, instance) {\n  if (base.extends) {\n    callHookFromExtends(name, type, base.extends, instance);\n  }\n\n  const baseHook = base[name];\n\n  if (baseHook) {\n    callWithAsyncErrorHandling(baseHook.bind(instance.proxy), instance, type);\n  }\n}\n\nfunction callHookFromMixins(name, type, mixins, instance) {\n  for (let i = 0; i < mixins.length; i++) {\n    const chainedMixins = mixins[i].mixins;\n\n    if (chainedMixins) {\n      callHookFromMixins(name, type, chainedMixins, instance);\n    }\n\n    const fn = mixins[i][name];\n\n    if (fn) {\n      callWithAsyncErrorHandling(fn.bind(instance.proxy), instance, type);\n    }\n  }\n}\n\nfunction applyMixins(instance, mixins, deferredData, deferredWatch, deferredProvide) {\n  for (let i = 0; i < mixins.length; i++) {\n    applyOptions(instance, mixins[i], deferredData, deferredWatch, deferredProvide, true);\n  }\n}\n\nfunction resolveData(instance, dataFn, publicThis) {\n  if (process.env.NODE_ENV !== 'production' && !isFunction(dataFn)) {\n    warn(`The data option must be a function. ` + `Plain object usage is no longer supported.`);\n  }\n\n  const data = dataFn.call(publicThis, publicThis);\n\n  if (process.env.NODE_ENV !== 'production' && isPromise(data)) {\n    warn(`data() returned a Promise - note data() cannot be async; If you ` + `intend to perform data fetching before component renders, use ` + `async setup() + <Suspense>.`);\n  }\n\n  if (!isObject(data)) {\n    process.env.NODE_ENV !== 'production' && warn(`data() should return an object.`);\n  } else if (instance.data === EMPTY_OBJ) {\n    instance.data = reactive(data);\n  } else {\n    // existing data: this is a mixin or extends.\n    extend(instance.data, data);\n  }\n}\n\nfunction createWatcher(raw, ctx, publicThis, key) {\n  const getter = key.includes('.') ? createPathGetter(publicThis, key) : () => publicThis[key];\n\n  if (isString(raw)) {\n    const handler = ctx[raw];\n\n    if (isFunction(handler)) {\n      watch(getter, handler);\n    } else if (process.env.NODE_ENV !== 'production') {\n      warn(`Invalid watch handler specified by key \"${raw}\"`, handler);\n    }\n  } else if (isFunction(raw)) {\n    watch(getter, raw.bind(publicThis));\n  } else if (isObject(raw)) {\n    if (isArray(raw)) {\n      raw.forEach(r => createWatcher(r, ctx, publicThis, key));\n    } else {\n      const handler = isFunction(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];\n\n      if (isFunction(handler)) {\n        watch(getter, handler, raw);\n      } else if (process.env.NODE_ENV !== 'production') {\n        warn(`Invalid watch handler specified by key \"${raw.handler}\"`, handler);\n      }\n    }\n  } else if (process.env.NODE_ENV !== 'production') {\n    warn(`Invalid watch option: \"${key}\"`, raw);\n  }\n}\n\nfunction createPathGetter(ctx, path) {\n  const segments = path.split('.');\n  return () => {\n    let cur = ctx;\n\n    for (let i = 0; i < segments.length && cur; i++) {\n      cur = cur[segments[i]];\n    }\n\n    return cur;\n  };\n}\n\nfunction resolveMergedOptions(instance) {\n  const raw = instance.type;\n  const {\n    __merged,\n    mixins,\n    extends: extendsOptions\n  } = raw;\n  if (__merged) return __merged;\n  const globalMixins = instance.appContext.mixins;\n  if (!globalMixins.length && !mixins && !extendsOptions) return raw;\n  const options = {};\n  globalMixins.forEach(m => mergeOptions(options, m, instance));\n  mergeOptions(options, raw, instance);\n  return raw.__merged = options;\n}\n\nfunction mergeOptions(to, from, instance) {\n  const strats = instance.appContext.config.optionMergeStrategies;\n  const {\n    mixins,\n    extends: extendsOptions\n  } = from;\n  extendsOptions && mergeOptions(to, extendsOptions, instance);\n  mixins && mixins.forEach(m => mergeOptions(to, m, instance));\n\n  for (const key in from) {\n    if (strats && hasOwn(strats, key)) {\n      to[key] = strats[key](to[key], from[key], instance.proxy, key);\n    } else {\n      to[key] = from[key];\n    }\n  }\n}\n\nconst publicPropertiesMap = extend(Object.create(null), {\n  $: i => i,\n  $el: i => i.vnode.el,\n  $data: i => i.data,\n  $props: i => process.env.NODE_ENV !== 'production' ? shallowReadonly(i.props) : i.props,\n  $attrs: i => process.env.NODE_ENV !== 'production' ? shallowReadonly(i.attrs) : i.attrs,\n  $slots: i => process.env.NODE_ENV !== 'production' ? shallowReadonly(i.slots) : i.slots,\n  $refs: i => process.env.NODE_ENV !== 'production' ? shallowReadonly(i.refs) : i.refs,\n  $parent: i => i.parent && i.parent.proxy,\n  $root: i => i.root && i.root.proxy,\n  $emit: i => i.emit,\n  $options: i => __VUE_OPTIONS_API__ ? resolveMergedOptions(i) : i.type,\n  $forceUpdate: i => () => queueJob(i.update),\n  $nextTick: i => nextTick.bind(i.proxy),\n  $watch: i => __VUE_OPTIONS_API__ ? instanceWatch.bind(i) : NOOP\n});\nconst PublicInstanceProxyHandlers = {\n  get({\n    _: instance\n  }, key) {\n    const {\n      ctx,\n      setupState,\n      data,\n      props,\n      accessCache,\n      type,\n      appContext\n    } = instance; // let @vue/reactivity know it should never observe Vue public instances.\n\n    if (key === \"__v_skip\"\n    /* SKIP */\n    ) {\n        return true;\n      } // for internal formatters to know that this is a Vue instance\n\n\n    if (process.env.NODE_ENV !== 'production' && key === '__isVue') {\n      return true;\n    } // data / props / ctx\n    // This getter gets called for every property access on the render context\n    // during render and is a major hotspot. The most expensive part of this\n    // is the multiple hasOwn() calls. It's much faster to do a simple property\n    // access on a plain object, so we use an accessCache object (with null\n    // prototype) to memoize what access type a key corresponds to.\n\n\n    let normalizedProps;\n\n    if (key[0] !== '$') {\n      const n = accessCache[key];\n\n      if (n !== undefined) {\n        switch (n) {\n          case 0\n          /* SETUP */\n          :\n            return setupState[key];\n\n          case 1\n          /* DATA */\n          :\n            return data[key];\n\n          case 3\n          /* CONTEXT */\n          :\n            return ctx[key];\n\n          case 2\n          /* PROPS */\n          :\n            return props[key];\n          // default: just fallthrough\n        }\n      } else if (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) {\n        accessCache[key] = 0\n        /* SETUP */\n        ;\n        return setupState[key];\n      } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {\n        accessCache[key] = 1\n        /* DATA */\n        ;\n        return data[key];\n      } else if ( // only cache other properties when instance has declared (thus stable)\n      // props\n      (normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)) {\n        accessCache[key] = 2\n        /* PROPS */\n        ;\n        return props[key];\n      } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {\n        accessCache[key] = 3\n        /* CONTEXT */\n        ;\n        return ctx[key];\n      } else if (!__VUE_OPTIONS_API__ || !isInBeforeCreate) {\n        accessCache[key] = 4\n        /* OTHER */\n        ;\n      }\n    }\n\n    const publicGetter = publicPropertiesMap[key];\n    let cssModule, globalProperties; // public $xxx properties\n\n    if (publicGetter) {\n      if (key === '$attrs') {\n        track(instance, \"get\"\n        /* GET */\n        , key);\n        process.env.NODE_ENV !== 'production' && markAttrsAccessed();\n      }\n\n      return publicGetter(instance);\n    } else if ( // css module (injected by vue-loader)\n    (cssModule = type.__cssModules) && (cssModule = cssModule[key])) {\n      return cssModule;\n    } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {\n      // user may set custom properties to `this` that start with `$`\n      accessCache[key] = 3\n      /* CONTEXT */\n      ;\n      return ctx[key];\n    } else if ( // global properties\n    globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)) {\n      return globalProperties[key];\n    } else if (process.env.NODE_ENV !== 'production' && currentRenderingInstance && (!isString(key) || // #1091 avoid internal isRef/isVNode checks on component instance leading\n    // to infinite warning loop\n    key.indexOf('__v') !== 0)) {\n      if (data !== EMPTY_OBJ && (key[0] === '$' || key[0] === '_') && hasOwn(data, key)) {\n        warn(`Property ${JSON.stringify(key)} must be accessed via $data because it starts with a reserved ` + `character (\"$\" or \"_\") and is not proxied on the render context.`);\n      } else {\n        warn(`Property ${JSON.stringify(key)} was accessed during render ` + `but is not defined on instance.`);\n      }\n    }\n  },\n\n  set({\n    _: instance\n  }, key, value) {\n    const {\n      data,\n      setupState,\n      ctx\n    } = instance;\n\n    if (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) {\n      setupState[key] = value;\n    } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {\n      data[key] = value;\n    } else if (key in instance.props) {\n      process.env.NODE_ENV !== 'production' && warn(`Attempting to mutate prop \"${key}\". Props are readonly.`, instance);\n      return false;\n    }\n\n    if (key[0] === '$' && key.slice(1) in instance) {\n      process.env.NODE_ENV !== 'production' && warn(`Attempting to mutate public property \"${key}\". ` + `Properties starting with $ are reserved and readonly.`, instance);\n      return false;\n    } else {\n      if (process.env.NODE_ENV !== 'production' && key in instance.appContext.config.globalProperties) {\n        Object.defineProperty(ctx, key, {\n          enumerable: true,\n          configurable: true,\n          value\n        });\n      } else {\n        ctx[key] = value;\n      }\n    }\n\n    return true;\n  },\n\n  has({\n    _: {\n      data,\n      setupState,\n      accessCache,\n      ctx,\n      appContext,\n      propsOptions\n    }\n  }, key) {\n    let normalizedProps;\n    return accessCache[key] !== undefined || data !== EMPTY_OBJ && hasOwn(data, key) || setupState !== EMPTY_OBJ && hasOwn(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);\n  }\n\n};\n\nif (process.env.NODE_ENV !== 'production' && !false) {\n  PublicInstanceProxyHandlers.ownKeys = target => {\n    warn(`Avoid app logic that relies on enumerating keys on a component instance. ` + `The keys will be empty in production mode to avoid performance overhead.`);\n    return Reflect.ownKeys(target);\n  };\n}\n\nconst RuntimeCompiledPublicInstanceProxyHandlers = extend({}, PublicInstanceProxyHandlers, {\n  get(target, key) {\n    // fast path for unscopables when using `with` block\n    if (key === Symbol.unscopables) {\n      return;\n    }\n\n    return PublicInstanceProxyHandlers.get(target, key, target);\n  },\n\n  has(_, key) {\n    const has = key[0] !== '_' && !isGloballyWhitelisted(key);\n\n    if (process.env.NODE_ENV !== 'production' && !has && PublicInstanceProxyHandlers.has(_, key)) {\n      warn(`Property ${JSON.stringify(key)} should not start with _ which is a reserved prefix for Vue internals.`);\n    }\n\n    return has;\n  }\n\n}); // In dev mode, the proxy target exposes the same properties as seen on `this`\n// for easier console inspection. In prod mode it will be an empty object so\n// these properties definitions can be skipped.\n\nfunction createRenderContext(instance) {\n  const target = {}; // expose internal instance for proxy handlers\n\n  Object.defineProperty(target, `_`, {\n    configurable: true,\n    enumerable: false,\n    get: () => instance\n  }); // expose public properties\n\n  Object.keys(publicPropertiesMap).forEach(key => {\n    Object.defineProperty(target, key, {\n      configurable: true,\n      enumerable: false,\n      get: () => publicPropertiesMap[key](instance),\n      // intercepted by the proxy so no need for implementation,\n      // but needed to prevent set errors\n      set: NOOP\n    });\n  }); // expose global properties\n\n  const {\n    globalProperties\n  } = instance.appContext.config;\n  Object.keys(globalProperties).forEach(key => {\n    Object.defineProperty(target, key, {\n      configurable: true,\n      enumerable: false,\n      get: () => globalProperties[key],\n      set: NOOP\n    });\n  });\n  return target;\n} // dev only\n\n\nfunction exposePropsOnRenderContext(instance) {\n  const {\n    ctx,\n    propsOptions: [propsOptions]\n  } = instance;\n\n  if (propsOptions) {\n    Object.keys(propsOptions).forEach(key => {\n      Object.defineProperty(ctx, key, {\n        enumerable: true,\n        configurable: true,\n        get: () => instance.props[key],\n        set: NOOP\n      });\n    });\n  }\n} // dev only\n\n\nfunction exposeSetupStateOnRenderContext(instance) {\n  const {\n    ctx,\n    setupState\n  } = instance;\n  Object.keys(toRaw(setupState)).forEach(key => {\n    if (key[0] === '$' || key[0] === '_') {\n      warn(`setup() return property ${JSON.stringify(key)} should not start with \"$\" or \"_\" ` + `which are reserved prefixes for Vue internals.`);\n      return;\n    }\n\n    Object.defineProperty(ctx, key, {\n      enumerable: true,\n      configurable: true,\n      get: () => setupState[key],\n      set: NOOP\n    });\n  });\n}\n\nconst emptyAppContext = createAppContext();\nlet uid$1 = 0;\n\nfunction createComponentInstance(vnode, parent, suspense) {\n  const type = vnode.type; // inherit parent app context - or - if root, adopt from root vnode\n\n  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;\n  const instance = {\n    uid: uid$1++,\n    vnode,\n    type,\n    parent,\n    appContext,\n    root: null,\n    next: null,\n    subTree: null,\n    update: null,\n    render: null,\n    proxy: null,\n    withProxy: null,\n    effects: null,\n    provides: parent ? parent.provides : Object.create(appContext.provides),\n    accessCache: null,\n    renderCache: [],\n    // local resovled assets\n    components: null,\n    directives: null,\n    // resolved props and emits options\n    propsOptions: normalizePropsOptions(type, appContext),\n    emitsOptions: normalizeEmitsOptions(type, appContext),\n    // emit\n    emit: null,\n    emitted: null,\n    // state\n    ctx: EMPTY_OBJ,\n    data: EMPTY_OBJ,\n    props: EMPTY_OBJ,\n    attrs: EMPTY_OBJ,\n    slots: EMPTY_OBJ,\n    refs: EMPTY_OBJ,\n    setupState: EMPTY_OBJ,\n    setupContext: null,\n    // suspense related\n    suspense,\n    suspenseId: suspense ? suspense.pendingId : 0,\n    asyncDep: null,\n    asyncResolved: false,\n    // lifecycle hooks\n    // not using enums here because it results in computed properties\n    isMounted: false,\n    isUnmounted: false,\n    isDeactivated: false,\n    bc: null,\n    c: null,\n    bm: null,\n    m: null,\n    bu: null,\n    u: null,\n    um: null,\n    bum: null,\n    da: null,\n    a: null,\n    rtg: null,\n    rtc: null,\n    ec: null\n  };\n\n  if (process.env.NODE_ENV !== 'production') {\n    instance.ctx = createRenderContext(instance);\n  } else {\n    instance.ctx = {\n      _: instance\n    };\n  }\n\n  instance.root = parent ? parent.root : instance;\n  instance.emit = emit.bind(null, instance);\n\n  if (process.env.NODE_ENV !== 'production' || __VUE_PROD_DEVTOOLS__) {\n    devtoolsComponentAdded(instance);\n  }\n\n  return instance;\n}\n\nlet currentInstance = null;\n\nconst getCurrentInstance = () => currentInstance || currentRenderingInstance;\n\nconst setCurrentInstance = instance => {\n  currentInstance = instance;\n};\n\nconst isBuiltInTag = /*#__PURE__*/makeMap('slot,component');\n\nfunction validateComponentName(name, config) {\n  const appIsNativeTag = config.isNativeTag || NO;\n\n  if (isBuiltInTag(name) || appIsNativeTag(name)) {\n    warn('Do not use built-in or reserved HTML elements as component id: ' + name);\n  }\n}\n\nlet isInSSRComponentSetup = false;\n\nfunction setupComponent(instance, isSSR = false) {\n  isInSSRComponentSetup = isSSR;\n  const {\n    props,\n    children,\n    shapeFlag\n  } = instance.vnode;\n  const isStateful = shapeFlag & 4\n  /* STATEFUL_COMPONENT */\n  ;\n  initProps(instance, props, isStateful, isSSR);\n  initSlots(instance, children);\n  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : undefined;\n  isInSSRComponentSetup = false;\n  return setupResult;\n}\n\nfunction setupStatefulComponent(instance, isSSR) {\n  const Component = instance.type;\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (Component.name) {\n      validateComponentName(Component.name, instance.appContext.config);\n    }\n\n    if (Component.components) {\n      const names = Object.keys(Component.components);\n\n      for (let i = 0; i < names.length; i++) {\n        validateComponentName(names[i], instance.appContext.config);\n      }\n    }\n\n    if (Component.directives) {\n      const names = Object.keys(Component.directives);\n\n      for (let i = 0; i < names.length; i++) {\n        validateDirectiveName(names[i]);\n      }\n    }\n  } // 0. create render proxy property access cache\n\n\n  instance.accessCache = {}; // 1. create public instance / render proxy\n  // also mark it raw so it's never observed\n\n  instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);\n\n  if (process.env.NODE_ENV !== 'production') {\n    exposePropsOnRenderContext(instance);\n  } // 2. call setup()\n\n\n  const {\n    setup\n  } = Component;\n\n  if (setup) {\n    const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;\n    currentInstance = instance;\n    pauseTracking();\n    const setupResult = callWithErrorHandling(setup, instance, 0\n    /* SETUP_FUNCTION */\n    , [process.env.NODE_ENV !== 'production' ? shallowReadonly(instance.props) : instance.props, setupContext]);\n    resetTracking();\n    currentInstance = null;\n\n    if (isPromise(setupResult)) {\n      if (isSSR) {\n        // return the promise so server-renderer can wait on it\n        return setupResult.then(resolvedResult => {\n          handleSetupResult(instance, resolvedResult);\n        });\n      } else {\n        // async setup returned Promise.\n        // bail here and wait for re-entry.\n        instance.asyncDep = setupResult;\n      }\n    } else {\n      handleSetupResult(instance, setupResult);\n    }\n  } else {\n    finishComponentSetup(instance);\n  }\n}\n\nfunction handleSetupResult(instance, setupResult, isSSR) {\n  if (isFunction(setupResult)) {\n    // setup returned an inline render function\n    instance.render = setupResult;\n  } else if (isObject(setupResult)) {\n    if (process.env.NODE_ENV !== 'production' && isVNode(setupResult)) {\n      warn(`setup() should not return VNodes directly - ` + `return a render function instead.`);\n    } // setup returned bindings.\n    // assuming a render function compiled from template is present.\n\n\n    if (process.env.NODE_ENV !== 'production' || __VUE_PROD_DEVTOOLS__) {\n      instance.devtoolsRawSetupState = setupResult;\n    }\n\n    instance.setupState = proxyRefs(setupResult);\n\n    if (process.env.NODE_ENV !== 'production') {\n      exposeSetupStateOnRenderContext(instance);\n    }\n  } else if (process.env.NODE_ENV !== 'production' && setupResult !== undefined) {\n    warn(`setup() should return an object. Received: ${setupResult === null ? 'null' : typeof setupResult}`);\n  }\n\n  finishComponentSetup(instance);\n}\n\nlet compile;\n/**\r\n * For runtime-dom to register the compiler.\r\n * Note the exported method uses any to avoid d.ts relying on the compiler types.\r\n */\n\nfunction registerRuntimeCompiler(_compile) {\n  compile = _compile;\n}\n\nfunction finishComponentSetup(instance, isSSR) {\n  const Component = instance.type; // template / render function normalization\n\n  if (!instance.render) {\n    // could be set from setup()\n    if (compile && Component.template && !Component.render) {\n      if (process.env.NODE_ENV !== 'production') {\n        startMeasure(instance, `compile`);\n      }\n\n      Component.render = compile(Component.template, {\n        isCustomElement: instance.appContext.config.isCustomElement,\n        delimiters: Component.delimiters\n      });\n\n      if (process.env.NODE_ENV !== 'production') {\n        endMeasure(instance, `compile`);\n      }\n    }\n\n    instance.render = Component.render || NOOP; // for runtime-compiled render functions using `with` blocks, the render\n    // proxy used needs a different `has` handler which is more performant and\n    // also only allows a whitelist of globals to fallthrough.\n\n    if (instance.render._rc) {\n      instance.withProxy = new Proxy(instance.ctx, RuntimeCompiledPublicInstanceProxyHandlers);\n    }\n  } // support for 2.x options\n\n\n  if (__VUE_OPTIONS_API__) {\n    currentInstance = instance;\n    applyOptions(instance, Component);\n    currentInstance = null;\n  } // warn missing template/render\n\n\n  if (process.env.NODE_ENV !== 'production' && !Component.render && instance.render === NOOP) {\n    /* istanbul ignore if */\n    if (!compile && Component.template) {\n      warn(`Component provided template option but ` + `runtime compilation is not supported in this build of Vue.` + ` Configure your bundler to alias \"vue\" to \"vue/dist/vue.esm-bundler.js\".`\n      /* should not happen */\n      );\n    } else {\n      warn(`Component is missing template or render function.`);\n    }\n  }\n}\n\nconst attrHandlers = {\n  get: (target, key) => {\n    if (process.env.NODE_ENV !== 'production') {\n      markAttrsAccessed();\n    }\n\n    return target[key];\n  },\n  set: () => {\n    warn(`setupContext.attrs is readonly.`);\n    return false;\n  },\n  deleteProperty: () => {\n    warn(`setupContext.attrs is readonly.`);\n    return false;\n  }\n};\n\nfunction createSetupContext(instance) {\n  if (process.env.NODE_ENV !== 'production') {\n    // We use getters in dev in case libs like test-utils overwrite instance\n    // properties (overwrites should not be done in prod)\n    return Object.freeze({\n      get attrs() {\n        return new Proxy(instance.attrs, attrHandlers);\n      },\n\n      get slots() {\n        return shallowReadonly(instance.slots);\n      },\n\n      get emit() {\n        return (event, ...args) => instance.emit(event, ...args);\n      }\n\n    });\n  } else {\n    return {\n      attrs: instance.attrs,\n      slots: instance.slots,\n      emit: instance.emit\n    };\n  }\n} // record effects created during a component's setup() so that they can be\n// stopped when the component unmounts\n\n\nfunction recordInstanceBoundEffect(effect) {\n  if (currentInstance) {\n    (currentInstance.effects || (currentInstance.effects = [])).push(effect);\n  }\n}\n\nconst classifyRE = /(?:^|[-_])(\\w)/g;\n\nconst classify = str => str.replace(classifyRE, c => c.toUpperCase()).replace(/[-_]/g, '');\n/* istanbul ignore next */\n\n\nfunction formatComponentName(instance, Component, isRoot = false) {\n  let name = isFunction(Component) ? Component.displayName || Component.name : Component.name;\n\n  if (!name && Component.__file) {\n    const match = Component.__file.match(/([^/\\\\]+)\\.vue$/);\n\n    if (match) {\n      name = match[1];\n    }\n  }\n\n  if (!name && instance && instance.parent) {\n    // try to infer the name based on reverse resolution\n    const inferFromRegistry = registry => {\n      for (const key in registry) {\n        if (registry[key] === Component) {\n          return key;\n        }\n      }\n    };\n\n    name = inferFromRegistry(instance.components || instance.parent.type.components) || inferFromRegistry(instance.appContext.components);\n  }\n\n  return name ? classify(name) : isRoot ? `App` : `Anonymous`;\n}\n\nfunction isClassComponent(value) {\n  return isFunction(value) && '__vccOpts' in value;\n}\n\nfunction computed(getterOrOptions) {\n  const c = computed$1(getterOrOptions);\n  recordInstanceBoundEffect(c.effect);\n  return c;\n} // implementation, close to no-op\n\n\nfunction defineComponent(options) {\n  return isFunction(options) ? {\n    setup: options,\n    name: options.name\n  } : options;\n}\n\nfunction defineAsyncComponent(source) {\n  if (isFunction(source)) {\n    source = {\n      loader: source\n    };\n  }\n\n  const {\n    loader,\n    loadingComponent: loadingComponent,\n    errorComponent: errorComponent,\n    delay = 200,\n    timeout,\n    // undefined = never times out\n    suspensible = true,\n    onError: userOnError\n  } = source;\n  let pendingRequest = null;\n  let resolvedComp;\n  let retries = 0;\n\n  const retry = () => {\n    retries++;\n    pendingRequest = null;\n    return load();\n  };\n\n  const load = () => {\n    let thisRequest;\n    return pendingRequest || (thisRequest = pendingRequest = loader().catch(err => {\n      err = err instanceof Error ? err : new Error(String(err));\n\n      if (userOnError) {\n        return new Promise((resolve, reject) => {\n          const userRetry = () => resolve(retry());\n\n          const userFail = () => reject(err);\n\n          userOnError(err, userRetry, userFail, retries + 1);\n        });\n      } else {\n        throw err;\n      }\n    }).then(comp => {\n      if (thisRequest !== pendingRequest && pendingRequest) {\n        return pendingRequest;\n      }\n\n      if (process.env.NODE_ENV !== 'production' && !comp) {\n        warn(`Async component loader resolved to undefined. ` + `If you are using retry(), make sure to return its return value.`);\n      } // interop module default\n\n\n      if (comp && (comp.__esModule || comp[Symbol.toStringTag] === 'Module')) {\n        comp = comp.default;\n      }\n\n      if (process.env.NODE_ENV !== 'production' && comp && !isObject(comp) && !isFunction(comp)) {\n        throw new Error(`Invalid async component load result: ${comp}`);\n      }\n\n      resolvedComp = comp;\n      return comp;\n    }));\n  };\n\n  return defineComponent({\n    __asyncLoader: load,\n    name: 'AsyncComponentWrapper',\n\n    setup() {\n      const instance = currentInstance; // already resolved\n\n      if (resolvedComp) {\n        return () => createInnerComp(resolvedComp, instance);\n      }\n\n      const onError = err => {\n        pendingRequest = null;\n        handleError(err, instance, 13\n        /* ASYNC_COMPONENT_LOADER */\n        , !errorComponent\n        /* do not throw in dev if user provided error component */\n        );\n      }; // suspense-controlled or SSR.\n\n\n      if (suspensible && instance.suspense || false) {\n        return load().then(comp => {\n          return () => createInnerComp(comp, instance);\n        }).catch(err => {\n          onError(err);\n          return () => errorComponent ? createVNode(errorComponent, {\n            error: err\n          }) : null;\n        });\n      }\n\n      const loaded = ref(false);\n      const error = ref();\n      const delayed = ref(!!delay);\n\n      if (delay) {\n        setTimeout(() => {\n          delayed.value = false;\n        }, delay);\n      }\n\n      if (timeout != null) {\n        setTimeout(() => {\n          if (!loaded.value && !error.value) {\n            const err = new Error(`Async component timed out after ${timeout}ms.`);\n            onError(err);\n            error.value = err;\n          }\n        }, timeout);\n      }\n\n      load().then(() => {\n        loaded.value = true;\n      }).catch(err => {\n        onError(err);\n        error.value = err;\n      });\n      return () => {\n        if (loaded.value && resolvedComp) {\n          return createInnerComp(resolvedComp, instance);\n        } else if (error.value && errorComponent) {\n          return createVNode(errorComponent, {\n            error: error.value\n          });\n        } else if (loadingComponent && !delayed.value) {\n          return createVNode(loadingComponent);\n        }\n      };\n    }\n\n  });\n}\n\nfunction createInnerComp(comp, {\n  vnode: {\n    props,\n    children\n  }\n}) {\n  return createVNode(comp, props, children);\n} // Actual implementation\n\n\nfunction h(type, propsOrChildren, children) {\n  const l = arguments.length;\n\n  if (l === 2) {\n    if (isObject(propsOrChildren) && !isArray(propsOrChildren)) {\n      // single vnode without props\n      if (isVNode(propsOrChildren)) {\n        return createVNode(type, null, [propsOrChildren]);\n      } // props without children\n\n\n      return createVNode(type, propsOrChildren);\n    } else {\n      // omit props\n      return createVNode(type, null, propsOrChildren);\n    }\n  } else {\n    if (l > 3) {\n      children = Array.prototype.slice.call(arguments, 2);\n    } else if (l === 3 && isVNode(children)) {\n      children = [children];\n    }\n\n    return createVNode(type, propsOrChildren, children);\n  }\n}\n\nconst ssrContextKey = Symbol(process.env.NODE_ENV !== 'production' ? `ssrContext` : ``);\n\nconst useSSRContext = () => {\n  {\n    const ctx = inject(ssrContextKey);\n\n    if (!ctx) {\n      warn(`Server rendering context not provided. Make sure to only call ` + `useSsrContext() conditionally in the server build.`);\n    }\n\n    return ctx;\n  }\n};\n\nfunction initCustomFormatter() {\n  if (!(process.env.NODE_ENV !== 'production') || !true) {\n    return;\n  }\n\n  const vueStyle = {\n    style: 'color:#3ba776'\n  };\n  const numberStyle = {\n    style: 'color:#0b1bc9'\n  };\n  const stringStyle = {\n    style: 'color:#b62e24'\n  };\n  const keywordStyle = {\n    style: 'color:#9d288c'\n  }; // custom formatter for Chrome\n  // https://www.mattzeunert.com/2016/02/19/custom-chrome-devtools-object-formatters.html\n\n  const formatter = {\n    header(obj) {\n      // TODO also format ComponentPublicInstance & ctx.slots/attrs in setup\n      if (!isObject(obj)) {\n        return null;\n      }\n\n      if (obj.__isVue) {\n        return ['div', vueStyle, `VueInstance`];\n      } else if (isRef(obj)) {\n        return ['div', {}, ['span', vueStyle, genRefFlag(obj)], '<', formatValue(obj.value), `>`];\n      } else if (isReactive(obj)) {\n        return ['div', {}, ['span', vueStyle, 'Reactive'], '<', formatValue(obj), `>${isReadonly(obj) ? ` (readonly)` : ``}`];\n      } else if (isReadonly(obj)) {\n        return ['div', {}, ['span', vueStyle, 'Readonly'], '<', formatValue(obj), '>'];\n      }\n\n      return null;\n    },\n\n    hasBody(obj) {\n      return obj && obj.__isVue;\n    },\n\n    body(obj) {\n      if (obj && obj.__isVue) {\n        return ['div', {}, ...formatInstance(obj.$)];\n      }\n    }\n\n  };\n\n  function formatInstance(instance) {\n    const blocks = [];\n\n    if (instance.type.props && instance.props) {\n      blocks.push(createInstanceBlock('props', toRaw(instance.props)));\n    }\n\n    if (instance.setupState !== EMPTY_OBJ) {\n      blocks.push(createInstanceBlock('setup', instance.setupState));\n    }\n\n    if (instance.data !== EMPTY_OBJ) {\n      blocks.push(createInstanceBlock('data', toRaw(instance.data)));\n    }\n\n    const computed = extractKeys(instance, 'computed');\n\n    if (computed) {\n      blocks.push(createInstanceBlock('computed', computed));\n    }\n\n    const injected = extractKeys(instance, 'inject');\n\n    if (injected) {\n      blocks.push(createInstanceBlock('injected', injected));\n    }\n\n    blocks.push(['div', {}, ['span', {\n      style: keywordStyle.style + ';opacity:0.66'\n    }, '$ (internal): '], ['object', {\n      object: instance\n    }]]);\n    return blocks;\n  }\n\n  function createInstanceBlock(type, target) {\n    target = extend({}, target);\n\n    if (!Object.keys(target).length) {\n      return ['span', {}];\n    }\n\n    return ['div', {\n      style: 'line-height:1.25em;margin-bottom:0.6em'\n    }, ['div', {\n      style: 'color:#476582'\n    }, type], ['div', {\n      style: 'padding-left:1.25em'\n    }, ...Object.keys(target).map(key => {\n      return ['div', {}, ['span', keywordStyle, key + ': '], formatValue(target[key], false)];\n    })]];\n  }\n\n  function formatValue(v, asRaw = true) {\n    if (typeof v === 'number') {\n      return ['span', numberStyle, v];\n    } else if (typeof v === 'string') {\n      return ['span', stringStyle, JSON.stringify(v)];\n    } else if (typeof v === 'boolean') {\n      return ['span', keywordStyle, v];\n    } else if (isObject(v)) {\n      return ['object', {\n        object: asRaw ? toRaw(v) : v\n      }];\n    } else {\n      return ['span', stringStyle, String(v)];\n    }\n  }\n\n  function extractKeys(instance, type) {\n    const Comp = instance.type;\n\n    if (isFunction(Comp)) {\n      return;\n    }\n\n    const extracted = {};\n\n    for (const key in instance.ctx) {\n      if (isKeyOfType(Comp, key, type)) {\n        extracted[key] = instance.ctx[key];\n      }\n    }\n\n    return extracted;\n  }\n\n  function isKeyOfType(Comp, key, type) {\n    const opts = Comp[type];\n\n    if (isArray(opts) && opts.includes(key) || isObject(opts) && key in opts) {\n      return true;\n    }\n\n    if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {\n      return true;\n    }\n\n    if (Comp.mixins && Comp.mixins.some(m => isKeyOfType(m, key, type))) {\n      return true;\n    }\n  }\n\n  function genRefFlag(v) {\n    if (v._shallow) {\n      return `ShallowRef`;\n    }\n\n    if (v.effect) {\n      return `ComputedRef`;\n    }\n\n    return `Ref`;\n  }\n  /* eslint-disable no-restricted-globals */\n\n\n  if (window.devtoolsFormatters) {\n    window.devtoolsFormatters.push(formatter);\n  } else {\n    window.devtoolsFormatters = [formatter];\n  }\n}\n/**\r\n * Actual implementation\r\n */\n\n\nfunction renderList(source, renderItem) {\n  let ret;\n\n  if (isArray(source) || isString(source)) {\n    ret = new Array(source.length);\n\n    for (let i = 0, l = source.length; i < l; i++) {\n      ret[i] = renderItem(source[i], i);\n    }\n  } else if (typeof source === 'number') {\n    if (process.env.NODE_ENV !== 'production' && !Number.isInteger(source)) {\n      warn(`The v-for range expect an integer value but got ${source}.`);\n      return [];\n    }\n\n    ret = new Array(source);\n\n    for (let i = 0; i < source; i++) {\n      ret[i] = renderItem(i + 1, i);\n    }\n  } else if (isObject(source)) {\n    if (source[Symbol.iterator]) {\n      ret = Array.from(source, renderItem);\n    } else {\n      const keys = Object.keys(source);\n      ret = new Array(keys.length);\n\n      for (let i = 0, l = keys.length; i < l; i++) {\n        const key = keys[i];\n        ret[i] = renderItem(source[key], key, i);\n      }\n    }\n  } else {\n    ret = [];\n  }\n\n  return ret;\n}\n/**\r\n * For prefixing keys in v-on=\"obj\" with \"on\"\r\n * @private\r\n */\n\n\nfunction toHandlers(obj) {\n  const ret = {};\n\n  if (process.env.NODE_ENV !== 'production' && !isObject(obj)) {\n    warn(`v-on with no argument expects an object value.`);\n    return ret;\n  }\n\n  for (const key in obj) {\n    ret[`on${capitalize(key)}`] = obj[key];\n  }\n\n  return ret;\n}\n/**\r\n * Compiler runtime helper for creating dynamic slots object\r\n * @private\r\n */\n\n\nfunction createSlots(slots, dynamicSlots) {\n  for (let i = 0; i < dynamicSlots.length; i++) {\n    const slot = dynamicSlots[i]; // array of dynamic slot generated by <template v-for=\"...\" #[...]>\n\n    if (isArray(slot)) {\n      for (let j = 0; j < slot.length; j++) {\n        slots[slot[j].name] = slot[j].fn;\n      }\n    } else if (slot) {\n      // conditional single slot generated by <template v-if=\"...\" #foo>\n      slots[slot.name] = slot.fn;\n    }\n  }\n\n  return slots;\n} // Core API ------------------------------------------------------------------\n\n\nconst version = \"3.0.1\";\n/**\r\n * SSR utils for \\@vue/server-renderer. Only exposed in cjs builds.\r\n * @internal\r\n */\n\nconst ssrUtils = null;\nexport { BaseTransition, Comment, Fragment, KeepAlive, Static, Suspense, Teleport, Text, callWithAsyncErrorHandling, callWithErrorHandling, cloneVNode, computed, createBlock, createCommentVNode, createHydrationRenderer, createRenderer, createSlots, createStaticVNode, createTextVNode, createVNode, defineAsyncComponent, defineComponent, devtools, getCurrentInstance, getTransitionRawChildren, h, handleError, initCustomFormatter, inject, isVNode, mergeProps, nextTick, onActivated, onBeforeMount, onBeforeUnmount, onBeforeUpdate, onDeactivated, onErrorCaptured, onMounted, onRenderTracked, onRenderTriggered, onUnmounted, onUpdated, openBlock, popScopeId, provide, pushScopeId, queuePostFlushCb, registerRuntimeCompiler, renderList, renderSlot, resolveComponent, resolveDirective, resolveDynamicComponent, resolveTransitionHooks, setBlockTracking, setDevtoolsHook, setTransitionHooks, ssrContextKey, ssrUtils, toHandlers, transformVNodeArgs, useSSRContext, useTransitionState, version, warn, watch, watchEffect, withCtx, withDirectives, withScopeId };","map":{"version":3,"sources":["C:/Users/ASUS/node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js"],"names":["pauseTracking","resetTracking","isRef","toRaw","shallowReactive","trigger","isReactive","effect","stop","isProxy","reactive","shallowReadonly","track","proxyRefs","computed","computed$1","ref","isReadonly","customRef","markRaw","readonly","shallowRef","toRef","toRefs","triggerRef","unref","isString","isFunction","isPromise","isArray","extend","EMPTY_OBJ","capitalize","hyphenate","camelize","isOn","hasOwn","isModelListener","toNumber","def","isReservedProp","EMPTY_ARR","isObject","toRawType","makeMap","remove","NOOP","hasChanged","isSet","isMap","invokeArrayFns","NO","getGlobalThis","normalizeClass","normalizeStyle","isGloballyWhitelisted","toDisplayString","stack","pushWarningContext","vnode","push","popWarningContext","pop","warn","msg","args","instance","length","component","appWarnHandler","appContext","config","warnHandler","trace","getComponentTrace","callWithErrorHandling","join","proxy","map","formatComponentName","type","warnArgs","formatTrace","console","currentVNode","normalizedStack","last","recurseCount","parentInstance","parent","logs","forEach","entry","i","formatTraceEntry","postfix","isRoot","open","close","props","formatProps","res","keys","Object","slice","key","formatProp","value","raw","JSON","stringify","name","ErrorTypeStrings","fn","err","handleError","callWithAsyncErrorHandling","catch","values","throwInDev","contextVNode","cur","exposedInstance","errorInfo","process","env","NODE_ENV","errorCapturedHooks","ec","appErrorHandler","errorHandler","logError","info","error","isFlushing","isFlushPending","queue","flushIndex","pendingPreFlushCbs","activePreFlushCbs","preFlushIndex","pendingPostFlushCbs","activePostFlushCbs","postFlushIndex","resolvedPromise","Promise","resolve","currentFlushPromise","currentPreFlushParentJob","RECURSION_LIMIT","nextTick","p","then","bind","queueJob","job","includes","allowRecurse","queueFlush","flushJobs","invalidateJob","indexOf","queueCb","cb","activeQueue","pendingQueue","index","queuePreFlushCb","queuePostFlushCb","flushPreFlushCbs","seen","parentJob","Set","Map","checkRecursiveUpdates","flushPostFlushCbs","deduped","sort","a","b","getId","id","Infinity","has","set","count","get","Error","isHmrUpdating","hmrDirtyComponents","globalObject","global","self","window","__VUE_HMR_RUNTIME__","createRecord","tryWrap","rerender","reload","registerHMR","__hmrId","record","add","unregisterHMR","delete","newRender","Array","from","render","renderCache","update","newComp","comp","isClassComponent","__vccOpts","location","arg","e","devtools","setDevtoolsHook","hook","devtoolsInitApp","app","version","emit","Fragment","Text","Comment","Static","devtoolsUnmountApp","devtoolsComponentAdded","createDevtoolsComponentHook","devtoolsComponentUpdated","devtoolsComponentRemoved","uid","undefined","devtoolsComponentEmit","event","params","emitsOptions","propsOptions","validator","isValid","__VUE_PROD_DEVTOOLS__","lowerCaseEvent","toLowerCase","handlerName","handler","startsWith","emitted","normalizeEmitsOptions","asMixin","deopt","__emits","emits","normalized","hasExtends","__VUE_OPTIONS_API__","extendEmits","mixins","extends","isEmitListener","options","replace","currentRenderingInstance","setCurrentRenderingInstance","accessedAttrs","markAttrsAccessed","renderComponentRoot","Component","withProxy","slots","attrs","data","setupState","ctx","result","fallthroughAttrs","shapeFlag","proxyToUse","normalizeVNode","call","getFunctionalFallthrough","root","setRoot","getChildRoot","inheritAttrs","some","filterModelListeners","cloneVNode","allAttrs","eventAttrs","extraAttrs","l","dirs","isElementRoot","concat","transition","createVNode","rawChildren","children","dynamicChildren","childRoot","filterSingleRoot","dynamicIndex","updatedRoot","patchFlag","filtered","filter","child","isVNode","shouldUpdateComponent","prevVNode","nextVNode","optimized","prevProps","prevChildren","nextProps","nextChildren","hasPropsChanged","dynamicProps","$stable","nextKeys","updateHOCHostEl","el","subTree","isSuspense","__isSuspense","SuspenseImpl","n1","n2","container","anchor","parentComponent","parentSuspense","isSVG","rendererInternals","mountSuspense","patchSuspense","hydrate","hydrateSuspense","create","createSuspenseBoundary","Suspense","patch","o","createElement","hiddenContainer","suspense","pendingBranch","ssContent","deps","ssFallback","setActiveBranch","um","unmount","newBranch","newFallback","activeBranch","isInFallback","isHydrating","isSameVNodeType","pendingId","effects","onPending","timeout","setTimeout","fallback","hasWarned","m","move","n","next","parentNode","isUnmounted","resume","delayEnter","mode","afterLeave","hasUnresolvedAncestor","onResolve","fallbackVNode","onFallback","mountFallback","registerDep","setupRenderEffect","hydratedEl","asyncDep","asyncSetupResult","suspenseId","asyncResolved","handleSetupResult","placeholder","doRemove","node","hydrateNode","document","normalizeSuspenseChildren","content","normalizeSuspenseSlot","default","s","singleChild","queueEffectWithSuspense","branch","isRenderingCompiledSlot","setCompiledSlotRendering","renderSlot","slot","rendered","openBlock","createBlock","_","withCtx","renderFnWithContext","owner","closeBlock","_c","currentScopeId","scopeIdStack","pushScopeId","popScopeId","withScopeId","apply","arguments","initProps","rawProps","isStateful","isSSR","InternalObjectKey","setFullProps","validateProps","updateProps","rawPrevProps","rawCurrentProps","propsToUpdate","camelizedKey","resolvePropValue","kebabKey","needCastKeys","camelKey","opt","hasDefault","defaultValue","Function","setCurrentInstance","normalizePropsOptions","__props","extendProps","normalizedKey","validatePropName","prop","booleanIndex","getTypeIndex","Boolean","stringIndex","String","getType","ctor","match","toString","isSameType","expectedTypes","len","rawValues","validateProp","isAbsent","required","types","valid","expectedType","assertType","getInvalidTypeMessage","isSimpleType","t","message","receivedType","expectedValue","styleValue","receivedValue","isExplicable","isBoolean","Number","explicitTypes","elem","injectHook","target","currentInstance","prepend","hooks","wrappedHook","__weh","unshift","apiName","createHook","lifecycle","isInSSRComponentSetup","onBeforeMount","onMounted","onBeforeUpdate","onUpdated","onBeforeUnmount","onUnmounted","onRenderTriggered","onRenderTracked","onErrorCaptured","watchEffect","doWatch","INITIAL_WATCHER_VALUE","watch","source","immediate","deep","flush","onTrack","onTrigger","warnInvalidSource","getter","forceTrigger","_shallow","traverse","cleanup","onInvalidate","baseGetter","runner","onStop","oldValue","active","newValue","scheduler","queuePostRenderEffect","isMounted","lazy","recordInstanceBoundEffect","instanceWatch","publicThis","v","useTransitionState","state","isLeaving","isUnmounting","leavingVNodes","TransitionHookValidator","BaseTransitionImpl","appear","persisted","onBeforeEnter","onEnter","onAfterEnter","onEnterCancelled","onBeforeLeave","onLeave","onAfterLeave","onLeaveCancelled","onBeforeAppear","onAppear","onAfterAppear","onAppearCancelled","setup","getCurrentInstance","prevTransitionKey","getTransitionRawChildren","emptyPlaceholder","innerChild","getKeepAliveChild","enterHooks","resolveTransitionHooks","setTransitionHooks","oldChild","oldInnerChild","transitionKeyChanged","getTransitionKey","leavingHooks","delayLeave","earlyRemove","delayedLeave","leavingVNodesCache","getLeavingNodesForType","_leaveCb","BaseTransition","callHook","beforeEnter","leavingVNode","enter","afterHook","cancelHook","called","done","_enterCb","cancelled","leave","clone","isKeepAlive","keepComment","ret","keyedFragmentCount","__isKeepAlive","KeepAliveImpl","inheritRef","include","RegExp","exclude","max","cache","current","sharedContext","renderer","_unmount","storageContainer","activate","isDeactivated","vnodeHook","onVnodeMounted","invokeVNodeHook","deactivate","da","onVnodeUnmounted","resetShapeFlag","pruneCache","getName","pruneCacheEntry","cached","matches","pendingCacheKey","cacheSubtree","getInnerChild","rawVNode","cachedVNode","size","parseInt","KeepAlive","displayName","pattern","split","test","onActivated","registerKeepAliveHook","onDeactivated","__wdc","injectToKeepAliveRoot","keepAliveRoot","injected","isInternalKey","normalizeSlotValue","normalizeSlot","rawSlot","normalizeObjectSlots","rawSlots","_ctx","normalizeVNodeSlots","initSlots","updateSlots","needDeletionCheck","deletionComparisonTarget","isBuiltInDirective","validateDirectiveName","withDirectives","directives","internalInstance","bindings","dir","modifiers","mounted","updated","invokeDirectiveHook","oldBindings","binding","createAppContext","isNativeTag","performance","globalProperties","optionMergeStrategies","isCustomElement","components","provides","createAppAPI","createApp","rootComponent","rootProps","context","installedPlugins","_uid","_component","_props","_container","_context","use","plugin","install","mixin","validateComponentName","directive","mount","rootContainer","isHydrate","__vue_app__","provide","hasMismatch","isSVGContainer","namespaceURI","tagName","isComment","nodeType","createHydrationFunctions","mt","mountComponent","patchProp","nextSibling","insert","createComment","hasChildNodes","firstChild","isFragmentStart","onMismatch","handleMismatch","domType","nextNode","needToAdoptContent","staticCount","outerHTML","hydrateFragment","hydrateElement","hydrateComponent","loadAsync","__asyncLoader","locateClosingAsyncAnchor","hydrateChildren","setRef","onClick","vnodeHooks","onVnodeBeforeMount","innerHTML","textContent","parentVNode","isFragment","end","supported","perf","startMeasure","isSupported","mark","endMeasure","startTag","endTag","measure","clearMarks","initFeatureFlags","needWarn","prodEffectOptions","createDevEffectOptions","rtc","rtg","rawRef","oldRawRef","r","oldRef","refs","doSet","createRenderer","baseCreateRenderer","createHydrationRenderer","createHydrationFns","hostInsert","hostRemove","hostPatchProp","forcePatchProp","hostForcePatchProp","hostCreateElement","createText","hostCreateText","hostCreateComment","setText","hostSetText","setElementText","hostSetElementText","hostParentNode","hostNextSibling","setScopeId","hostSetScopeId","cloneNode","hostCloneNode","insertStaticContent","hostInsertStaticContent","getNextHostNode","processText","processCommentNode","mountStaticNode","patchStaticNode","processFragment","processElement","processComponent","internals","removeStaticNode","moveStaticNode","mountElement","patchElement","scopeId","is","mountChildren","unmountChildren","defineProperty","enumerable","needCallTransitionHooks","treeOwnerId","__scopeId","start","cloneIfMounted","oldProps","newProps","onVnodeBeforeUpdate","patchProps","class","style","prev","areChildrenSVG","patchBlockChildren","traverseStaticChildren","patchChildren","onVnodeUpdated","oldChildren","newChildren","fallbackContainer","oldVNode","newVNode","fragmentStartAnchor","fragmentEndAnchor","updateComponent","initialVNode","createComponentInstance","setupComponent","updateComponentPreRender","componentEffect","bm","bu","u","originNext","nextTree","prevTree","c1","prevShapeFlag","c2","patchKeyedChildren","patchUnkeyedChildren","oldLength","newLength","commonLength","Math","min","nextChild","parentAnchor","l2","e1","e2","nextPos","s1","s2","keyToNewIndexMap","j","patched","toBePatched","moved","maxNewIndexSoFar","newIndexToOldIndexMap","prevChild","newIndex","increasingNewIndexSequence","getSequence","nextIndex","moveType","needTransition","performLeave","shouldInvokeDirs","onVnodeBeforeUnmount","unmountComponent","isTeleportDisabled","removeFragment","performRemove","bum","_vnode","mc","pc","pbc","shallow","ch1","ch2","arr","c","arrI","isTeleport","__isTeleport","disabled","resolveTarget","select","targetSelector","to","TeleportImpl","querySelector","mainAnchor","targetAnchor","wasDisabled","currentContainer","currentAnchor","moveTeleport","nextTarget","hydrateTeleport","isReorder","targetNode","_lpa","Teleport","COMPONENTS","DIRECTIVES","resolveComponent","resolveAsset","NULL_DYNAMIC_COMPONENT","Symbol","resolveDynamicComponent","resolveDirective","warnMissing","selfName","registry","blockStack","currentBlock","disableTracking","shouldTrack","setBlockTracking","__v_isVNode","vnodeArgsTransformer","transformVNodeArgs","transformer","createVNodeWithArgsTransform","_createVNode","normalizeKey","normalizeRef","isBlockNode","cloned","normalizeChildren","klass","extraProps","mergeRef","mergedProps","mergeProps","createTextVNode","text","flag","createStaticVNode","numberOfNodes","createCommentVNode","asBlock","slotFlag","toMerge","existing","incoming","parentProvides","inject","treatDefaultAsFactory","createDuplicateChecker","isInBeforeCreate","applyOptions","deferredData","deferredWatch","deferredProvide","extendsOptions","dataOptions","computedOptions","methods","watchOptions","provideOptions","injectOptions","beforeMount","beforeUpdate","activated","deactivated","beforeDestroy","beforeUnmount","destroyed","unmounted","renderTracked","renderTriggered","errorCaptured","globalMixins","callSyncHook","applyMixins","checkDuplicateProperties","methodHandler","dataFn","resolveData","rawData","configurable","createWatcher","callHookFromMixins","base","callHookFromExtends","selfHook","baseHook","chainedMixins","createPathGetter","path","segments","resolveMergedOptions","__merged","mergeOptions","strats","publicPropertiesMap","$","$el","$data","$props","$attrs","$slots","$refs","$parent","$root","$emit","$options","$forceUpdate","$nextTick","$watch","PublicInstanceProxyHandlers","accessCache","normalizedProps","publicGetter","cssModule","__cssModules","ownKeys","Reflect","RuntimeCompiledPublicInstanceProxyHandlers","unscopables","createRenderContext","exposePropsOnRenderContext","exposeSetupStateOnRenderContext","emptyAppContext","uid$1","setupContext","bc","isBuiltInTag","appIsNativeTag","setupResult","setupStatefulComponent","names","Proxy","createSetupContext","resolvedResult","finishComponentSetup","devtoolsRawSetupState","compile","registerRuntimeCompiler","_compile","template","delimiters","_rc","attrHandlers","deleteProperty","freeze","classifyRE","classify","str","toUpperCase","__file","inferFromRegistry","getterOrOptions","defineComponent","defineAsyncComponent","loader","loadingComponent","errorComponent","delay","suspensible","onError","userOnError","pendingRequest","resolvedComp","retries","retry","load","thisRequest","reject","userRetry","userFail","__esModule","toStringTag","createInnerComp","loaded","delayed","h","propsOrChildren","prototype","ssrContextKey","useSSRContext","initCustomFormatter","vueStyle","numberStyle","stringStyle","keywordStyle","formatter","header","obj","__isVue","genRefFlag","formatValue","hasBody","body","formatInstance","blocks","createInstanceBlock","extractKeys","object","asRaw","Comp","extracted","isKeyOfType","opts","devtoolsFormatters","renderList","renderItem","isInteger","iterator","toHandlers","createSlots","dynamicSlots","ssrUtils"],"mappings":"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","sourcesContent":["import { pauseTracking, resetTracking, isRef, toRaw, shallowReactive, trigger, isReactive, effect, stop, isProxy, reactive, shallowReadonly, track, proxyRefs, computed as computed$1, ref, isReadonly } from '@vue/reactivity';\nexport { customRef, isProxy, isReactive, isReadonly, isRef, markRaw, proxyRefs, reactive, readonly, ref, shallowReactive, shallowReadonly, shallowRef, toRaw, toRef, toRefs, triggerRef, unref } from '@vue/reactivity';\nimport { isString, isFunction, isPromise, isArray, extend, EMPTY_OBJ, capitalize, hyphenate, camelize, isOn, hasOwn, isModelListener, toNumber, def, isReservedProp, EMPTY_ARR, isObject, toRawType, makeMap, remove, NOOP, hasChanged, isSet, isMap, invokeArrayFns, NO, getGlobalThis, normalizeClass, normalizeStyle, isGloballyWhitelisted } from '@vue/shared';\nexport { camelize, capitalize, toDisplayString } from '@vue/shared';\n\nconst stack = [];\r\nfunction pushWarningContext(vnode) {\r\n    stack.push(vnode);\r\n}\r\nfunction popWarningContext() {\r\n    stack.pop();\r\n}\r\nfunction warn(msg, ...args) {\r\n    // avoid props formatting or warn handler tracking deps that might be mutated\r\n    // during patch, leading to infinite recursion.\r\n    pauseTracking();\r\n    const instance = stack.length ? stack[stack.length - 1].component : null;\r\n    const appWarnHandler = instance && instance.appContext.config.warnHandler;\r\n    const trace = getComponentTrace();\r\n    if (appWarnHandler) {\r\n        callWithErrorHandling(appWarnHandler, instance, 11 /* APP_WARN_HANDLER */, [\r\n            msg + args.join(''),\r\n            instance && instance.proxy,\r\n            trace\r\n                .map(({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`)\r\n                .join('\\n'),\r\n            trace\r\n        ]);\r\n    }\r\n    else {\r\n        const warnArgs = [`[Vue warn]: ${msg}`, ...args];\r\n        /* istanbul ignore if */\r\n        if (trace.length &&\r\n            // avoid spamming console during tests\r\n            !false) {\r\n            warnArgs.push(`\\n`, ...formatTrace(trace));\r\n        }\r\n        console.warn(...warnArgs);\r\n    }\r\n    resetTracking();\r\n}\r\nfunction getComponentTrace() {\r\n    let currentVNode = stack[stack.length - 1];\r\n    if (!currentVNode) {\r\n        return [];\r\n    }\r\n    // we can't just use the stack because it will be incomplete during updates\r\n    // that did not start from the root. Re-construct the parent chain using\r\n    // instance parent pointers.\r\n    const normalizedStack = [];\r\n    while (currentVNode) {\r\n        const last = normalizedStack[0];\r\n        if (last && last.vnode === currentVNode) {\r\n            last.recurseCount++;\r\n        }\r\n        else {\r\n            normalizedStack.push({\r\n                vnode: currentVNode,\r\n                recurseCount: 0\r\n            });\r\n        }\r\n        const parentInstance = currentVNode.component && currentVNode.component.parent;\r\n        currentVNode = parentInstance && parentInstance.vnode;\r\n    }\r\n    return normalizedStack;\r\n}\r\n/* istanbul ignore next */\r\nfunction formatTrace(trace) {\r\n    const logs = [];\r\n    trace.forEach((entry, i) => {\r\n        logs.push(...(i === 0 ? [] : [`\\n`]), ...formatTraceEntry(entry));\r\n    });\r\n    return logs;\r\n}\r\nfunction formatTraceEntry({ vnode, recurseCount }) {\r\n    const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;\r\n    const isRoot = vnode.component ? vnode.component.parent == null : false;\r\n    const open = ` at <${formatComponentName(vnode.component, vnode.type, isRoot)}`;\r\n    const close = `>` + postfix;\r\n    return vnode.props\r\n        ? [open, ...formatProps(vnode.props), close]\r\n        : [open + close];\r\n}\r\n/* istanbul ignore next */\r\nfunction formatProps(props) {\r\n    const res = [];\r\n    const keys = Object.keys(props);\r\n    keys.slice(0, 3).forEach(key => {\r\n        res.push(...formatProp(key, props[key]));\r\n    });\r\n    if (keys.length > 3) {\r\n        res.push(` ...`);\r\n    }\r\n    return res;\r\n}\r\n/* istanbul ignore next */\r\nfunction formatProp(key, value, raw) {\r\n    if (isString(value)) {\r\n        value = JSON.stringify(value);\r\n        return raw ? value : [`${key}=${value}`];\r\n    }\r\n    else if (typeof value === 'number' ||\r\n        typeof value === 'boolean' ||\r\n        value == null) {\r\n        return raw ? value : [`${key}=${value}`];\r\n    }\r\n    else if (isRef(value)) {\r\n        value = formatProp(key, toRaw(value.value), true);\r\n        return raw ? value : [`${key}=Ref<`, value, `>`];\r\n    }\r\n    else if (isFunction(value)) {\r\n        return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];\r\n    }\r\n    else {\r\n        value = toRaw(value);\r\n        return raw ? value : [`${key}=`, value];\r\n    }\r\n}\n\nconst ErrorTypeStrings = {\r\n    [\"bc\" /* BEFORE_CREATE */]: 'beforeCreate hook',\r\n    [\"c\" /* CREATED */]: 'created hook',\r\n    [\"bm\" /* BEFORE_MOUNT */]: 'beforeMount hook',\r\n    [\"m\" /* MOUNTED */]: 'mounted hook',\r\n    [\"bu\" /* BEFORE_UPDATE */]: 'beforeUpdate hook',\r\n    [\"u\" /* UPDATED */]: 'updated',\r\n    [\"bum\" /* BEFORE_UNMOUNT */]: 'beforeUnmount hook',\r\n    [\"um\" /* UNMOUNTED */]: 'unmounted hook',\r\n    [\"a\" /* ACTIVATED */]: 'activated hook',\r\n    [\"da\" /* DEACTIVATED */]: 'deactivated hook',\r\n    [\"ec\" /* ERROR_CAPTURED */]: 'errorCaptured hook',\r\n    [\"rtc\" /* RENDER_TRACKED */]: 'renderTracked hook',\r\n    [\"rtg\" /* RENDER_TRIGGERED */]: 'renderTriggered hook',\r\n    [0 /* SETUP_FUNCTION */]: 'setup function',\r\n    [1 /* RENDER_FUNCTION */]: 'render function',\r\n    [2 /* WATCH_GETTER */]: 'watcher getter',\r\n    [3 /* WATCH_CALLBACK */]: 'watcher callback',\r\n    [4 /* WATCH_CLEANUP */]: 'watcher cleanup function',\r\n    [5 /* NATIVE_EVENT_HANDLER */]: 'native event handler',\r\n    [6 /* COMPONENT_EVENT_HANDLER */]: 'component event handler',\r\n    [7 /* VNODE_HOOK */]: 'vnode hook',\r\n    [8 /* DIRECTIVE_HOOK */]: 'directive hook',\r\n    [9 /* TRANSITION_HOOK */]: 'transition hook',\r\n    [10 /* APP_ERROR_HANDLER */]: 'app errorHandler',\r\n    [11 /* APP_WARN_HANDLER */]: 'app warnHandler',\r\n    [12 /* FUNCTION_REF */]: 'ref function',\r\n    [13 /* ASYNC_COMPONENT_LOADER */]: 'async component loader',\r\n    [14 /* SCHEDULER */]: 'scheduler flush. This is likely a Vue internals bug. ' +\r\n        'Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/vue-next'\r\n};\r\nfunction callWithErrorHandling(fn, instance, type, args) {\r\n    let res;\r\n    try {\r\n        res = args ? fn(...args) : fn();\r\n    }\r\n    catch (err) {\r\n        handleError(err, instance, type);\r\n    }\r\n    return res;\r\n}\r\nfunction callWithAsyncErrorHandling(fn, instance, type, args) {\r\n    if (isFunction(fn)) {\r\n        const res = callWithErrorHandling(fn, instance, type, args);\r\n        if (res && isPromise(res)) {\r\n            res.catch(err => {\r\n                handleError(err, instance, type);\r\n            });\r\n        }\r\n        return res;\r\n    }\r\n    const values = [];\r\n    for (let i = 0; i < fn.length; i++) {\r\n        values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));\r\n    }\r\n    return values;\r\n}\r\nfunction handleError(err, instance, type, throwInDev = true) {\r\n    const contextVNode = instance ? instance.vnode : null;\r\n    if (instance) {\r\n        let cur = instance.parent;\r\n        // the exposed instance is the render proxy to keep it consistent with 2.x\r\n        const exposedInstance = instance.proxy;\r\n        // in production the hook receives only the error code\r\n        const errorInfo = (process.env.NODE_ENV !== 'production') ? ErrorTypeStrings[type] : type;\r\n        while (cur) {\r\n            const errorCapturedHooks = cur.ec;\r\n            if (errorCapturedHooks) {\r\n                for (let i = 0; i < errorCapturedHooks.length; i++) {\r\n                    if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n            cur = cur.parent;\r\n        }\r\n        // app-level handling\r\n        const appErrorHandler = instance.appContext.config.errorHandler;\r\n        if (appErrorHandler) {\r\n            callWithErrorHandling(appErrorHandler, null, 10 /* APP_ERROR_HANDLER */, [err, exposedInstance, errorInfo]);\r\n            return;\r\n        }\r\n    }\r\n    logError(err, type, contextVNode, throwInDev);\r\n}\r\nfunction logError(err, type, contextVNode, throwInDev = true) {\r\n    if ((process.env.NODE_ENV !== 'production')) {\r\n        const info = ErrorTypeStrings[type];\r\n        if (contextVNode) {\r\n            pushWarningContext(contextVNode);\r\n        }\r\n        warn(`Unhandled error${info ? ` during execution of ${info}` : ``}`);\r\n        if (contextVNode) {\r\n            popWarningContext();\r\n        }\r\n        // crash in dev by default so it's more noticeable\r\n        if (throwInDev) {\r\n            throw err;\r\n        }\r\n        else {\r\n            console.error(err);\r\n        }\r\n    }\r\n    else {\r\n        // recover in prod to reduce the impact on end-user\r\n        console.error(err);\r\n    }\r\n}\n\nlet isFlushing = false;\r\nlet isFlushPending = false;\r\nconst queue = [];\r\nlet flushIndex = 0;\r\nconst pendingPreFlushCbs = [];\r\nlet activePreFlushCbs = null;\r\nlet preFlushIndex = 0;\r\nconst pendingPostFlushCbs = [];\r\nlet activePostFlushCbs = null;\r\nlet postFlushIndex = 0;\r\nconst resolvedPromise = Promise.resolve();\r\nlet currentFlushPromise = null;\r\nlet currentPreFlushParentJob = null;\r\nconst RECURSION_LIMIT = 100;\r\nfunction nextTick(fn) {\r\n    const p = currentFlushPromise || resolvedPromise;\r\n    return fn ? p.then(this ? fn.bind(this) : fn) : p;\r\n}\r\nfunction queueJob(job) {\r\n    // the dedupe search uses the startIndex argument of Array.includes()\r\n    // by default the search index includes the current job that is being run\r\n    // so it cannot recursively trigger itself again.\r\n    // if the job is a watch() callback, the search will start with a +1 index to\r\n    // allow it recursively trigger itself - it is the user's responsibility to\r\n    // ensure it doesn't end up in an infinite loop.\r\n    if ((!queue.length ||\r\n        !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) &&\r\n        job !== currentPreFlushParentJob) {\r\n        queue.push(job);\r\n        queueFlush();\r\n    }\r\n}\r\nfunction queueFlush() {\r\n    if (!isFlushing && !isFlushPending) {\r\n        isFlushPending = true;\r\n        currentFlushPromise = resolvedPromise.then(flushJobs);\r\n    }\r\n}\r\nfunction invalidateJob(job) {\r\n    const i = queue.indexOf(job);\r\n    if (i > -1) {\r\n        queue[i] = null;\r\n    }\r\n}\r\nfunction queueCb(cb, activeQueue, pendingQueue, index) {\r\n    if (!isArray(cb)) {\r\n        if (!activeQueue ||\r\n            !activeQueue.includes(cb, cb.allowRecurse ? index + 1 : index)) {\r\n            pendingQueue.push(cb);\r\n        }\r\n    }\r\n    else {\r\n        // if cb is an array, it is a component lifecycle hook which can only be\r\n        // triggered by a job, which is already deduped in the main queue, so\r\n        // we can skip duplicate check here to improve perf\r\n        pendingQueue.push(...cb);\r\n    }\r\n    queueFlush();\r\n}\r\nfunction queuePreFlushCb(cb) {\r\n    queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex);\r\n}\r\nfunction queuePostFlushCb(cb) {\r\n    queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex);\r\n}\r\nfunction flushPreFlushCbs(seen, parentJob = null) {\r\n    if (pendingPreFlushCbs.length) {\r\n        currentPreFlushParentJob = parentJob;\r\n        activePreFlushCbs = [...new Set(pendingPreFlushCbs)];\r\n        pendingPreFlushCbs.length = 0;\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            seen = seen || new Map();\r\n        }\r\n        for (preFlushIndex = 0; preFlushIndex < activePreFlushCbs.length; preFlushIndex++) {\r\n            if ((process.env.NODE_ENV !== 'production')) {\r\n                checkRecursiveUpdates(seen, activePreFlushCbs[preFlushIndex]);\r\n            }\r\n            activePreFlushCbs[preFlushIndex]();\r\n        }\r\n        activePreFlushCbs = null;\r\n        preFlushIndex = 0;\r\n        currentPreFlushParentJob = null;\r\n        // recursively flush until it drains\r\n        flushPreFlushCbs(seen, parentJob);\r\n    }\r\n}\r\nfunction flushPostFlushCbs(seen) {\r\n    if (pendingPostFlushCbs.length) {\r\n        const deduped = [...new Set(pendingPostFlushCbs)];\r\n        pendingPostFlushCbs.length = 0;\r\n        // #1947 already has active queue, nested flushPostFlushCbs call\r\n        if (activePostFlushCbs) {\r\n            activePostFlushCbs.push(...deduped);\r\n            return;\r\n        }\r\n        activePostFlushCbs = deduped;\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            seen = seen || new Map();\r\n        }\r\n        activePostFlushCbs.sort((a, b) => getId(a) - getId(b));\r\n        for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {\r\n            if ((process.env.NODE_ENV !== 'production')) {\r\n                checkRecursiveUpdates(seen, activePostFlushCbs[postFlushIndex]);\r\n            }\r\n            activePostFlushCbs[postFlushIndex]();\r\n        }\r\n        activePostFlushCbs = null;\r\n        postFlushIndex = 0;\r\n    }\r\n}\r\nconst getId = (job) => job.id == null ? Infinity : job.id;\r\nfunction flushJobs(seen) {\r\n    isFlushPending = false;\r\n    isFlushing = true;\r\n    if ((process.env.NODE_ENV !== 'production')) {\r\n        seen = seen || new Map();\r\n    }\r\n    flushPreFlushCbs(seen);\r\n    // Sort queue before flush.\r\n    // This ensures that:\r\n    // 1. Components are updated from parent to child. (because parent is always\r\n    //    created before the child so its render effect will have smaller\r\n    //    priority number)\r\n    // 2. If a component is unmounted during a parent component's update,\r\n    //    its update can be skipped.\r\n    // Jobs can never be null before flush starts, since they are only invalidated\r\n    // during execution of another flushed job.\r\n    queue.sort((a, b) => getId(a) - getId(b));\r\n    try {\r\n        for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {\r\n            const job = queue[flushIndex];\r\n            if (job) {\r\n                if ((process.env.NODE_ENV !== 'production')) {\r\n                    checkRecursiveUpdates(seen, job);\r\n                }\r\n                callWithErrorHandling(job, null, 14 /* SCHEDULER */);\r\n            }\r\n        }\r\n    }\r\n    finally {\r\n        flushIndex = 0;\r\n        queue.length = 0;\r\n        flushPostFlushCbs(seen);\r\n        isFlushing = false;\r\n        currentFlushPromise = null;\r\n        // some postFlushCb queued jobs!\r\n        // keep flushing until it drains.\r\n        if (queue.length || pendingPostFlushCbs.length) {\r\n            flushJobs(seen);\r\n        }\r\n    }\r\n}\r\nfunction checkRecursiveUpdates(seen, fn) {\r\n    if (!seen.has(fn)) {\r\n        seen.set(fn, 1);\r\n    }\r\n    else {\r\n        const count = seen.get(fn);\r\n        if (count > RECURSION_LIMIT) {\r\n            throw new Error(`Maximum recursive updates exceeded. ` +\r\n                `This means you have a reactive effect that is mutating its own ` +\r\n                `dependencies and thus recursively triggering itself. Possible sources ` +\r\n                `include component template, render function, updated hook or ` +\r\n                `watcher source function.`);\r\n        }\r\n        else {\r\n            seen.set(fn, count + 1);\r\n        }\r\n    }\r\n}\n\n/* eslint-disable no-restricted-globals */\r\nlet isHmrUpdating = false;\r\nconst hmrDirtyComponents = new Set();\r\n// Expose the HMR runtime on the global object\r\n// This makes it entirely tree-shakable without polluting the exports and makes\r\n// it easier to be used in toolings like vue-loader\r\n// Note: for a component to be eligible for HMR it also needs the __hmrId option\r\n// to be set so that its instances can be registered / removed.\r\nif ((process.env.NODE_ENV !== 'production') && (true )) {\r\n    const globalObject = typeof global !== 'undefined'\r\n        ? global\r\n        : typeof self !== 'undefined'\r\n            ? self\r\n            : typeof window !== 'undefined'\r\n                ? window\r\n                : {};\r\n    globalObject.__VUE_HMR_RUNTIME__ = {\r\n        createRecord: tryWrap(createRecord),\r\n        rerender: tryWrap(rerender),\r\n        reload: tryWrap(reload)\r\n    };\r\n}\r\nconst map = new Map();\r\nfunction registerHMR(instance) {\r\n    const id = instance.type.__hmrId;\r\n    let record = map.get(id);\r\n    if (!record) {\r\n        createRecord(id);\r\n        record = map.get(id);\r\n    }\r\n    record.add(instance);\r\n}\r\nfunction unregisterHMR(instance) {\r\n    map.get(instance.type.__hmrId).delete(instance);\r\n}\r\nfunction createRecord(id) {\r\n    if (map.has(id)) {\r\n        return false;\r\n    }\r\n    map.set(id, new Set());\r\n    return true;\r\n}\r\nfunction rerender(id, newRender) {\r\n    const record = map.get(id);\r\n    if (!record)\r\n        return;\r\n    // Array.from creates a snapshot which avoids the set being mutated during\r\n    // updates\r\n    Array.from(record).forEach(instance => {\r\n        if (newRender) {\r\n            instance.render = newRender;\r\n        }\r\n        instance.renderCache = [];\r\n        // this flag forces child components with slot content to update\r\n        isHmrUpdating = true;\r\n        instance.update();\r\n        isHmrUpdating = false;\r\n    });\r\n}\r\nfunction reload(id, newComp) {\r\n    const record = map.get(id);\r\n    if (!record)\r\n        return;\r\n    // Array.from creates a snapshot which avoids the set being mutated during\r\n    // updates\r\n    Array.from(record).forEach(instance => {\r\n        const comp = instance.type;\r\n        if (!hmrDirtyComponents.has(comp)) {\r\n            // 1. Update existing comp definition to match new one\r\n            newComp = isClassComponent(newComp) ? newComp.__vccOpts : newComp;\r\n            extend(comp, newComp);\r\n            for (const key in comp) {\r\n                if (!(key in newComp)) {\r\n                    delete comp[key];\r\n                }\r\n            }\r\n            // 2. Mark component dirty. This forces the renderer to replace the component\r\n            // on patch.\r\n            hmrDirtyComponents.add(comp);\r\n            // 3. Make sure to unmark the component after the reload.\r\n            queuePostFlushCb(() => {\r\n                hmrDirtyComponents.delete(comp);\r\n            });\r\n        }\r\n        if (instance.parent) {\r\n            // 4. Force the parent instance to re-render. This will cause all updated\r\n            // components to be unmounted and re-mounted. Queue the update so that we\r\n            // don't end up forcing the same parent to re-render multiple times.\r\n            queueJob(instance.parent.update);\r\n        }\r\n        else if (instance.appContext.reload) {\r\n            // root instance mounted via createApp() has a reload method\r\n            instance.appContext.reload();\r\n        }\r\n        else if (typeof window !== 'undefined') {\r\n            // root instance inside tree created via raw render(). Force reload.\r\n            window.location.reload();\r\n        }\r\n        else {\r\n            console.warn('[HMR] Root or manually mounted instance modified. Full reload required.');\r\n        }\r\n    });\r\n}\r\nfunction tryWrap(fn) {\r\n    return (id, arg) => {\r\n        try {\r\n            return fn(id, arg);\r\n        }\r\n        catch (e) {\r\n            console.error(e);\r\n            console.warn(`[HMR] Something went wrong during Vue component hot-reload. ` +\r\n                `Full reload required.`);\r\n        }\r\n    };\r\n}\n\nlet devtools;\r\nfunction setDevtoolsHook(hook) {\r\n    devtools = hook;\r\n}\r\nfunction devtoolsInitApp(app, version) {\r\n    // TODO queue if devtools is undefined\r\n    if (!devtools)\r\n        return;\r\n    devtools.emit(\"app:init\" /* APP_INIT */, app, version, {\r\n        Fragment,\r\n        Text,\r\n        Comment,\r\n        Static\r\n    });\r\n}\r\nfunction devtoolsUnmountApp(app) {\r\n    if (!devtools)\r\n        return;\r\n    devtools.emit(\"app:unmount\" /* APP_UNMOUNT */, app);\r\n}\r\nconst devtoolsComponentAdded = /*#__PURE__*/ createDevtoolsComponentHook(\"component:added\" /* COMPONENT_ADDED */);\r\nconst devtoolsComponentUpdated = /*#__PURE__*/ createDevtoolsComponentHook(\"component:updated\" /* COMPONENT_UPDATED */);\r\nconst devtoolsComponentRemoved = /*#__PURE__*/ createDevtoolsComponentHook(\"component:removed\" /* COMPONENT_REMOVED */);\r\nfunction createDevtoolsComponentHook(hook) {\r\n    return (component) => {\r\n        if (!devtools)\r\n            return;\r\n        devtools.emit(hook, component.appContext.app, component.uid, component.parent ? component.parent.uid : undefined);\r\n    };\r\n}\r\nfunction devtoolsComponentEmit(component, event, params) {\r\n    if (!devtools)\r\n        return;\r\n    devtools.emit(\"component:emit\" /* COMPONENT_EMIT */, component.appContext.app, component, event, params);\r\n}\n\nfunction emit(instance, event, ...args) {\r\n    const props = instance.vnode.props || EMPTY_OBJ;\r\n    if ((process.env.NODE_ENV !== 'production')) {\r\n        const { emitsOptions, propsOptions: [propsOptions] } = instance;\r\n        if (emitsOptions) {\r\n            if (!(event in emitsOptions)) {\r\n                if (!propsOptions || !(`on` + capitalize(event) in propsOptions)) {\r\n                    warn(`Component emitted event \"${event}\" but it is neither declared in ` +\r\n                        `the emits option nor as an \"on${capitalize(event)}\" prop.`);\r\n                }\r\n            }\r\n            else {\r\n                const validator = emitsOptions[event];\r\n                if (isFunction(validator)) {\r\n                    const isValid = validator(...args);\r\n                    if (!isValid) {\r\n                        warn(`Invalid event arguments: event validation failed for event \"${event}\".`);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if ((process.env.NODE_ENV !== 'production') || __VUE_PROD_DEVTOOLS__) {\r\n        devtoolsComponentEmit(instance, event, args);\r\n    }\r\n    if ((process.env.NODE_ENV !== 'production')) {\r\n        const lowerCaseEvent = event.toLowerCase();\r\n        if (lowerCaseEvent !== event && props[`on` + capitalize(lowerCaseEvent)]) {\r\n            warn(`Event \"${lowerCaseEvent}\" is emitted in component ` +\r\n                `${formatComponentName(instance, instance.type)} but the handler is registered for \"${event}\". ` +\r\n                `Note that HTML attributes are case-insensitive and you cannot use ` +\r\n                `v-on to listen to camelCase events when using in-DOM templates. ` +\r\n                `You should probably use \"${hyphenate(event)}\" instead of \"${event}\".`);\r\n        }\r\n    }\r\n    // convert handler name to camelCase. See issue #2249\r\n    let handlerName = `on${capitalize(camelize(event))}`;\r\n    let handler = props[handlerName];\r\n    // for v-model update:xxx events, also trigger kebab-case equivalent\r\n    // for props passed via kebab-case\r\n    if (!handler && event.startsWith('update:')) {\r\n        handlerName = `on${capitalize(hyphenate(event))}`;\r\n        handler = props[handlerName];\r\n    }\r\n    if (!handler) {\r\n        handler = props[handlerName + `Once`];\r\n        if (!instance.emitted) {\r\n            (instance.emitted = {})[handlerName] = true;\r\n        }\r\n        else if (instance.emitted[handlerName]) {\r\n            return;\r\n        }\r\n    }\r\n    if (handler) {\r\n        callWithAsyncErrorHandling(handler, instance, 6 /* COMPONENT_EVENT_HANDLER */, args);\r\n    }\r\n}\r\nfunction normalizeEmitsOptions(comp, appContext, asMixin = false) {\r\n    if (!appContext.deopt && comp.__emits !== undefined) {\r\n        return comp.__emits;\r\n    }\r\n    const raw = comp.emits;\r\n    let normalized = {};\r\n    // apply mixin/extends props\r\n    let hasExtends = false;\r\n    if (__VUE_OPTIONS_API__ && !isFunction(comp)) {\r\n        const extendEmits = (raw) => {\r\n            hasExtends = true;\r\n            extend(normalized, normalizeEmitsOptions(raw, appContext, true));\r\n        };\r\n        if (!asMixin && appContext.mixins.length) {\r\n            appContext.mixins.forEach(extendEmits);\r\n        }\r\n        if (comp.extends) {\r\n            extendEmits(comp.extends);\r\n        }\r\n        if (comp.mixins) {\r\n            comp.mixins.forEach(extendEmits);\r\n        }\r\n    }\r\n    if (!raw && !hasExtends) {\r\n        return (comp.__emits = null);\r\n    }\r\n    if (isArray(raw)) {\r\n        raw.forEach(key => (normalized[key] = null));\r\n    }\r\n    else {\r\n        extend(normalized, raw);\r\n    }\r\n    return (comp.__emits = normalized);\r\n}\r\n// Check if an incoming prop key is a declared emit event listener.\r\n// e.g. With `emits: { click: null }`, props named `onClick` and `onclick` are\r\n// both considered matched listeners.\r\nfunction isEmitListener(options, key) {\r\n    if (!options || !isOn(key)) {\r\n        return false;\r\n    }\r\n    key = key.replace(/Once$/, '');\r\n    return (hasOwn(options, key[2].toLowerCase() + key.slice(3)) ||\r\n        hasOwn(options, key.slice(2)));\r\n}\n\n// mark the current rendering instance for asset resolution (e.g.\r\n// resolveComponent, resolveDirective) during render\r\nlet currentRenderingInstance = null;\r\nfunction setCurrentRenderingInstance(instance) {\r\n    currentRenderingInstance = instance;\r\n}\r\n// dev only flag to track whether $attrs was used during render.\r\n// If $attrs was used during render then the warning for failed attrs\r\n// fallthrough can be suppressed.\r\nlet accessedAttrs = false;\r\nfunction markAttrsAccessed() {\r\n    accessedAttrs = true;\r\n}\r\nfunction renderComponentRoot(instance) {\r\n    const { type: Component, vnode, proxy, withProxy, props, propsOptions: [propsOptions], slots, attrs, emit, render, renderCache, data, setupState, ctx } = instance;\r\n    let result;\r\n    currentRenderingInstance = instance;\r\n    if ((process.env.NODE_ENV !== 'production')) {\r\n        accessedAttrs = false;\r\n    }\r\n    try {\r\n        let fallthroughAttrs;\r\n        if (vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */) {\r\n            // withProxy is a proxy with a different `has` trap only for\r\n            // runtime-compiled render functions using `with` block.\r\n            const proxyToUse = withProxy || proxy;\r\n            result = normalizeVNode(render.call(proxyToUse, proxyToUse, renderCache, props, setupState, data, ctx));\r\n            fallthroughAttrs = attrs;\r\n        }\r\n        else {\r\n            // functional\r\n            const render = Component;\r\n            // in dev, mark attrs accessed if optional props (attrs === props)\r\n            if ((process.env.NODE_ENV !== 'production') && attrs === props) {\r\n                markAttrsAccessed();\r\n            }\r\n            result = normalizeVNode(render.length > 1\r\n                ? render(props, (process.env.NODE_ENV !== 'production')\r\n                    ? {\r\n                        get attrs() {\r\n                            markAttrsAccessed();\r\n                            return attrs;\r\n                        },\r\n                        slots,\r\n                        emit\r\n                    }\r\n                    : { attrs, slots, emit })\r\n                : render(props, null /* we know it doesn't need it */));\r\n            fallthroughAttrs = Component.props\r\n                ? attrs\r\n                : getFunctionalFallthrough(attrs);\r\n        }\r\n        // attr merging\r\n        // in dev mode, comments are preserved, and it's possible for a template\r\n        // to have comments along side the root element which makes it a fragment\r\n        let root = result;\r\n        let setRoot = undefined;\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            ;\r\n            [root, setRoot] = getChildRoot(result);\r\n        }\r\n        if (Component.inheritAttrs !== false && fallthroughAttrs) {\r\n            const keys = Object.keys(fallthroughAttrs);\r\n            const { shapeFlag } = root;\r\n            if (keys.length) {\r\n                if (shapeFlag & 1 /* ELEMENT */ ||\r\n                    shapeFlag & 6 /* COMPONENT */) {\r\n                    if (propsOptions && keys.some(isModelListener)) {\r\n                        // If a v-model listener (onUpdate:xxx) has a corresponding declared\r\n                        // prop, it indicates this component expects to handle v-model and\r\n                        // it should not fallthrough.\r\n                        // related: #1543, #1643, #1989\r\n                        fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);\r\n                    }\r\n                    root = cloneVNode(root, fallthroughAttrs);\r\n                }\r\n                else if ((process.env.NODE_ENV !== 'production') && !accessedAttrs && root.type !== Comment) {\r\n                    const allAttrs = Object.keys(attrs);\r\n                    const eventAttrs = [];\r\n                    const extraAttrs = [];\r\n                    for (let i = 0, l = allAttrs.length; i < l; i++) {\r\n                        const key = allAttrs[i];\r\n                        if (isOn(key)) {\r\n                            // ignore v-model handlers when they fail to fallthrough\r\n                            if (!isModelListener(key)) {\r\n                                // remove `on`, lowercase first letter to reflect event casing\r\n                                // accurately\r\n                                eventAttrs.push(key[2].toLowerCase() + key.slice(3));\r\n                            }\r\n                        }\r\n                        else {\r\n                            extraAttrs.push(key);\r\n                        }\r\n                    }\r\n                    if (extraAttrs.length) {\r\n                        warn(`Extraneous non-props attributes (` +\r\n                            `${extraAttrs.join(', ')}) ` +\r\n                            `were passed to component but could not be automatically inherited ` +\r\n                            `because component renders fragment or text root nodes.`);\r\n                    }\r\n                    if (eventAttrs.length) {\r\n                        warn(`Extraneous non-emits event listeners (` +\r\n                            `${eventAttrs.join(', ')}) ` +\r\n                            `were passed to component but could not be automatically inherited ` +\r\n                            `because component renders fragment or text root nodes. ` +\r\n                            `If the listener is intended to be a component custom event listener only, ` +\r\n                            `declare it using the \"emits\" option.`);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // inherit directives\r\n        if (vnode.dirs) {\r\n            if ((process.env.NODE_ENV !== 'production') && !isElementRoot(root)) {\r\n                warn(`Runtime directive used on component with non-element root node. ` +\r\n                    `The directives will not function as intended.`);\r\n            }\r\n            root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;\r\n        }\r\n        // inherit transition data\r\n        if (vnode.transition) {\r\n            if ((process.env.NODE_ENV !== 'production') && !isElementRoot(root)) {\r\n                warn(`Component inside <Transition> renders non-element root node ` +\r\n                    `that cannot be animated.`);\r\n            }\r\n            root.transition = vnode.transition;\r\n        }\r\n        if ((process.env.NODE_ENV !== 'production') && setRoot) {\r\n            setRoot(root);\r\n        }\r\n        else {\r\n            result = root;\r\n        }\r\n    }\r\n    catch (err) {\r\n        handleError(err, instance, 1 /* RENDER_FUNCTION */);\r\n        result = createVNode(Comment);\r\n    }\r\n    currentRenderingInstance = null;\r\n    return result;\r\n}\r\n/**\r\n * dev only\r\n * In dev mode, template root level comments are rendered, which turns the\r\n * template into a fragment root, but we need to locate the single element\r\n * root for attrs and scope id processing.\r\n */\r\nconst getChildRoot = (vnode) => {\r\n    if (vnode.type !== Fragment) {\r\n        return [vnode, undefined];\r\n    }\r\n    const rawChildren = vnode.children;\r\n    const dynamicChildren = vnode.dynamicChildren;\r\n    const childRoot = filterSingleRoot(rawChildren);\r\n    if (!childRoot) {\r\n        return [vnode, undefined];\r\n    }\r\n    const index = rawChildren.indexOf(childRoot);\r\n    const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;\r\n    const setRoot = (updatedRoot) => {\r\n        rawChildren[index] = updatedRoot;\r\n        if (dynamicIndex > -1) {\r\n            dynamicChildren[dynamicIndex] = updatedRoot;\r\n        }\r\n        else if (dynamicChildren && updatedRoot.patchFlag > 0) {\r\n            dynamicChildren.push(updatedRoot);\r\n        }\r\n    };\r\n    return [normalizeVNode(childRoot), setRoot];\r\n};\r\n/**\r\n * dev only\r\n */\r\nfunction filterSingleRoot(children) {\r\n    const filtered = children.filter(child => {\r\n        return !(isVNode(child) &&\r\n            child.type === Comment &&\r\n            child.children !== 'v-if');\r\n    });\r\n    return filtered.length === 1 && isVNode(filtered[0]) ? filtered[0] : null;\r\n}\r\nconst getFunctionalFallthrough = (attrs) => {\r\n    let res;\r\n    for (const key in attrs) {\r\n        if (key === 'class' || key === 'style' || isOn(key)) {\r\n            (res || (res = {}))[key] = attrs[key];\r\n        }\r\n    }\r\n    return res;\r\n};\r\nconst filterModelListeners = (attrs, props) => {\r\n    const res = {};\r\n    for (const key in attrs) {\r\n        if (!isModelListener(key) || !(key.slice(9) in props)) {\r\n            res[key] = attrs[key];\r\n        }\r\n    }\r\n    return res;\r\n};\r\nconst isElementRoot = (vnode) => {\r\n    return (vnode.shapeFlag & 6 /* COMPONENT */ ||\r\n        vnode.shapeFlag & 1 /* ELEMENT */ ||\r\n        vnode.type === Comment // potential v-if branch switch\r\n    );\r\n};\r\nfunction shouldUpdateComponent(prevVNode, nextVNode, optimized) {\r\n    const { props: prevProps, children: prevChildren, component } = prevVNode;\r\n    const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;\r\n    const emits = component.emitsOptions;\r\n    // Parent component's render function was hot-updated. Since this may have\r\n    // caused the child component's slots content to have changed, we need to\r\n    // force the child to update as well.\r\n    if ((process.env.NODE_ENV !== 'production') && (prevChildren || nextChildren) && isHmrUpdating) {\r\n        return true;\r\n    }\r\n    // force child update for runtime directive or transition on component vnode.\r\n    if (nextVNode.dirs || nextVNode.transition) {\r\n        return true;\r\n    }\r\n    if (optimized && patchFlag > 0) {\r\n        if (patchFlag & 1024 /* DYNAMIC_SLOTS */) {\r\n            // slot content that references values that might have changed,\r\n            // e.g. in a v-for\r\n            return true;\r\n        }\r\n        if (patchFlag & 16 /* FULL_PROPS */) {\r\n            if (!prevProps) {\r\n                return !!nextProps;\r\n            }\r\n            // presence of this flag indicates props are always non-null\r\n            return hasPropsChanged(prevProps, nextProps, emits);\r\n        }\r\n        else if (patchFlag & 8 /* PROPS */) {\r\n            const dynamicProps = nextVNode.dynamicProps;\r\n            for (let i = 0; i < dynamicProps.length; i++) {\r\n                const key = dynamicProps[i];\r\n                if (nextProps[key] !== prevProps[key] &&\r\n                    !isEmitListener(emits, key)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        // this path is only taken by manually written render functions\r\n        // so presence of any children leads to a forced update\r\n        if (prevChildren || nextChildren) {\r\n            if (!nextChildren || !nextChildren.$stable) {\r\n                return true;\r\n            }\r\n        }\r\n        if (prevProps === nextProps) {\r\n            return false;\r\n        }\r\n        if (!prevProps) {\r\n            return !!nextProps;\r\n        }\r\n        if (!nextProps) {\r\n            return true;\r\n        }\r\n        return hasPropsChanged(prevProps, nextProps, emits);\r\n    }\r\n    return false;\r\n}\r\nfunction hasPropsChanged(prevProps, nextProps, emitsOptions) {\r\n    const nextKeys = Object.keys(nextProps);\r\n    if (nextKeys.length !== Object.keys(prevProps).length) {\r\n        return true;\r\n    }\r\n    for (let i = 0; i < nextKeys.length; i++) {\r\n        const key = nextKeys[i];\r\n        if (nextProps[key] !== prevProps[key] &&\r\n            !isEmitListener(emitsOptions, key)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction updateHOCHostEl({ vnode, parent }, el // HostNode\r\n) {\r\n    while (parent && parent.subTree === vnode) {\r\n        (vnode = parent.vnode).el = el;\r\n        parent = parent.parent;\r\n    }\r\n}\n\nconst isSuspense = (type) => type.__isSuspense;\r\n// Suspense exposes a component-like API, and is treated like a component\r\n// in the compiler, but internally it's a special built-in type that hooks\r\n// directly into the renderer.\r\nconst SuspenseImpl = {\r\n    // In order to make Suspense tree-shakable, we need to avoid importing it\r\n    // directly in the renderer. The renderer checks for the __isSuspense flag\r\n    // on a vnode's type and calls the `process` method, passing in renderer\r\n    // internals.\r\n    __isSuspense: true,\r\n    process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized, \r\n    // platform-specific impl passed from renderer\r\n    rendererInternals) {\r\n        if (n1 == null) {\r\n            mountSuspense(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized, rendererInternals);\r\n        }\r\n        else {\r\n            patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, optimized, rendererInternals);\r\n        }\r\n    },\r\n    hydrate: hydrateSuspense,\r\n    create: createSuspenseBoundary\r\n};\r\n// Force-casted public typing for h and TSX props inference\r\nconst Suspense = ( SuspenseImpl\r\n    );\r\nfunction mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, isSVG, optimized, rendererInternals) {\r\n    const { p: patch, o: { createElement } } = rendererInternals;\r\n    const hiddenContainer = createElement('div');\r\n    const suspense = (vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, isSVG, optimized, rendererInternals));\r\n    // start mounting the content subtree in an off-dom container\r\n    patch(null, (suspense.pendingBranch = vnode.ssContent), hiddenContainer, null, parentComponent, suspense, isSVG, optimized);\r\n    // now check if we have encountered any async deps\r\n    if (suspense.deps > 0) {\r\n        // has async\r\n        // mount the fallback tree\r\n        patch(null, vnode.ssFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context\r\n        isSVG, optimized);\r\n        setActiveBranch(suspense, vnode.ssFallback);\r\n    }\r\n    else {\r\n        // Suspense has no async deps. Just resolve.\r\n        suspense.resolve();\r\n    }\r\n}\r\nfunction patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, optimized, { p: patch, um: unmount, o: { createElement } }) {\r\n    const suspense = (n2.suspense = n1.suspense);\r\n    suspense.vnode = n2;\r\n    n2.el = n1.el;\r\n    const newBranch = n2.ssContent;\r\n    const newFallback = n2.ssFallback;\r\n    const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;\r\n    if (pendingBranch) {\r\n        suspense.pendingBranch = newBranch;\r\n        if (isSameVNodeType(newBranch, pendingBranch)) {\r\n            // same root type but content may have changed.\r\n            patch(pendingBranch, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, optimized);\r\n            if (suspense.deps <= 0) {\r\n                suspense.resolve();\r\n            }\r\n            else if (isInFallback) {\r\n                patch(activeBranch, newFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context\r\n                isSVG, optimized);\r\n                setActiveBranch(suspense, newFallback);\r\n            }\r\n        }\r\n        else {\r\n            // toggled before pending tree is resolved\r\n            suspense.pendingId++;\r\n            if (isHydrating) {\r\n                // if toggled before hydration is finished, the current DOM tree is\r\n                // no longer valid. set it as the active branch so it will be unmounted\r\n                // when resolved\r\n                suspense.isHydrating = false;\r\n                suspense.activeBranch = pendingBranch;\r\n            }\r\n            else {\r\n                unmount(pendingBranch, parentComponent, suspense);\r\n            }\r\n            // increment pending ID. this is used to invalidate async callbacks\r\n            // reset suspense state\r\n            suspense.deps = 0;\r\n            // discard effects from pending branch\r\n            suspense.effects.length = 0;\r\n            // discard previous container\r\n            suspense.hiddenContainer = createElement('div');\r\n            if (isInFallback) {\r\n                // already in fallback state\r\n                patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, optimized);\r\n                if (suspense.deps <= 0) {\r\n                    suspense.resolve();\r\n                }\r\n                else {\r\n                    patch(activeBranch, newFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context\r\n                    isSVG, optimized);\r\n                    setActiveBranch(suspense, newFallback);\r\n                }\r\n            }\r\n            else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {\r\n                // toggled \"back\" to current active branch\r\n                patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, optimized);\r\n                // force resolve\r\n                suspense.resolve(true);\r\n            }\r\n            else {\r\n                // switched to a 3rd branch\r\n                patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, optimized);\r\n                if (suspense.deps <= 0) {\r\n                    suspense.resolve();\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {\r\n            // root did not change, just normal patch\r\n            patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, optimized);\r\n            setActiveBranch(suspense, newBranch);\r\n        }\r\n        else {\r\n            // root node toggled\r\n            // invoke @pending event\r\n            const onPending = n2.props && n2.props.onPending;\r\n            if (isFunction(onPending)) {\r\n                onPending();\r\n            }\r\n            // mount pending branch in off-dom container\r\n            suspense.pendingBranch = newBranch;\r\n            suspense.pendingId++;\r\n            patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, optimized);\r\n            if (suspense.deps <= 0) {\r\n                // incoming branch has no async deps, resolve now.\r\n                suspense.resolve();\r\n            }\r\n            else {\r\n                const { timeout, pendingId } = suspense;\r\n                if (timeout > 0) {\r\n                    setTimeout(() => {\r\n                        if (suspense.pendingId === pendingId) {\r\n                            suspense.fallback(newFallback);\r\n                        }\r\n                    }, timeout);\r\n                }\r\n                else if (timeout === 0) {\r\n                    suspense.fallback(newFallback);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\nlet hasWarned = false;\r\nfunction createSuspenseBoundary(vnode, parent, parentComponent, container, hiddenContainer, anchor, isSVG, optimized, rendererInternals, isHydrating = false) {\r\n    /* istanbul ignore if */\r\n    if ((process.env.NODE_ENV !== 'production') && !false && !hasWarned) {\r\n        hasWarned = true;\r\n        // @ts-ignore `console.info` cannot be null error\r\n        console[console.info ? 'info' : 'log'](`<Suspense> is an experimental feature and its API will likely change.`);\r\n    }\r\n    const { p: patch, m: move, um: unmount, n: next, o: { parentNode, remove } } = rendererInternals;\r\n    const timeout = toNumber(vnode.props && vnode.props.timeout);\r\n    const suspense = {\r\n        vnode,\r\n        parent,\r\n        parentComponent,\r\n        isSVG,\r\n        optimized,\r\n        container,\r\n        hiddenContainer,\r\n        anchor,\r\n        deps: 0,\r\n        pendingId: 0,\r\n        timeout: typeof timeout === 'number' ? timeout : -1,\r\n        activeBranch: null,\r\n        pendingBranch: null,\r\n        isInFallback: true,\r\n        isHydrating,\r\n        isUnmounted: false,\r\n        effects: [],\r\n        resolve(resume = false) {\r\n            if ((process.env.NODE_ENV !== 'production')) {\r\n                if (!resume && !suspense.pendingBranch) {\r\n                    throw new Error(`suspense.resolve() is called without a pending branch.`);\r\n                }\r\n                if (suspense.isUnmounted) {\r\n                    throw new Error(`suspense.resolve() is called on an already unmounted suspense boundary.`);\r\n                }\r\n            }\r\n            const { vnode, activeBranch, pendingBranch, pendingId, effects, parentComponent, container } = suspense;\r\n            if (suspense.isHydrating) {\r\n                suspense.isHydrating = false;\r\n            }\r\n            else if (!resume) {\r\n                const delayEnter = activeBranch &&\r\n                    pendingBranch.transition &&\r\n                    pendingBranch.transition.mode === 'out-in';\r\n                if (delayEnter) {\r\n                    activeBranch.transition.afterLeave = () => {\r\n                        if (pendingId === suspense.pendingId) {\r\n                            move(pendingBranch, container, anchor, 0 /* ENTER */);\r\n                        }\r\n                    };\r\n                }\r\n                // this is initial anchor on mount\r\n                let { anchor } = suspense;\r\n                // unmount current active tree\r\n                if (activeBranch) {\r\n                    // if the fallback tree was mounted, it may have been moved\r\n                    // as part of a parent suspense. get the latest anchor for insertion\r\n                    anchor = next(activeBranch);\r\n                    unmount(activeBranch, parentComponent, suspense, true);\r\n                }\r\n                if (!delayEnter) {\r\n                    // move content from off-dom container to actual container\r\n                    move(pendingBranch, container, anchor, 0 /* ENTER */);\r\n                }\r\n            }\r\n            setActiveBranch(suspense, pendingBranch);\r\n            suspense.pendingBranch = null;\r\n            suspense.isInFallback = false;\r\n            // flush buffered effects\r\n            // check if there is a pending parent suspense\r\n            let parent = suspense.parent;\r\n            let hasUnresolvedAncestor = false;\r\n            while (parent) {\r\n                if (parent.pendingBranch) {\r\n                    // found a pending parent suspense, merge buffered post jobs\r\n                    // into that parent\r\n                    parent.effects.push(...effects);\r\n                    hasUnresolvedAncestor = true;\r\n                    break;\r\n                }\r\n                parent = parent.parent;\r\n            }\r\n            // no pending parent suspense, flush all jobs\r\n            if (!hasUnresolvedAncestor) {\r\n                queuePostFlushCb(effects);\r\n            }\r\n            suspense.effects = [];\r\n            // invoke @resolve event\r\n            const onResolve = vnode.props && vnode.props.onResolve;\r\n            if (isFunction(onResolve)) {\r\n                onResolve();\r\n            }\r\n        },\r\n        fallback(fallbackVNode) {\r\n            if (!suspense.pendingBranch) {\r\n                return;\r\n            }\r\n            const { vnode, activeBranch, parentComponent, container, isSVG, optimized } = suspense;\r\n            // invoke @fallback event\r\n            const onFallback = vnode.props && vnode.props.onFallback;\r\n            if (isFunction(onFallback)) {\r\n                onFallback();\r\n            }\r\n            const anchor = next(activeBranch);\r\n            const mountFallback = () => {\r\n                if (!suspense.isInFallback) {\r\n                    return;\r\n                }\r\n                // mount the fallback tree\r\n                patch(null, fallbackVNode, container, anchor, parentComponent, null, // fallback tree will not have suspense context\r\n                isSVG, optimized);\r\n                setActiveBranch(suspense, fallbackVNode);\r\n            };\r\n            const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === 'out-in';\r\n            if (delayEnter) {\r\n                activeBranch.transition.afterLeave = mountFallback;\r\n            }\r\n            // unmount current active branch\r\n            unmount(activeBranch, parentComponent, null, // no suspense so unmount hooks fire now\r\n            true // shouldRemove\r\n            );\r\n            suspense.isInFallback = true;\r\n            if (!delayEnter) {\r\n                mountFallback();\r\n            }\r\n        },\r\n        move(container, anchor, type) {\r\n            suspense.activeBranch &&\r\n                move(suspense.activeBranch, container, anchor, type);\r\n            suspense.container = container;\r\n        },\r\n        next() {\r\n            return suspense.activeBranch && next(suspense.activeBranch);\r\n        },\r\n        registerDep(instance, setupRenderEffect) {\r\n            if (!suspense.pendingBranch) {\r\n                return;\r\n            }\r\n            const hydratedEl = instance.vnode.el;\r\n            suspense.deps++;\r\n            instance\r\n                .asyncDep.catch(err => {\r\n                handleError(err, instance, 0 /* SETUP_FUNCTION */);\r\n            })\r\n                .then(asyncSetupResult => {\r\n                // retry when the setup() promise resolves.\r\n                // component may have been unmounted before resolve.\r\n                if (instance.isUnmounted ||\r\n                    suspense.isUnmounted ||\r\n                    suspense.pendingId !== instance.suspenseId) {\r\n                    return;\r\n                }\r\n                suspense.deps--;\r\n                // retry from this component\r\n                instance.asyncResolved = true;\r\n                const { vnode } = instance;\r\n                if ((process.env.NODE_ENV !== 'production')) {\r\n                    pushWarningContext(vnode);\r\n                }\r\n                handleSetupResult(instance, asyncSetupResult);\r\n                if (hydratedEl) {\r\n                    // vnode may have been replaced if an update happened before the\r\n                    // async dep is resolved.\r\n                    vnode.el = hydratedEl;\r\n                }\r\n                const placeholder = !hydratedEl && instance.subTree.el;\r\n                setupRenderEffect(instance, vnode, \r\n                // component may have been moved before resolve.\r\n                // if this is not a hydration, instance.subTree will be the comment\r\n                // placeholder.\r\n                parentNode(hydratedEl || instance.subTree.el), \r\n                // anchor will not be used if this is hydration, so only need to\r\n                // consider the comment placeholder case.\r\n                hydratedEl ? null : next(instance.subTree), suspense, isSVG, optimized);\r\n                if (placeholder) {\r\n                    remove(placeholder);\r\n                }\r\n                updateHOCHostEl(instance, vnode.el);\r\n                if ((process.env.NODE_ENV !== 'production')) {\r\n                    popWarningContext();\r\n                }\r\n                if (suspense.deps === 0) {\r\n                    suspense.resolve();\r\n                }\r\n            });\r\n        },\r\n        unmount(parentSuspense, doRemove) {\r\n            suspense.isUnmounted = true;\r\n            if (suspense.activeBranch) {\r\n                unmount(suspense.activeBranch, parentComponent, parentSuspense, doRemove);\r\n            }\r\n            if (suspense.pendingBranch) {\r\n                unmount(suspense.pendingBranch, parentComponent, parentSuspense, doRemove);\r\n            }\r\n        }\r\n    };\r\n    return suspense;\r\n}\r\nfunction hydrateSuspense(node, vnode, parentComponent, parentSuspense, isSVG, optimized, rendererInternals, hydrateNode) {\r\n    /* eslint-disable no-restricted-globals */\r\n    const suspense = (vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, node.parentNode, document.createElement('div'), null, isSVG, optimized, rendererInternals, true /* hydrating */));\r\n    // there are two possible scenarios for server-rendered suspense:\r\n    // - success: ssr content should be fully resolved\r\n    // - failure: ssr content should be the fallback branch.\r\n    // however, on the client we don't really know if it has failed or not\r\n    // attempt to hydrate the DOM assuming it has succeeded, but we still\r\n    // need to construct a suspense boundary first\r\n    const result = hydrateNode(node, (suspense.pendingBranch = vnode.ssContent), parentComponent, suspense, optimized);\r\n    if (suspense.deps === 0) {\r\n        suspense.resolve();\r\n    }\r\n    return result;\r\n    /* eslint-enable no-restricted-globals */\r\n}\r\nfunction normalizeSuspenseChildren(vnode) {\r\n    const { shapeFlag, children } = vnode;\r\n    let content;\r\n    let fallback;\r\n    if (shapeFlag & 32 /* SLOTS_CHILDREN */) {\r\n        content = normalizeSuspenseSlot(children.default);\r\n        fallback = normalizeSuspenseSlot(children.fallback);\r\n    }\r\n    else {\r\n        content = normalizeSuspenseSlot(children);\r\n        fallback = normalizeVNode(null);\r\n    }\r\n    return {\r\n        content,\r\n        fallback\r\n    };\r\n}\r\nfunction normalizeSuspenseSlot(s) {\r\n    if (isFunction(s)) {\r\n        s = s();\r\n    }\r\n    if (isArray(s)) {\r\n        const singleChild = filterSingleRoot(s);\r\n        if ((process.env.NODE_ENV !== 'production') && !singleChild) {\r\n            warn(`<Suspense> slots expect a single root node.`);\r\n        }\r\n        s = singleChild;\r\n    }\r\n    return normalizeVNode(s);\r\n}\r\nfunction queueEffectWithSuspense(fn, suspense) {\r\n    if (suspense && suspense.pendingBranch) {\r\n        if (isArray(fn)) {\r\n            suspense.effects.push(...fn);\r\n        }\r\n        else {\r\n            suspense.effects.push(fn);\r\n        }\r\n    }\r\n    else {\r\n        queuePostFlushCb(fn);\r\n    }\r\n}\r\nfunction setActiveBranch(suspense, branch) {\r\n    suspense.activeBranch = branch;\r\n    const { vnode, parentComponent } = suspense;\r\n    const el = (vnode.el = branch.el);\r\n    // in case suspense is the root node of a component,\r\n    // recursively update the HOC el\r\n    if (parentComponent && parentComponent.subTree === vnode) {\r\n        parentComponent.vnode.el = el;\r\n        updateHOCHostEl(parentComponent, el);\r\n    }\r\n}\n\nlet isRenderingCompiledSlot = 0;\r\nconst setCompiledSlotRendering = (n) => (isRenderingCompiledSlot += n);\r\n/**\r\n * Compiler runtime helper for rendering `<slot/>`\r\n * @private\r\n */\r\nfunction renderSlot(slots, name, props = {}, \r\n// this is not a user-facing function, so the fallback is always generated by\r\n// the compiler and guaranteed to be a function returning an array\r\nfallback) {\r\n    let slot = slots[name];\r\n    if ((process.env.NODE_ENV !== 'production') && slot && slot.length > 1) {\r\n        warn(`SSR-optimized slot function detected in a non-SSR-optimized render ` +\r\n            `function. You need to mark this component with $dynamic-slots in the ` +\r\n            `parent template.`);\r\n        slot = () => [];\r\n    }\r\n    // a compiled slot disables block tracking by default to avoid manual\r\n    // invocation interfering with template-based block tracking, but in\r\n    // `renderSlot` we can be sure that it's template-based so we can force\r\n    // enable it.\r\n    isRenderingCompiledSlot++;\r\n    const rendered = (openBlock(),\r\n        createBlock(Fragment, { key: props.key }, slot ? slot(props) : fallback ? fallback() : [], slots._ === 1 /* STABLE */\r\n            ? 64 /* STABLE_FRAGMENT */\r\n            : -2 /* BAIL */));\r\n    isRenderingCompiledSlot--;\r\n    return rendered;\r\n}\n\n/**\r\n * Wrap a slot function to memoize current rendering instance\r\n * @private\r\n */\r\nfunction withCtx(fn, ctx = currentRenderingInstance) {\r\n    if (!ctx)\r\n        return fn;\r\n    const renderFnWithContext = (...args) => {\r\n        // If a user calls a compiled slot inside a template expression (#1745), it\r\n        // can mess up block tracking, so by default we need to push a null block to\r\n        // avoid that. This isn't necessary if rendering a compiled `<slot>`.\r\n        if (!isRenderingCompiledSlot) {\r\n            openBlock(true /* null block that disables tracking */);\r\n        }\r\n        const owner = currentRenderingInstance;\r\n        setCurrentRenderingInstance(ctx);\r\n        const res = fn(...args);\r\n        setCurrentRenderingInstance(owner);\r\n        if (!isRenderingCompiledSlot) {\r\n            closeBlock();\r\n        }\r\n        return res;\r\n    };\r\n    renderFnWithContext._c = true;\r\n    return renderFnWithContext;\r\n}\n\n// SFC scoped style ID management.\r\nlet currentScopeId = null;\r\nconst scopeIdStack = [];\r\n/**\r\n * @private\r\n */\r\nfunction pushScopeId(id) {\r\n    scopeIdStack.push((currentScopeId = id));\r\n}\r\n/**\r\n * @private\r\n */\r\nfunction popScopeId() {\r\n    scopeIdStack.pop();\r\n    currentScopeId = scopeIdStack[scopeIdStack.length - 1] || null;\r\n}\r\n/**\r\n * @private\r\n */\r\nfunction withScopeId(id) {\r\n    return ((fn) => withCtx(function () {\r\n        pushScopeId(id);\r\n        const res = fn.apply(this, arguments);\r\n        popScopeId();\r\n        return res;\r\n    }));\r\n}\n\nfunction initProps(instance, rawProps, isStateful, // result of bitwise flag comparison\r\nisSSR = false) {\r\n    const props = {};\r\n    const attrs = {};\r\n    def(attrs, InternalObjectKey, 1);\r\n    setFullProps(instance, rawProps, props, attrs);\r\n    // validation\r\n    if ((process.env.NODE_ENV !== 'production')) {\r\n        validateProps(props, instance);\r\n    }\r\n    if (isStateful) {\r\n        // stateful\r\n        instance.props = isSSR ? props : shallowReactive(props);\r\n    }\r\n    else {\r\n        if (!instance.type.props) {\r\n            // functional w/ optional props, props === attrs\r\n            instance.props = attrs;\r\n        }\r\n        else {\r\n            // functional w/ declared props\r\n            instance.props = props;\r\n        }\r\n    }\r\n    instance.attrs = attrs;\r\n}\r\nfunction updateProps(instance, rawProps, rawPrevProps, optimized) {\r\n    const { props, attrs, vnode: { patchFlag } } = instance;\r\n    const rawCurrentProps = toRaw(props);\r\n    const [options] = instance.propsOptions;\r\n    if (\r\n    // always force full diff in dev\r\n    // - #1942 if hmr is enabled with sfc component\r\n    // - vite#872 non-sfc component used by sfc component\r\n    !((process.env.NODE_ENV !== 'production') &&\r\n        (instance.type.__hmrId ||\r\n            (instance.parent && instance.parent.type.__hmrId))) &&\r\n        (optimized || patchFlag > 0) &&\r\n        !(patchFlag & 16 /* FULL_PROPS */)) {\r\n        if (patchFlag & 8 /* PROPS */) {\r\n            // Compiler-generated props & no keys change, just set the updated\r\n            // the props.\r\n            const propsToUpdate = instance.vnode.dynamicProps;\r\n            for (let i = 0; i < propsToUpdate.length; i++) {\r\n                const key = propsToUpdate[i];\r\n                // PROPS flag guarantees rawProps to be non-null\r\n                const value = rawProps[key];\r\n                if (options) {\r\n                    // attr / props separation was done on init and will be consistent\r\n                    // in this code path, so just check if attrs have it.\r\n                    if (hasOwn(attrs, key)) {\r\n                        attrs[key] = value;\r\n                    }\r\n                    else {\r\n                        const camelizedKey = camelize(key);\r\n                        props[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value, instance);\r\n                    }\r\n                }\r\n                else {\r\n                    attrs[key] = value;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        // full props update.\r\n        setFullProps(instance, rawProps, props, attrs);\r\n        // in case of dynamic props, check if we need to delete keys from\r\n        // the props object\r\n        let kebabKey;\r\n        for (const key in rawCurrentProps) {\r\n            if (!rawProps ||\r\n                // for camelCase\r\n                (!hasOwn(rawProps, key) &&\r\n                    // it's possible the original props was passed in as kebab-case\r\n                    // and converted to camelCase (#955)\r\n                    ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey)))) {\r\n                if (options) {\r\n                    if (rawPrevProps &&\r\n                        // for camelCase\r\n                        (rawPrevProps[key] !== undefined ||\r\n                            // for kebab-case\r\n                            rawPrevProps[kebabKey] !== undefined)) {\r\n                        props[key] = resolvePropValue(options, rawProps || EMPTY_OBJ, key, undefined, instance);\r\n                    }\r\n                }\r\n                else {\r\n                    delete props[key];\r\n                }\r\n            }\r\n        }\r\n        // in the case of functional component w/o props declaration, props and\r\n        // attrs point to the same object so it should already have been updated.\r\n        if (attrs !== rawCurrentProps) {\r\n            for (const key in attrs) {\r\n                if (!rawProps || !hasOwn(rawProps, key)) {\r\n                    delete attrs[key];\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // trigger updates for $attrs in case it's used in component slots\r\n    trigger(instance, \"set\" /* SET */, '$attrs');\r\n    if ((process.env.NODE_ENV !== 'production') && rawProps) {\r\n        validateProps(props, instance);\r\n    }\r\n}\r\nfunction setFullProps(instance, rawProps, props, attrs) {\r\n    const [options, needCastKeys] = instance.propsOptions;\r\n    if (rawProps) {\r\n        for (const key in rawProps) {\r\n            const value = rawProps[key];\r\n            // key, ref are reserved and never passed down\r\n            if (isReservedProp(key)) {\r\n                continue;\r\n            }\r\n            // prop option names are camelized during normalization, so to support\r\n            // kebab -> camel conversion here we need to camelize the key.\r\n            let camelKey;\r\n            if (options && hasOwn(options, (camelKey = camelize(key)))) {\r\n                props[camelKey] = value;\r\n            }\r\n            else if (!isEmitListener(instance.emitsOptions, key)) {\r\n                // Any non-declared (either as a prop or an emitted event) props are put\r\n                // into a separate `attrs` object for spreading. Make sure to preserve\r\n                // original key casing\r\n                attrs[key] = value;\r\n            }\r\n        }\r\n    }\r\n    if (needCastKeys) {\r\n        const rawCurrentProps = toRaw(props);\r\n        for (let i = 0; i < needCastKeys.length; i++) {\r\n            const key = needCastKeys[i];\r\n            props[key] = resolvePropValue(options, rawCurrentProps, key, rawCurrentProps[key], instance);\r\n        }\r\n    }\r\n}\r\nfunction resolvePropValue(options, props, key, value, instance) {\r\n    const opt = options[key];\r\n    if (opt != null) {\r\n        const hasDefault = hasOwn(opt, 'default');\r\n        // default values\r\n        if (hasDefault && value === undefined) {\r\n            const defaultValue = opt.default;\r\n            if (opt.type !== Function && isFunction(defaultValue)) {\r\n                setCurrentInstance(instance);\r\n                value = defaultValue(props);\r\n                setCurrentInstance(null);\r\n            }\r\n            else {\r\n                value = defaultValue;\r\n            }\r\n        }\r\n        // boolean casting\r\n        if (opt[0 /* shouldCast */]) {\r\n            if (!hasOwn(props, key) && !hasDefault) {\r\n                value = false;\r\n            }\r\n            else if (opt[1 /* shouldCastTrue */] &&\r\n                (value === '' || value === hyphenate(key))) {\r\n                value = true;\r\n            }\r\n        }\r\n    }\r\n    return value;\r\n}\r\nfunction normalizePropsOptions(comp, appContext, asMixin = false) {\r\n    if (!appContext.deopt && comp.__props) {\r\n        return comp.__props;\r\n    }\r\n    const raw = comp.props;\r\n    const normalized = {};\r\n    const needCastKeys = [];\r\n    // apply mixin/extends props\r\n    let hasExtends = false;\r\n    if (__VUE_OPTIONS_API__ && !isFunction(comp)) {\r\n        const extendProps = (raw) => {\r\n            hasExtends = true;\r\n            const [props, keys] = normalizePropsOptions(raw, appContext, true);\r\n            extend(normalized, props);\r\n            if (keys)\r\n                needCastKeys.push(...keys);\r\n        };\r\n        if (!asMixin && appContext.mixins.length) {\r\n            appContext.mixins.forEach(extendProps);\r\n        }\r\n        if (comp.extends) {\r\n            extendProps(comp.extends);\r\n        }\r\n        if (comp.mixins) {\r\n            comp.mixins.forEach(extendProps);\r\n        }\r\n    }\r\n    if (!raw && !hasExtends) {\r\n        return (comp.__props = EMPTY_ARR);\r\n    }\r\n    if (isArray(raw)) {\r\n        for (let i = 0; i < raw.length; i++) {\r\n            if ((process.env.NODE_ENV !== 'production') && !isString(raw[i])) {\r\n                warn(`props must be strings when using array syntax.`, raw[i]);\r\n            }\r\n            const normalizedKey = camelize(raw[i]);\r\n            if (validatePropName(normalizedKey)) {\r\n                normalized[normalizedKey] = EMPTY_OBJ;\r\n            }\r\n        }\r\n    }\r\n    else if (raw) {\r\n        if ((process.env.NODE_ENV !== 'production') && !isObject(raw)) {\r\n            warn(`invalid props options`, raw);\r\n        }\r\n        for (const key in raw) {\r\n            const normalizedKey = camelize(key);\r\n            if (validatePropName(normalizedKey)) {\r\n                const opt = raw[key];\r\n                const prop = (normalized[normalizedKey] =\r\n                    isArray(opt) || isFunction(opt) ? { type: opt } : opt);\r\n                if (prop) {\r\n                    const booleanIndex = getTypeIndex(Boolean, prop.type);\r\n                    const stringIndex = getTypeIndex(String, prop.type);\r\n                    prop[0 /* shouldCast */] = booleanIndex > -1;\r\n                    prop[1 /* shouldCastTrue */] =\r\n                        stringIndex < 0 || booleanIndex < stringIndex;\r\n                    // if the prop needs boolean casting or default value\r\n                    if (booleanIndex > -1 || hasOwn(prop, 'default')) {\r\n                        needCastKeys.push(normalizedKey);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return (comp.__props = [normalized, needCastKeys]);\r\n}\r\nfunction validatePropName(key) {\r\n    if (key[0] !== '$') {\r\n        return true;\r\n    }\r\n    else if ((process.env.NODE_ENV !== 'production')) {\r\n        warn(`Invalid prop name: \"${key}\" is a reserved property.`);\r\n    }\r\n    return false;\r\n}\r\n// use function string name to check type constructors\r\n// so that it works across vms / iframes.\r\nfunction getType(ctor) {\r\n    const match = ctor && ctor.toString().match(/^\\s*function (\\w+)/);\r\n    return match ? match[1] : '';\r\n}\r\nfunction isSameType(a, b) {\r\n    return getType(a) === getType(b);\r\n}\r\nfunction getTypeIndex(type, expectedTypes) {\r\n    if (isArray(expectedTypes)) {\r\n        for (let i = 0, len = expectedTypes.length; i < len; i++) {\r\n            if (isSameType(expectedTypes[i], type)) {\r\n                return i;\r\n            }\r\n        }\r\n    }\r\n    else if (isFunction(expectedTypes)) {\r\n        return isSameType(expectedTypes, type) ? 0 : -1;\r\n    }\r\n    return -1;\r\n}\r\n/**\r\n * dev only\r\n */\r\nfunction validateProps(props, instance) {\r\n    const rawValues = toRaw(props);\r\n    const options = instance.propsOptions[0];\r\n    for (const key in options) {\r\n        let opt = options[key];\r\n        if (opt == null)\r\n            continue;\r\n        validateProp(key, rawValues[key], opt, !hasOwn(rawValues, key));\r\n    }\r\n}\r\n/**\r\n * dev only\r\n */\r\nfunction validateProp(name, value, prop, isAbsent) {\r\n    const { type, required, validator } = prop;\r\n    // required!\r\n    if (required && isAbsent) {\r\n        warn('Missing required prop: \"' + name + '\"');\r\n        return;\r\n    }\r\n    // missing but optional\r\n    if (value == null && !prop.required) {\r\n        return;\r\n    }\r\n    // type check\r\n    if (type != null && type !== true) {\r\n        let isValid = false;\r\n        const types = isArray(type) ? type : [type];\r\n        const expectedTypes = [];\r\n        // value is valid as long as one of the specified types match\r\n        for (let i = 0; i < types.length && !isValid; i++) {\r\n            const { valid, expectedType } = assertType(value, types[i]);\r\n            expectedTypes.push(expectedType || '');\r\n            isValid = valid;\r\n        }\r\n        if (!isValid) {\r\n            warn(getInvalidTypeMessage(name, value, expectedTypes));\r\n            return;\r\n        }\r\n    }\r\n    // custom validator\r\n    if (validator && !validator(value)) {\r\n        warn('Invalid prop: custom validator check failed for prop \"' + name + '\".');\r\n    }\r\n}\r\nconst isSimpleType = /*#__PURE__*/ makeMap('String,Number,Boolean,Function,Symbol');\r\n/**\r\n * dev only\r\n */\r\nfunction assertType(value, type) {\r\n    let valid;\r\n    const expectedType = getType(type);\r\n    if (isSimpleType(expectedType)) {\r\n        const t = typeof value;\r\n        valid = t === expectedType.toLowerCase();\r\n        // for primitive wrapper objects\r\n        if (!valid && t === 'object') {\r\n            valid = value instanceof type;\r\n        }\r\n    }\r\n    else if (expectedType === 'Object') {\r\n        valid = isObject(value);\r\n    }\r\n    else if (expectedType === 'Array') {\r\n        valid = isArray(value);\r\n    }\r\n    else {\r\n        valid = value instanceof type;\r\n    }\r\n    return {\r\n        valid,\r\n        expectedType\r\n    };\r\n}\r\n/**\r\n * dev only\r\n */\r\nfunction getInvalidTypeMessage(name, value, expectedTypes) {\r\n    let message = `Invalid prop: type check failed for prop \"${name}\".` +\r\n        ` Expected ${expectedTypes.map(capitalize).join(', ')}`;\r\n    const expectedType = expectedTypes[0];\r\n    const receivedType = toRawType(value);\r\n    const expectedValue = styleValue(value, expectedType);\r\n    const receivedValue = styleValue(value, receivedType);\r\n    // check if we need to specify expected value\r\n    if (expectedTypes.length === 1 &&\r\n        isExplicable(expectedType) &&\r\n        !isBoolean(expectedType, receivedType)) {\r\n        message += ` with value ${expectedValue}`;\r\n    }\r\n    message += `, got ${receivedType} `;\r\n    // check if we need to specify received value\r\n    if (isExplicable(receivedType)) {\r\n        message += `with value ${receivedValue}.`;\r\n    }\r\n    return message;\r\n}\r\n/**\r\n * dev only\r\n */\r\nfunction styleValue(value, type) {\r\n    if (type === 'String') {\r\n        return `\"${value}\"`;\r\n    }\r\n    else if (type === 'Number') {\r\n        return `${Number(value)}`;\r\n    }\r\n    else {\r\n        return `${value}`;\r\n    }\r\n}\r\n/**\r\n * dev only\r\n */\r\nfunction isExplicable(type) {\r\n    const explicitTypes = ['string', 'number', 'boolean'];\r\n    return explicitTypes.some(elem => type.toLowerCase() === elem);\r\n}\r\n/**\r\n * dev only\r\n */\r\nfunction isBoolean(...args) {\r\n    return args.some(elem => elem.toLowerCase() === 'boolean');\r\n}\n\nfunction injectHook(type, hook, target = currentInstance, prepend = false) {\r\n    if (target) {\r\n        const hooks = target[type] || (target[type] = []);\r\n        // cache the error handling wrapper for injected hooks so the same hook\r\n        // can be properly deduped by the scheduler. \"__weh\" stands for \"with error\r\n        // handling\".\r\n        const wrappedHook = hook.__weh ||\r\n            (hook.__weh = (...args) => {\r\n                if (target.isUnmounted) {\r\n                    return;\r\n                }\r\n                // disable tracking inside all lifecycle hooks\r\n                // since they can potentially be called inside effects.\r\n                pauseTracking();\r\n                // Set currentInstance during hook invocation.\r\n                // This assumes the hook does not synchronously trigger other hooks, which\r\n                // can only be false when the user does something really funky.\r\n                setCurrentInstance(target);\r\n                const res = callWithAsyncErrorHandling(hook, target, type, args);\r\n                setCurrentInstance(null);\r\n                resetTracking();\r\n                return res;\r\n            });\r\n        if (prepend) {\r\n            hooks.unshift(wrappedHook);\r\n        }\r\n        else {\r\n            hooks.push(wrappedHook);\r\n        }\r\n        return wrappedHook;\r\n    }\r\n    else if ((process.env.NODE_ENV !== 'production')) {\r\n        const apiName = `on${capitalize(ErrorTypeStrings[type].replace(/ hook$/, ''))}`;\r\n        warn(`${apiName} is called when there is no active component instance to be ` +\r\n            `associated with. ` +\r\n            `Lifecycle injection APIs can only be used during execution of setup().` +\r\n            ( ` If you are using async setup(), make sure to register lifecycle ` +\r\n                    `hooks before the first await statement.`\r\n                ));\r\n    }\r\n}\r\nconst createHook = (lifecycle) => (hook, target = currentInstance) => \r\n// post-create lifecycle registrations are noops during SSR\r\n!isInSSRComponentSetup && injectHook(lifecycle, hook, target);\r\nconst onBeforeMount = createHook(\"bm\" /* BEFORE_MOUNT */);\r\nconst onMounted = createHook(\"m\" /* MOUNTED */);\r\nconst onBeforeUpdate = createHook(\"bu\" /* BEFORE_UPDATE */);\r\nconst onUpdated = createHook(\"u\" /* UPDATED */);\r\nconst onBeforeUnmount = createHook(\"bum\" /* BEFORE_UNMOUNT */);\r\nconst onUnmounted = createHook(\"um\" /* UNMOUNTED */);\r\nconst onRenderTriggered = createHook(\"rtg\" /* RENDER_TRIGGERED */);\r\nconst onRenderTracked = createHook(\"rtc\" /* RENDER_TRACKED */);\r\nconst onErrorCaptured = (hook, target = currentInstance) => {\r\n    injectHook(\"ec\" /* ERROR_CAPTURED */, hook, target);\r\n};\n\n// Simple effect.\r\nfunction watchEffect(effect, options) {\r\n    return doWatch(effect, null, options);\r\n}\r\n// initial value for watchers to trigger on undefined initial values\r\nconst INITIAL_WATCHER_VALUE = {};\r\n// implementation\r\nfunction watch(source, cb, options) {\r\n    if ((process.env.NODE_ENV !== 'production') && !isFunction(cb)) {\r\n        warn(`\\`watch(fn, options?)\\` signature has been moved to a separate API. ` +\r\n            `Use \\`watchEffect(fn, options?)\\` instead. \\`watch\\` now only ` +\r\n            `supports \\`watch(source, cb, options?) signature.`);\r\n    }\r\n    return doWatch(source, cb, options);\r\n}\r\nfunction doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ, instance = currentInstance) {\r\n    if ((process.env.NODE_ENV !== 'production') && !cb) {\r\n        if (immediate !== undefined) {\r\n            warn(`watch() \"immediate\" option is only respected when using the ` +\r\n                `watch(source, callback, options?) signature.`);\r\n        }\r\n        if (deep !== undefined) {\r\n            warn(`watch() \"deep\" option is only respected when using the ` +\r\n                `watch(source, callback, options?) signature.`);\r\n        }\r\n    }\r\n    const warnInvalidSource = (s) => {\r\n        warn(`Invalid watch source: `, s, `A watch source can only be a getter/effect function, a ref, ` +\r\n            `a reactive object, or an array of these types.`);\r\n    };\r\n    let getter;\r\n    let forceTrigger = false;\r\n    if (isRef(source)) {\r\n        getter = () => source.value;\r\n        forceTrigger = !!source._shallow;\r\n    }\r\n    else if (isReactive(source)) {\r\n        getter = () => source;\r\n        deep = true;\r\n    }\r\n    else if (isArray(source)) {\r\n        getter = () => source.map(s => {\r\n            if (isRef(s)) {\r\n                return s.value;\r\n            }\r\n            else if (isReactive(s)) {\r\n                return traverse(s);\r\n            }\r\n            else if (isFunction(s)) {\r\n                return callWithErrorHandling(s, instance, 2 /* WATCH_GETTER */);\r\n            }\r\n            else {\r\n                (process.env.NODE_ENV !== 'production') && warnInvalidSource(s);\r\n            }\r\n        });\r\n    }\r\n    else if (isFunction(source)) {\r\n        if (cb) {\r\n            // getter with cb\r\n            getter = () => callWithErrorHandling(source, instance, 2 /* WATCH_GETTER */);\r\n        }\r\n        else {\r\n            // no cb -> simple effect\r\n            getter = () => {\r\n                if (instance && instance.isUnmounted) {\r\n                    return;\r\n                }\r\n                if (cleanup) {\r\n                    cleanup();\r\n                }\r\n                return callWithErrorHandling(source, instance, 3 /* WATCH_CALLBACK */, [onInvalidate]);\r\n            };\r\n        }\r\n    }\r\n    else {\r\n        getter = NOOP;\r\n        (process.env.NODE_ENV !== 'production') && warnInvalidSource(source);\r\n    }\r\n    if (cb && deep) {\r\n        const baseGetter = getter;\r\n        getter = () => traverse(baseGetter());\r\n    }\r\n    let cleanup;\r\n    const onInvalidate = (fn) => {\r\n        cleanup = runner.options.onStop = () => {\r\n            callWithErrorHandling(fn, instance, 4 /* WATCH_CLEANUP */);\r\n        };\r\n    };\r\n    let oldValue = isArray(source) ? [] : INITIAL_WATCHER_VALUE;\r\n    const job = () => {\r\n        if (!runner.active) {\r\n            return;\r\n        }\r\n        if (cb) {\r\n            // watch(source, cb)\r\n            const newValue = runner();\r\n            if (deep || forceTrigger || hasChanged(newValue, oldValue)) {\r\n                // cleanup before running cb again\r\n                if (cleanup) {\r\n                    cleanup();\r\n                }\r\n                callWithAsyncErrorHandling(cb, instance, 3 /* WATCH_CALLBACK */, [\r\n                    newValue,\r\n                    // pass undefined as the old value when it's changed for the first time\r\n                    oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue,\r\n                    onInvalidate\r\n                ]);\r\n                oldValue = newValue;\r\n            }\r\n        }\r\n        else {\r\n            // watchEffect\r\n            runner();\r\n        }\r\n    };\r\n    // important: mark the job as a watcher callback so that scheduler knows\r\n    // it is allowed to self-trigger (#1727)\r\n    job.allowRecurse = !!cb;\r\n    let scheduler;\r\n    if (flush === 'sync') {\r\n        scheduler = job;\r\n    }\r\n    else if (flush === 'post') {\r\n        scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);\r\n    }\r\n    else {\r\n        // default: 'pre'\r\n        scheduler = () => {\r\n            if (!instance || instance.isMounted) {\r\n                queuePreFlushCb(job);\r\n            }\r\n            else {\r\n                // with 'pre' option, the first call must happen before\r\n                // the component is mounted so it is called synchronously.\r\n                job();\r\n            }\r\n        };\r\n    }\r\n    const runner = effect(getter, {\r\n        lazy: true,\r\n        onTrack,\r\n        onTrigger,\r\n        scheduler\r\n    });\r\n    recordInstanceBoundEffect(runner);\r\n    // initial run\r\n    if (cb) {\r\n        if (immediate) {\r\n            job();\r\n        }\r\n        else {\r\n            oldValue = runner();\r\n        }\r\n    }\r\n    else if (flush === 'post') {\r\n        queuePostRenderEffect(runner, instance && instance.suspense);\r\n    }\r\n    else {\r\n        runner();\r\n    }\r\n    return () => {\r\n        stop(runner);\r\n        if (instance) {\r\n            remove(instance.effects, runner);\r\n        }\r\n    };\r\n}\r\n// this.$watch\r\nfunction instanceWatch(source, cb, options) {\r\n    const publicThis = this.proxy;\r\n    const getter = isString(source)\r\n        ? () => publicThis[source]\r\n        : source.bind(publicThis);\r\n    return doWatch(getter, cb.bind(publicThis), options, this);\r\n}\r\nfunction traverse(value, seen = new Set()) {\r\n    if (!isObject(value) || seen.has(value)) {\r\n        return value;\r\n    }\r\n    seen.add(value);\r\n    if (isRef(value)) {\r\n        traverse(value.value, seen);\r\n    }\r\n    else if (isArray(value)) {\r\n        for (let i = 0; i < value.length; i++) {\r\n            traverse(value[i], seen);\r\n        }\r\n    }\r\n    else if (isSet(value) || isMap(value)) {\r\n        value.forEach((v) => {\r\n            traverse(v, seen);\r\n        });\r\n    }\r\n    else {\r\n        for (const key in value) {\r\n            traverse(value[key], seen);\r\n        }\r\n    }\r\n    return value;\r\n}\n\nfunction useTransitionState() {\r\n    const state = {\r\n        isMounted: false,\r\n        isLeaving: false,\r\n        isUnmounting: false,\r\n        leavingVNodes: new Map()\r\n    };\r\n    onMounted(() => {\r\n        state.isMounted = true;\r\n    });\r\n    onBeforeUnmount(() => {\r\n        state.isUnmounting = true;\r\n    });\r\n    return state;\r\n}\r\nconst TransitionHookValidator = [Function, Array];\r\nconst BaseTransitionImpl = {\r\n    name: `BaseTransition`,\r\n    props: {\r\n        mode: String,\r\n        appear: Boolean,\r\n        persisted: Boolean,\r\n        // enter\r\n        onBeforeEnter: TransitionHookValidator,\r\n        onEnter: TransitionHookValidator,\r\n        onAfterEnter: TransitionHookValidator,\r\n        onEnterCancelled: TransitionHookValidator,\r\n        // leave\r\n        onBeforeLeave: TransitionHookValidator,\r\n        onLeave: TransitionHookValidator,\r\n        onAfterLeave: TransitionHookValidator,\r\n        onLeaveCancelled: TransitionHookValidator,\r\n        // appear\r\n        onBeforeAppear: TransitionHookValidator,\r\n        onAppear: TransitionHookValidator,\r\n        onAfterAppear: TransitionHookValidator,\r\n        onAppearCancelled: TransitionHookValidator\r\n    },\r\n    setup(props, { slots }) {\r\n        const instance = getCurrentInstance();\r\n        const state = useTransitionState();\r\n        let prevTransitionKey;\r\n        return () => {\r\n            const children = slots.default && getTransitionRawChildren(slots.default(), true);\r\n            if (!children || !children.length) {\r\n                return;\r\n            }\r\n            // warn multiple elements\r\n            if ((process.env.NODE_ENV !== 'production') && children.length > 1) {\r\n                warn('<transition> can only be used on a single element or component. Use ' +\r\n                    '<transition-group> for lists.');\r\n            }\r\n            // there's no need to track reactivity for these props so use the raw\r\n            // props for a bit better perf\r\n            const rawProps = toRaw(props);\r\n            const { mode } = rawProps;\r\n            // check mode\r\n            if ((process.env.NODE_ENV !== 'production') && mode && !['in-out', 'out-in', 'default'].includes(mode)) {\r\n                warn(`invalid <transition> mode: ${mode}`);\r\n            }\r\n            // at this point children has a guaranteed length of 1.\r\n            const child = children[0];\r\n            if (state.isLeaving) {\r\n                return emptyPlaceholder(child);\r\n            }\r\n            // in the case of <transition><keep-alive/></transition>, we need to\r\n            // compare the type of the kept-alive children.\r\n            const innerChild = getKeepAliveChild(child);\r\n            if (!innerChild) {\r\n                return emptyPlaceholder(child);\r\n            }\r\n            const enterHooks = resolveTransitionHooks(innerChild, rawProps, state, instance);\r\n            setTransitionHooks(innerChild, enterHooks);\r\n            const oldChild = instance.subTree;\r\n            const oldInnerChild = oldChild && getKeepAliveChild(oldChild);\r\n            let transitionKeyChanged = false;\r\n            const { getTransitionKey } = innerChild.type;\r\n            if (getTransitionKey) {\r\n                const key = getTransitionKey();\r\n                if (prevTransitionKey === undefined) {\r\n                    prevTransitionKey = key;\r\n                }\r\n                else if (key !== prevTransitionKey) {\r\n                    prevTransitionKey = key;\r\n                    transitionKeyChanged = true;\r\n                }\r\n            }\r\n            // handle mode\r\n            if (oldInnerChild &&\r\n                oldInnerChild.type !== Comment &&\r\n                (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {\r\n                const leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance);\r\n                // update old tree's hooks in case of dynamic transition\r\n                setTransitionHooks(oldInnerChild, leavingHooks);\r\n                // switching between different views\r\n                if (mode === 'out-in') {\r\n                    state.isLeaving = true;\r\n                    // return placeholder node and queue update when leave finishes\r\n                    leavingHooks.afterLeave = () => {\r\n                        state.isLeaving = false;\r\n                        instance.update();\r\n                    };\r\n                    return emptyPlaceholder(child);\r\n                }\r\n                else if (mode === 'in-out') {\r\n                    leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {\r\n                        const leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);\r\n                        leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;\r\n                        // early removal callback\r\n                        el._leaveCb = () => {\r\n                            earlyRemove();\r\n                            el._leaveCb = undefined;\r\n                            delete enterHooks.delayedLeave;\r\n                        };\r\n                        enterHooks.delayedLeave = delayedLeave;\r\n                    };\r\n                }\r\n            }\r\n            return child;\r\n        };\r\n    }\r\n};\r\n// export the public type for h/tsx inference\r\n// also to avoid inline import() in generated d.ts files\r\nconst BaseTransition = BaseTransitionImpl;\r\nfunction getLeavingNodesForType(state, vnode) {\r\n    const { leavingVNodes } = state;\r\n    let leavingVNodesCache = leavingVNodes.get(vnode.type);\r\n    if (!leavingVNodesCache) {\r\n        leavingVNodesCache = Object.create(null);\r\n        leavingVNodes.set(vnode.type, leavingVNodesCache);\r\n    }\r\n    return leavingVNodesCache;\r\n}\r\n// The transition hooks are attached to the vnode as vnode.transition\r\n// and will be called at appropriate timing in the renderer.\r\nfunction resolveTransitionHooks(vnode, props, state, instance) {\r\n    const { appear, mode, persisted = false, onBeforeEnter, onEnter, onAfterEnter, onEnterCancelled, onBeforeLeave, onLeave, onAfterLeave, onLeaveCancelled, onBeforeAppear, onAppear, onAfterAppear, onAppearCancelled } = props;\r\n    const key = String(vnode.key);\r\n    const leavingVNodesCache = getLeavingNodesForType(state, vnode);\r\n    const callHook = (hook, args) => {\r\n        hook &&\r\n            callWithAsyncErrorHandling(hook, instance, 9 /* TRANSITION_HOOK */, args);\r\n    };\r\n    const hooks = {\r\n        mode,\r\n        persisted,\r\n        beforeEnter(el) {\r\n            let hook = onBeforeEnter;\r\n            if (!state.isMounted) {\r\n                if (appear) {\r\n                    hook = onBeforeAppear || onBeforeEnter;\r\n                }\r\n                else {\r\n                    return;\r\n                }\r\n            }\r\n            // for same element (v-show)\r\n            if (el._leaveCb) {\r\n                el._leaveCb(true /* cancelled */);\r\n            }\r\n            // for toggled element with same key (v-if)\r\n            const leavingVNode = leavingVNodesCache[key];\r\n            if (leavingVNode &&\r\n                isSameVNodeType(vnode, leavingVNode) &&\r\n                leavingVNode.el._leaveCb) {\r\n                // force early removal (not cancelled)\r\n                leavingVNode.el._leaveCb();\r\n            }\r\n            callHook(hook, [el]);\r\n        },\r\n        enter(el) {\r\n            let hook = onEnter;\r\n            let afterHook = onAfterEnter;\r\n            let cancelHook = onEnterCancelled;\r\n            if (!state.isMounted) {\r\n                if (appear) {\r\n                    hook = onAppear || onEnter;\r\n                    afterHook = onAfterAppear || onAfterEnter;\r\n                    cancelHook = onAppearCancelled || onEnterCancelled;\r\n                }\r\n                else {\r\n                    return;\r\n                }\r\n            }\r\n            let called = false;\r\n            const done = (el._enterCb = (cancelled) => {\r\n                if (called)\r\n                    return;\r\n                called = true;\r\n                if (cancelled) {\r\n                    callHook(cancelHook, [el]);\r\n                }\r\n                else {\r\n                    callHook(afterHook, [el]);\r\n                }\r\n                if (hooks.delayedLeave) {\r\n                    hooks.delayedLeave();\r\n                }\r\n                el._enterCb = undefined;\r\n            });\r\n            if (hook) {\r\n                hook(el, done);\r\n                if (hook.length <= 1) {\r\n                    done();\r\n                }\r\n            }\r\n            else {\r\n                done();\r\n            }\r\n        },\r\n        leave(el, remove) {\r\n            const key = String(vnode.key);\r\n            if (el._enterCb) {\r\n                el._enterCb(true /* cancelled */);\r\n            }\r\n            if (state.isUnmounting) {\r\n                return remove();\r\n            }\r\n            callHook(onBeforeLeave, [el]);\r\n            let called = false;\r\n            const done = (el._leaveCb = (cancelled) => {\r\n                if (called)\r\n                    return;\r\n                called = true;\r\n                remove();\r\n                if (cancelled) {\r\n                    callHook(onLeaveCancelled, [el]);\r\n                }\r\n                else {\r\n                    callHook(onAfterLeave, [el]);\r\n                }\r\n                el._leaveCb = undefined;\r\n                if (leavingVNodesCache[key] === vnode) {\r\n                    delete leavingVNodesCache[key];\r\n                }\r\n            });\r\n            leavingVNodesCache[key] = vnode;\r\n            if (onLeave) {\r\n                onLeave(el, done);\r\n                if (onLeave.length <= 1) {\r\n                    done();\r\n                }\r\n            }\r\n            else {\r\n                done();\r\n            }\r\n        },\r\n        clone(vnode) {\r\n            return resolveTransitionHooks(vnode, props, state, instance);\r\n        }\r\n    };\r\n    return hooks;\r\n}\r\n// the placeholder really only handles one special case: KeepAlive\r\n// in the case of a KeepAlive in a leave phase we need to return a KeepAlive\r\n// placeholder with empty content to avoid the KeepAlive instance from being\r\n// unmounted.\r\nfunction emptyPlaceholder(vnode) {\r\n    if (isKeepAlive(vnode)) {\r\n        vnode = cloneVNode(vnode);\r\n        vnode.children = null;\r\n        return vnode;\r\n    }\r\n}\r\nfunction getKeepAliveChild(vnode) {\r\n    return isKeepAlive(vnode)\r\n        ? vnode.children\r\n            ? vnode.children[0]\r\n            : undefined\r\n        : vnode;\r\n}\r\nfunction setTransitionHooks(vnode, hooks) {\r\n    if (vnode.shapeFlag & 6 /* COMPONENT */ && vnode.component) {\r\n        setTransitionHooks(vnode.component.subTree, hooks);\r\n    }\r\n    else if ( vnode.shapeFlag & 128 /* SUSPENSE */) {\r\n        vnode.ssContent.transition = hooks.clone(vnode.ssContent);\r\n        vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);\r\n    }\r\n    else {\r\n        vnode.transition = hooks;\r\n    }\r\n}\r\nfunction getTransitionRawChildren(children, keepComment = false) {\r\n    let ret = [];\r\n    let keyedFragmentCount = 0;\r\n    for (let i = 0; i < children.length; i++) {\r\n        const child = children[i];\r\n        // handle fragment children case, e.g. v-for\r\n        if (child.type === Fragment) {\r\n            if (child.patchFlag & 128 /* KEYED_FRAGMENT */)\r\n                keyedFragmentCount++;\r\n            ret = ret.concat(getTransitionRawChildren(child.children, keepComment));\r\n        }\r\n        // comment placeholders should be skipped, e.g. v-if\r\n        else if (keepComment || child.type !== Comment) {\r\n            ret.push(child);\r\n        }\r\n    }\r\n    // #1126 if a transition children list contains multiple sub fragments, these\r\n    // fragments will be merged into a flat children array. Since each v-for\r\n    // fragment may contain different static bindings inside, we need to de-top\r\n    // these children to force full diffs to ensure correct behavior.\r\n    if (keyedFragmentCount > 1) {\r\n        for (let i = 0; i < ret.length; i++) {\r\n            ret[i].patchFlag = -2 /* BAIL */;\r\n        }\r\n    }\r\n    return ret;\r\n}\n\nconst isKeepAlive = (vnode) => vnode.type.__isKeepAlive;\r\nconst KeepAliveImpl = {\r\n    name: `KeepAlive`,\r\n    // Marker for special handling inside the renderer. We are not using a ===\r\n    // check directly on KeepAlive in the renderer, because importing it directly\r\n    // would prevent it from being tree-shaken.\r\n    __isKeepAlive: true,\r\n    inheritRef: true,\r\n    props: {\r\n        include: [String, RegExp, Array],\r\n        exclude: [String, RegExp, Array],\r\n        max: [String, Number]\r\n    },\r\n    setup(props, { slots }) {\r\n        const cache = new Map();\r\n        const keys = new Set();\r\n        let current = null;\r\n        const instance = getCurrentInstance();\r\n        const parentSuspense = instance.suspense;\r\n        // KeepAlive communicates with the instantiated renderer via the\r\n        // ctx where the renderer passes in its internals,\r\n        // and the KeepAlive instance exposes activate/deactivate implementations.\r\n        // The whole point of this is to avoid importing KeepAlive directly in the\r\n        // renderer to facilitate tree-shaking.\r\n        const sharedContext = instance.ctx;\r\n        const { renderer: { p: patch, m: move, um: _unmount, o: { createElement } } } = sharedContext;\r\n        const storageContainer = createElement('div');\r\n        sharedContext.activate = (vnode, container, anchor, isSVG, optimized) => {\r\n            const instance = vnode.component;\r\n            move(vnode, container, anchor, 0 /* ENTER */, parentSuspense);\r\n            // in case props have changed\r\n            patch(instance.vnode, vnode, container, anchor, instance, parentSuspense, isSVG, optimized);\r\n            queuePostRenderEffect(() => {\r\n                instance.isDeactivated = false;\r\n                if (instance.a) {\r\n                    invokeArrayFns(instance.a);\r\n                }\r\n                const vnodeHook = vnode.props && vnode.props.onVnodeMounted;\r\n                if (vnodeHook) {\r\n                    invokeVNodeHook(vnodeHook, instance.parent, vnode);\r\n                }\r\n            }, parentSuspense);\r\n        };\r\n        sharedContext.deactivate = (vnode) => {\r\n            const instance = vnode.component;\r\n            move(vnode, storageContainer, null, 1 /* LEAVE */, parentSuspense);\r\n            queuePostRenderEffect(() => {\r\n                if (instance.da) {\r\n                    invokeArrayFns(instance.da);\r\n                }\r\n                const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;\r\n                if (vnodeHook) {\r\n                    invokeVNodeHook(vnodeHook, instance.parent, vnode);\r\n                }\r\n                instance.isDeactivated = true;\r\n            }, parentSuspense);\r\n        };\r\n        function unmount(vnode) {\r\n            // reset the shapeFlag so it can be properly unmounted\r\n            resetShapeFlag(vnode);\r\n            _unmount(vnode, instance, parentSuspense);\r\n        }\r\n        function pruneCache(filter) {\r\n            cache.forEach((vnode, key) => {\r\n                const name = getName(vnode.type);\r\n                if (name && (!filter || !filter(name))) {\r\n                    pruneCacheEntry(key);\r\n                }\r\n            });\r\n        }\r\n        function pruneCacheEntry(key) {\r\n            const cached = cache.get(key);\r\n            if (!current || cached.type !== current.type) {\r\n                unmount(cached);\r\n            }\r\n            else if (current) {\r\n                // current active instance should no longer be kept-alive.\r\n                // we can't unmount it now but it might be later, so reset its flag now.\r\n                resetShapeFlag(current);\r\n            }\r\n            cache.delete(key);\r\n            keys.delete(key);\r\n        }\r\n        // prune cache on include/exclude prop change\r\n        watch(() => [props.include, props.exclude], ([include, exclude]) => {\r\n            include && pruneCache(name => matches(include, name));\r\n            exclude && pruneCache(name => !matches(exclude, name));\r\n        }, \r\n        // prune post-render after `current` has been updated\r\n        { flush: 'post' });\r\n        // cache sub tree after render\r\n        let pendingCacheKey = null;\r\n        const cacheSubtree = () => {\r\n            // fix #1621, the pendingCacheKey could be 0\r\n            if (pendingCacheKey != null) {\r\n                cache.set(pendingCacheKey, getInnerChild(instance.subTree));\r\n            }\r\n        };\r\n        onMounted(cacheSubtree);\r\n        onUpdated(cacheSubtree);\r\n        onBeforeUnmount(() => {\r\n            cache.forEach(cached => {\r\n                const { subTree, suspense } = instance;\r\n                const vnode = getInnerChild(subTree);\r\n                if (cached.type === vnode.type) {\r\n                    // current instance will be unmounted as part of keep-alive's unmount\r\n                    resetShapeFlag(vnode);\r\n                    // but invoke its deactivated hook here\r\n                    const da = vnode.component.da;\r\n                    da && queuePostRenderEffect(da, suspense);\r\n                    return;\r\n                }\r\n                unmount(cached);\r\n            });\r\n        });\r\n        return () => {\r\n            pendingCacheKey = null;\r\n            if (!slots.default) {\r\n                return null;\r\n            }\r\n            const children = slots.default();\r\n            const rawVNode = children[0];\r\n            if (children.length > 1) {\r\n                if ((process.env.NODE_ENV !== 'production')) {\r\n                    warn(`KeepAlive should contain exactly one component child.`);\r\n                }\r\n                current = null;\r\n                return children;\r\n            }\r\n            else if (!isVNode(rawVNode) ||\r\n                (!(rawVNode.shapeFlag & 4 /* STATEFUL_COMPONENT */) &&\r\n                    !(rawVNode.shapeFlag & 128 /* SUSPENSE */))) {\r\n                current = null;\r\n                return rawVNode;\r\n            }\r\n            let vnode = getInnerChild(rawVNode);\r\n            const comp = vnode.type;\r\n            const name = getName(comp);\r\n            const { include, exclude, max } = props;\r\n            if ((include && (!name || !matches(include, name))) ||\r\n                (exclude && name && matches(exclude, name))) {\r\n                current = vnode;\r\n                return rawVNode;\r\n            }\r\n            const key = vnode.key == null ? comp : vnode.key;\r\n            const cachedVNode = cache.get(key);\r\n            // clone vnode if it's reused because we are going to mutate it\r\n            if (vnode.el) {\r\n                vnode = cloneVNode(vnode);\r\n                if (rawVNode.shapeFlag & 128 /* SUSPENSE */) {\r\n                    rawVNode.ssContent = vnode;\r\n                }\r\n            }\r\n            // #1513 it's possible for the returned vnode to be cloned due to attr\r\n            // fallthrough or scopeId, so the vnode here may not be the final vnode\r\n            // that is mounted. Instead of caching it directly, we store the pending\r\n            // key and cache `instance.subTree` (the normalized vnode) in\r\n            // beforeMount/beforeUpdate hooks.\r\n            pendingCacheKey = key;\r\n            if (cachedVNode) {\r\n                // copy over mounted state\r\n                vnode.el = cachedVNode.el;\r\n                vnode.component = cachedVNode.component;\r\n                if (vnode.transition) {\r\n                    // recursively update transition hooks on subTree\r\n                    setTransitionHooks(vnode, vnode.transition);\r\n                }\r\n                // avoid vnode being mounted as fresh\r\n                vnode.shapeFlag |= 512 /* COMPONENT_KEPT_ALIVE */;\r\n                // make this key the freshest\r\n                keys.delete(key);\r\n                keys.add(key);\r\n            }\r\n            else {\r\n                keys.add(key);\r\n                // prune oldest entry\r\n                if (max && keys.size > parseInt(max, 10)) {\r\n                    pruneCacheEntry(keys.values().next().value);\r\n                }\r\n            }\r\n            // avoid vnode being unmounted\r\n            vnode.shapeFlag |= 256 /* COMPONENT_SHOULD_KEEP_ALIVE */;\r\n            current = vnode;\r\n            return rawVNode;\r\n        };\r\n    }\r\n};\r\n// export the public type for h/tsx inference\r\n// also to avoid inline import() in generated d.ts files\r\nconst KeepAlive = KeepAliveImpl;\r\nfunction getName(comp) {\r\n    return comp.displayName || comp.name;\r\n}\r\nfunction matches(pattern, name) {\r\n    if (isArray(pattern)) {\r\n        return pattern.some((p) => matches(p, name));\r\n    }\r\n    else if (isString(pattern)) {\r\n        return pattern.split(',').indexOf(name) > -1;\r\n    }\r\n    else if (pattern.test) {\r\n        return pattern.test(name);\r\n    }\r\n    /* istanbul ignore next */\r\n    return false;\r\n}\r\nfunction onActivated(hook, target) {\r\n    registerKeepAliveHook(hook, \"a\" /* ACTIVATED */, target);\r\n}\r\nfunction onDeactivated(hook, target) {\r\n    registerKeepAliveHook(hook, \"da\" /* DEACTIVATED */, target);\r\n}\r\nfunction registerKeepAliveHook(hook, type, target = currentInstance) {\r\n    // cache the deactivate branch check wrapper for injected hooks so the same\r\n    // hook can be properly deduped by the scheduler. \"__wdc\" stands for \"with\r\n    // deactivation check\".\r\n    const wrappedHook = hook.__wdc ||\r\n        (hook.__wdc = () => {\r\n            // only fire the hook if the target instance is NOT in a deactivated branch.\r\n            let current = target;\r\n            while (current) {\r\n                if (current.isDeactivated) {\r\n                    return;\r\n                }\r\n                current = current.parent;\r\n            }\r\n            hook();\r\n        });\r\n    injectHook(type, wrappedHook, target);\r\n    // In addition to registering it on the target instance, we walk up the parent\r\n    // chain and register it on all ancestor instances that are keep-alive roots.\r\n    // This avoids the need to walk the entire component tree when invoking these\r\n    // hooks, and more importantly, avoids the need to track child components in\r\n    // arrays.\r\n    if (target) {\r\n        let current = target.parent;\r\n        while (current && current.parent) {\r\n            if (isKeepAlive(current.parent.vnode)) {\r\n                injectToKeepAliveRoot(wrappedHook, type, target, current);\r\n            }\r\n            current = current.parent;\r\n        }\r\n    }\r\n}\r\nfunction injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {\r\n    // injectHook wraps the original for error handling, so make sure to remove\r\n    // the wrapped version.\r\n    const injected = injectHook(type, hook, keepAliveRoot, true /* prepend */);\r\n    onUnmounted(() => {\r\n        remove(keepAliveRoot[type], injected);\r\n    }, target);\r\n}\r\nfunction resetShapeFlag(vnode) {\r\n    let shapeFlag = vnode.shapeFlag;\r\n    if (shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */) {\r\n        shapeFlag -= 256 /* COMPONENT_SHOULD_KEEP_ALIVE */;\r\n    }\r\n    if (shapeFlag & 512 /* COMPONENT_KEPT_ALIVE */) {\r\n        shapeFlag -= 512 /* COMPONENT_KEPT_ALIVE */;\r\n    }\r\n    vnode.shapeFlag = shapeFlag;\r\n}\r\nfunction getInnerChild(vnode) {\r\n    return vnode.shapeFlag & 128 /* SUSPENSE */ ? vnode.ssContent : vnode;\r\n}\n\nconst isInternalKey = (key) => key[0] === '_' || key === '$stable';\r\nconst normalizeSlotValue = (value) => isArray(value)\r\n    ? value.map(normalizeVNode)\r\n    : [normalizeVNode(value)];\r\nconst normalizeSlot = (key, rawSlot, ctx) => withCtx((props) => {\r\n    if ((process.env.NODE_ENV !== 'production') && currentInstance) {\r\n        warn(`Slot \"${key}\" invoked outside of the render function: ` +\r\n            `this will not track dependencies used in the slot. ` +\r\n            `Invoke the slot function inside the render function instead.`);\r\n    }\r\n    return normalizeSlotValue(rawSlot(props));\r\n}, ctx);\r\nconst normalizeObjectSlots = (rawSlots, slots) => {\r\n    const ctx = rawSlots._ctx;\r\n    for (const key in rawSlots) {\r\n        if (isInternalKey(key))\r\n            continue;\r\n        const value = rawSlots[key];\r\n        if (isFunction(value)) {\r\n            slots[key] = normalizeSlot(key, value, ctx);\r\n        }\r\n        else if (value != null) {\r\n            if ((process.env.NODE_ENV !== 'production')) {\r\n                warn(`Non-function value encountered for slot \"${key}\". ` +\r\n                    `Prefer function slots for better performance.`);\r\n            }\r\n            const normalized = normalizeSlotValue(value);\r\n            slots[key] = () => normalized;\r\n        }\r\n    }\r\n};\r\nconst normalizeVNodeSlots = (instance, children) => {\r\n    if ((process.env.NODE_ENV !== 'production') && !isKeepAlive(instance.vnode)) {\r\n        warn(`Non-function value encountered for default slot. ` +\r\n            `Prefer function slots for better performance.`);\r\n    }\r\n    const normalized = normalizeSlotValue(children);\r\n    instance.slots.default = () => normalized;\r\n};\r\nconst initSlots = (instance, children) => {\r\n    if (instance.vnode.shapeFlag & 32 /* SLOTS_CHILDREN */) {\r\n        const type = children._;\r\n        if (type) {\r\n            instance.slots = children;\r\n            // make compiler marker non-enumerable\r\n            def(children, '_', type);\r\n        }\r\n        else {\r\n            normalizeObjectSlots(children, (instance.slots = {}));\r\n        }\r\n    }\r\n    else {\r\n        instance.slots = {};\r\n        if (children) {\r\n            normalizeVNodeSlots(instance, children);\r\n        }\r\n    }\r\n    def(instance.slots, InternalObjectKey, 1);\r\n};\r\nconst updateSlots = (instance, children) => {\r\n    const { vnode, slots } = instance;\r\n    let needDeletionCheck = true;\r\n    let deletionComparisonTarget = EMPTY_OBJ;\r\n    if (vnode.shapeFlag & 32 /* SLOTS_CHILDREN */) {\r\n        const type = children._;\r\n        if (type) {\r\n            // compiled slots.\r\n            if ((process.env.NODE_ENV !== 'production') && isHmrUpdating) {\r\n                // Parent was HMR updated so slot content may have changed.\r\n                // force update slots and mark instance for hmr as well\r\n                extend(slots, children);\r\n            }\r\n            else if (type === 1 /* STABLE */) {\r\n                // compiled AND stable.\r\n                // no need to update, and skip stale slots removal.\r\n                needDeletionCheck = false;\r\n            }\r\n            else {\r\n                // compiled but dynamic (v-if/v-for on slots) - update slots, but skip\r\n                // normalization.\r\n                extend(slots, children);\r\n            }\r\n        }\r\n        else {\r\n            needDeletionCheck = !children.$stable;\r\n            normalizeObjectSlots(children, slots);\r\n        }\r\n        deletionComparisonTarget = children;\r\n    }\r\n    else if (children) {\r\n        // non slot object children (direct value) passed to a component\r\n        normalizeVNodeSlots(instance, children);\r\n        deletionComparisonTarget = { default: 1 };\r\n    }\r\n    // delete stale slots\r\n    if (needDeletionCheck) {\r\n        for (const key in slots) {\r\n            if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {\r\n                delete slots[key];\r\n            }\r\n        }\r\n    }\r\n};\n\n/**\r\nRuntime helper for applying directives to a vnode. Example usage:\r\n\nconst comp = resolveComponent('comp')\r\nconst foo = resolveDirective('foo')\r\nconst bar = resolveDirective('bar')\r\n\nreturn withDirectives(h(comp), [\r\n  [foo, this.x],\r\n  [bar, this.y]\r\n])\r\n*/\r\nconst isBuiltInDirective = /*#__PURE__*/ makeMap('bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text');\r\nfunction validateDirectiveName(name) {\r\n    if (isBuiltInDirective(name)) {\r\n        warn('Do not use built-in directive ids as custom directive id: ' + name);\r\n    }\r\n}\r\n/**\r\n * Adds directives to a VNode.\r\n */\r\nfunction withDirectives(vnode, directives) {\r\n    const internalInstance = currentRenderingInstance;\r\n    if (internalInstance === null) {\r\n        (process.env.NODE_ENV !== 'production') && warn(`withDirectives can only be used inside render functions.`);\r\n        return vnode;\r\n    }\r\n    const instance = internalInstance.proxy;\r\n    const bindings = vnode.dirs || (vnode.dirs = []);\r\n    for (let i = 0; i < directives.length; i++) {\r\n        let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i];\r\n        if (isFunction(dir)) {\r\n            dir = {\r\n                mounted: dir,\r\n                updated: dir\r\n            };\r\n        }\r\n        bindings.push({\r\n            dir,\r\n            instance,\r\n            value,\r\n            oldValue: void 0,\r\n            arg,\r\n            modifiers\r\n        });\r\n    }\r\n    return vnode;\r\n}\r\nfunction invokeDirectiveHook(vnode, prevVNode, instance, name) {\r\n    const bindings = vnode.dirs;\r\n    const oldBindings = prevVNode && prevVNode.dirs;\r\n    for (let i = 0; i < bindings.length; i++) {\r\n        const binding = bindings[i];\r\n        if (oldBindings) {\r\n            binding.oldValue = oldBindings[i].value;\r\n        }\r\n        const hook = binding.dir[name];\r\n        if (hook) {\r\n            callWithAsyncErrorHandling(hook, instance, 8 /* DIRECTIVE_HOOK */, [\r\n                vnode.el,\r\n                binding,\r\n                vnode,\r\n                prevVNode\r\n            ]);\r\n        }\r\n    }\r\n}\n\nfunction createAppContext() {\r\n    return {\r\n        app: null,\r\n        config: {\r\n            isNativeTag: NO,\r\n            performance: false,\r\n            globalProperties: {},\r\n            optionMergeStrategies: {},\r\n            isCustomElement: NO,\r\n            errorHandler: undefined,\r\n            warnHandler: undefined\r\n        },\r\n        mixins: [],\r\n        components: {},\r\n        directives: {},\r\n        provides: Object.create(null)\r\n    };\r\n}\r\nlet uid = 0;\r\nfunction createAppAPI(render, hydrate) {\r\n    return function createApp(rootComponent, rootProps = null) {\r\n        if (rootProps != null && !isObject(rootProps)) {\r\n            (process.env.NODE_ENV !== 'production') && warn(`root props passed to app.mount() must be an object.`);\r\n            rootProps = null;\r\n        }\r\n        const context = createAppContext();\r\n        const installedPlugins = new Set();\r\n        let isMounted = false;\r\n        const app = (context.app = {\r\n            _uid: uid++,\r\n            _component: rootComponent,\r\n            _props: rootProps,\r\n            _container: null,\r\n            _context: context,\r\n            version,\r\n            get config() {\r\n                return context.config;\r\n            },\r\n            set config(v) {\r\n                if ((process.env.NODE_ENV !== 'production')) {\r\n                    warn(`app.config cannot be replaced. Modify individual options instead.`);\r\n                }\r\n            },\r\n            use(plugin, ...options) {\r\n                if (installedPlugins.has(plugin)) {\r\n                    (process.env.NODE_ENV !== 'production') && warn(`Plugin has already been applied to target app.`);\r\n                }\r\n                else if (plugin && isFunction(plugin.install)) {\r\n                    installedPlugins.add(plugin);\r\n                    plugin.install(app, ...options);\r\n                }\r\n                else if (isFunction(plugin)) {\r\n                    installedPlugins.add(plugin);\r\n                    plugin(app, ...options);\r\n                }\r\n                else if ((process.env.NODE_ENV !== 'production')) {\r\n                    warn(`A plugin must either be a function or an object with an \"install\" ` +\r\n                        `function.`);\r\n                }\r\n                return app;\r\n            },\r\n            mixin(mixin) {\r\n                if (__VUE_OPTIONS_API__) {\r\n                    if (!context.mixins.includes(mixin)) {\r\n                        context.mixins.push(mixin);\r\n                        // global mixin with props/emits de-optimizes props/emits\r\n                        // normalization caching.\r\n                        if (mixin.props || mixin.emits) {\r\n                            context.deopt = true;\r\n                        }\r\n                    }\r\n                    else if ((process.env.NODE_ENV !== 'production')) {\r\n                        warn('Mixin has already been applied to target app' +\r\n                            (mixin.name ? `: ${mixin.name}` : ''));\r\n                    }\r\n                }\r\n                else if ((process.env.NODE_ENV !== 'production')) {\r\n                    warn('Mixins are only available in builds supporting Options API');\r\n                }\r\n                return app;\r\n            },\r\n            component(name, component) {\r\n                if ((process.env.NODE_ENV !== 'production')) {\r\n                    validateComponentName(name, context.config);\r\n                }\r\n                if (!component) {\r\n                    return context.components[name];\r\n                }\r\n                if ((process.env.NODE_ENV !== 'production') && context.components[name]) {\r\n                    warn(`Component \"${name}\" has already been registered in target app.`);\r\n                }\r\n                context.components[name] = component;\r\n                return app;\r\n            },\r\n            directive(name, directive) {\r\n                if ((process.env.NODE_ENV !== 'production')) {\r\n                    validateDirectiveName(name);\r\n                }\r\n                if (!directive) {\r\n                    return context.directives[name];\r\n                }\r\n                if ((process.env.NODE_ENV !== 'production') && context.directives[name]) {\r\n                    warn(`Directive \"${name}\" has already been registered in target app.`);\r\n                }\r\n                context.directives[name] = directive;\r\n                return app;\r\n            },\r\n            mount(rootContainer, isHydrate) {\r\n                if (!isMounted) {\r\n                    const vnode = createVNode(rootComponent, rootProps);\r\n                    // store app context on the root VNode.\r\n                    // this will be set on the root instance on initial mount.\r\n                    vnode.appContext = context;\r\n                    // HMR root reload\r\n                    if ((process.env.NODE_ENV !== 'production')) {\r\n                        context.reload = () => {\r\n                            render(cloneVNode(vnode), rootContainer);\r\n                        };\r\n                    }\r\n                    if (isHydrate && hydrate) {\r\n                        hydrate(vnode, rootContainer);\r\n                    }\r\n                    else {\r\n                        render(vnode, rootContainer);\r\n                    }\r\n                    isMounted = true;\r\n                    app._container = rootContainer;\r\n                    rootContainer.__vue_app__ = app;\r\n                    if ((process.env.NODE_ENV !== 'production') || __VUE_PROD_DEVTOOLS__) {\r\n                        devtoolsInitApp(app, version);\r\n                    }\r\n                    return vnode.component.proxy;\r\n                }\r\n                else if ((process.env.NODE_ENV !== 'production')) {\r\n                    warn(`App has already been mounted.\\n` +\r\n                        `If you want to remount the same app, move your app creation logic ` +\r\n                        `into a factory function and create fresh app instances for each ` +\r\n                        `mount - e.g. \\`const createMyApp = () => createApp(App)\\``);\r\n                }\r\n            },\r\n            unmount() {\r\n                if (isMounted) {\r\n                    render(null, app._container);\r\n                    if ((process.env.NODE_ENV !== 'production') || __VUE_PROD_DEVTOOLS__) {\r\n                        devtoolsUnmountApp(app);\r\n                    }\r\n                }\r\n                else if ((process.env.NODE_ENV !== 'production')) {\r\n                    warn(`Cannot unmount an app that is not mounted.`);\r\n                }\r\n            },\r\n            provide(key, value) {\r\n                if ((process.env.NODE_ENV !== 'production') && key in context.provides) {\r\n                    warn(`App already provides property with key \"${String(key)}\". ` +\r\n                        `It will be overwritten with the new value.`);\r\n                }\r\n                // TypeScript doesn't allow symbols as index type\r\n                // https://github.com/Microsoft/TypeScript/issues/24587\r\n                context.provides[key] = value;\r\n                return app;\r\n            }\r\n        });\r\n        return app;\r\n    };\r\n}\n\nlet hasMismatch = false;\r\nconst isSVGContainer = (container) => /svg/.test(container.namespaceURI) && container.tagName !== 'foreignObject';\r\nconst isComment = (node) => node.nodeType === 8 /* COMMENT */;\r\n// Note: hydration is DOM-specific\r\n// But we have to place it in core due to tight coupling with core - splitting\r\n// it out creates a ton of unnecessary complexity.\r\n// Hydration also depends on some renderer internal logic which needs to be\r\n// passed in via arguments.\r\nfunction createHydrationFunctions(rendererInternals) {\r\n    const { mt: mountComponent, p: patch, o: { patchProp, nextSibling, parentNode, remove, insert, createComment } } = rendererInternals;\r\n    const hydrate = (vnode, container) => {\r\n        if ((process.env.NODE_ENV !== 'production') && !container.hasChildNodes()) {\r\n            warn(`Attempting to hydrate existing markup but container is empty. ` +\r\n                `Performing full mount instead.`);\r\n            patch(null, vnode, container);\r\n            return;\r\n        }\r\n        hasMismatch = false;\r\n        hydrateNode(container.firstChild, vnode, null, null);\r\n        flushPostFlushCbs();\r\n        if (hasMismatch && !false) {\r\n            // this error should show up in production\r\n            console.error(`Hydration completed but contains mismatches.`);\r\n        }\r\n    };\r\n    const hydrateNode = (node, vnode, parentComponent, parentSuspense, optimized = false) => {\r\n        const isFragmentStart = isComment(node) && node.data === '[';\r\n        const onMismatch = () => handleMismatch(node, vnode, parentComponent, parentSuspense, isFragmentStart);\r\n        const { type, ref, shapeFlag } = vnode;\r\n        const domType = node.nodeType;\r\n        vnode.el = node;\r\n        let nextNode = null;\r\n        switch (type) {\r\n            case Text:\r\n                if (domType !== 3 /* TEXT */) {\r\n                    nextNode = onMismatch();\r\n                }\r\n                else {\r\n                    if (node.data !== vnode.children) {\r\n                        hasMismatch = true;\r\n                        (process.env.NODE_ENV !== 'production') &&\r\n                            warn(`Hydration text mismatch:` +\r\n                                `\\n- Client: ${JSON.stringify(node.data)}` +\r\n                                `\\n- Server: ${JSON.stringify(vnode.children)}`);\r\n                        node.data = vnode.children;\r\n                    }\r\n                    nextNode = nextSibling(node);\r\n                }\r\n                break;\r\n            case Comment:\r\n                if (domType !== 8 /* COMMENT */ || isFragmentStart) {\r\n                    nextNode = onMismatch();\r\n                }\r\n                else {\r\n                    nextNode = nextSibling(node);\r\n                }\r\n                break;\r\n            case Static:\r\n                if (domType !== 1 /* ELEMENT */) {\r\n                    nextNode = onMismatch();\r\n                }\r\n                else {\r\n                    // determine anchor, adopt content\r\n                    nextNode = node;\r\n                    // if the static vnode has its content stripped during build,\r\n                    // adopt it from the server-rendered HTML.\r\n                    const needToAdoptContent = !vnode.children.length;\r\n                    for (let i = 0; i < vnode.staticCount; i++) {\r\n                        if (needToAdoptContent)\r\n                            vnode.children += nextNode.outerHTML;\r\n                        if (i === vnode.staticCount - 1) {\r\n                            vnode.anchor = nextNode;\r\n                        }\r\n                        nextNode = nextSibling(nextNode);\r\n                    }\r\n                    return nextNode;\r\n                }\r\n                break;\r\n            case Fragment:\r\n                if (!isFragmentStart) {\r\n                    nextNode = onMismatch();\r\n                }\r\n                else {\r\n                    nextNode = hydrateFragment(node, vnode, parentComponent, parentSuspense, optimized);\r\n                }\r\n                break;\r\n            default:\r\n                if (shapeFlag & 1 /* ELEMENT */) {\r\n                    if (domType !== 1 /* ELEMENT */ ||\r\n                        vnode.type !== node.tagName.toLowerCase()) {\r\n                        nextNode = onMismatch();\r\n                    }\r\n                    else {\r\n                        nextNode = hydrateElement(node, vnode, parentComponent, parentSuspense, optimized);\r\n                    }\r\n                }\r\n                else if (shapeFlag & 6 /* COMPONENT */) {\r\n                    // when setting up the render effect, if the initial vnode already\r\n                    // has .el set, the component will perform hydration instead of mount\r\n                    // on its sub-tree.\r\n                    const container = parentNode(node);\r\n                    const hydrateComponent = () => {\r\n                        mountComponent(vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), optimized);\r\n                    };\r\n                    // async component\r\n                    const loadAsync = vnode.type.__asyncLoader;\r\n                    if (loadAsync) {\r\n                        loadAsync().then(hydrateComponent);\r\n                    }\r\n                    else {\r\n                        hydrateComponent();\r\n                    }\r\n                    // component may be async, so in the case of fragments we cannot rely\r\n                    // on component's rendered output to determine the end of the fragment\r\n                    // instead, we do a lookahead to find the end anchor node.\r\n                    nextNode = isFragmentStart\r\n                        ? locateClosingAsyncAnchor(node)\r\n                        : nextSibling(node);\r\n                }\r\n                else if (shapeFlag & 64 /* TELEPORT */) {\r\n                    if (domType !== 8 /* COMMENT */) {\r\n                        nextNode = onMismatch();\r\n                    }\r\n                    else {\r\n                        nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, optimized, rendererInternals, hydrateChildren);\r\n                    }\r\n                }\r\n                else if ( shapeFlag & 128 /* SUSPENSE */) {\r\n                    nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, isSVGContainer(parentNode(node)), optimized, rendererInternals, hydrateNode);\r\n                }\r\n                else if ((process.env.NODE_ENV !== 'production')) {\r\n                    warn('Invalid HostVNode type:', type, `(${typeof type})`);\r\n                }\r\n        }\r\n        if (ref != null && parentComponent) {\r\n            setRef(ref, null, parentComponent, parentSuspense, vnode);\r\n        }\r\n        return nextNode;\r\n    };\r\n    const hydrateElement = (el, vnode, parentComponent, parentSuspense, optimized) => {\r\n        optimized = optimized || !!vnode.dynamicChildren;\r\n        const { props, patchFlag, shapeFlag, dirs } = vnode;\r\n        // skip props & children if this is hoisted static nodes\r\n        if (patchFlag !== -1 /* HOISTED */) {\r\n            if (dirs) {\r\n                invokeDirectiveHook(vnode, null, parentComponent, 'created');\r\n            }\r\n            // props\r\n            if (props) {\r\n                if (!optimized ||\r\n                    (patchFlag & 16 /* FULL_PROPS */ ||\r\n                        patchFlag & 32 /* HYDRATE_EVENTS */)) {\r\n                    for (const key in props) {\r\n                        if (!isReservedProp(key) && isOn(key)) {\r\n                            patchProp(el, key, null, props[key]);\r\n                        }\r\n                    }\r\n                }\r\n                else if (props.onClick) {\r\n                    // Fast path for click listeners (which is most often) to avoid\r\n                    // iterating through props.\r\n                    patchProp(el, 'onClick', null, props.onClick);\r\n                }\r\n            }\r\n            // vnode / directive hooks\r\n            let vnodeHooks;\r\n            if ((vnodeHooks = props && props.onVnodeBeforeMount)) {\r\n                invokeVNodeHook(vnodeHooks, parentComponent, vnode);\r\n            }\r\n            if (dirs) {\r\n                invokeDirectiveHook(vnode, null, parentComponent, 'beforeMount');\r\n            }\r\n            if ((vnodeHooks = props && props.onVnodeMounted) || dirs) {\r\n                queueEffectWithSuspense(() => {\r\n                    vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);\r\n                    dirs && invokeDirectiveHook(vnode, null, parentComponent, 'mounted');\r\n                }, parentSuspense);\r\n            }\r\n            // children\r\n            if (shapeFlag & 16 /* ARRAY_CHILDREN */ &&\r\n                // skip if element has innerHTML / textContent\r\n                !(props && (props.innerHTML || props.textContent))) {\r\n                let next = hydrateChildren(el.firstChild, vnode, el, parentComponent, parentSuspense, optimized);\r\n                let hasWarned = false;\r\n                while (next) {\r\n                    hasMismatch = true;\r\n                    if ((process.env.NODE_ENV !== 'production') && !hasWarned) {\r\n                        warn(`Hydration children mismatch in <${vnode.type}>: ` +\r\n                            `server rendered element contains more child nodes than client vdom.`);\r\n                        hasWarned = true;\r\n                    }\r\n                    // The SSRed DOM contains more nodes than it should. Remove them.\r\n                    const cur = next;\r\n                    next = next.nextSibling;\r\n                    remove(cur);\r\n                }\r\n            }\r\n            else if (shapeFlag & 8 /* TEXT_CHILDREN */) {\r\n                if (el.textContent !== vnode.children) {\r\n                    hasMismatch = true;\r\n                    (process.env.NODE_ENV !== 'production') &&\r\n                        warn(`Hydration text content mismatch in <${vnode.type}>:\\n` +\r\n                            `- Client: ${el.textContent}\\n` +\r\n                            `- Server: ${vnode.children}`);\r\n                    el.textContent = vnode.children;\r\n                }\r\n            }\r\n        }\r\n        return el.nextSibling;\r\n    };\r\n    const hydrateChildren = (node, parentVNode, container, parentComponent, parentSuspense, optimized) => {\r\n        optimized = optimized || !!parentVNode.dynamicChildren;\r\n        const children = parentVNode.children;\r\n        const l = children.length;\r\n        let hasWarned = false;\r\n        for (let i = 0; i < l; i++) {\r\n            const vnode = optimized\r\n                ? children[i]\r\n                : (children[i] = normalizeVNode(children[i]));\r\n            if (node) {\r\n                node = hydrateNode(node, vnode, parentComponent, parentSuspense, optimized);\r\n            }\r\n            else {\r\n                hasMismatch = true;\r\n                if ((process.env.NODE_ENV !== 'production') && !hasWarned) {\r\n                    warn(`Hydration children mismatch in <${container.tagName.toLowerCase()}>: ` +\r\n                        `server rendered element contains fewer child nodes than client vdom.`);\r\n                    hasWarned = true;\r\n                }\r\n                // the SSRed DOM didn't contain enough nodes. Mount the missing ones.\r\n                patch(null, vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container));\r\n            }\r\n        }\r\n        return node;\r\n    };\r\n    const hydrateFragment = (node, vnode, parentComponent, parentSuspense, optimized) => {\r\n        const container = parentNode(node);\r\n        const next = hydrateChildren(nextSibling(node), vnode, container, parentComponent, parentSuspense, optimized);\r\n        if (next && isComment(next) && next.data === ']') {\r\n            return nextSibling((vnode.anchor = next));\r\n        }\r\n        else {\r\n            // fragment didn't hydrate successfully, since we didn't get a end anchor\r\n            // back. This should have led to node/children mismatch warnings.\r\n            hasMismatch = true;\r\n            // since the anchor is missing, we need to create one and insert it\r\n            insert((vnode.anchor = createComment(`]`)), container, next);\r\n            return next;\r\n        }\r\n    };\r\n    const handleMismatch = (node, vnode, parentComponent, parentSuspense, isFragment) => {\r\n        hasMismatch = true;\r\n        (process.env.NODE_ENV !== 'production') &&\r\n            warn(`Hydration node mismatch:\\n- Client vnode:`, vnode.type, `\\n- Server rendered DOM:`, node, node.nodeType === 3 /* TEXT */\r\n                ? `(text)`\r\n                : isComment(node) && node.data === '['\r\n                    ? `(start of fragment)`\r\n                    : ``);\r\n        vnode.el = null;\r\n        if (isFragment) {\r\n            // remove excessive fragment nodes\r\n            const end = locateClosingAsyncAnchor(node);\r\n            while (true) {\r\n                const next = nextSibling(node);\r\n                if (next && next !== end) {\r\n                    remove(next);\r\n                }\r\n                else {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        const next = nextSibling(node);\r\n        const container = parentNode(node);\r\n        remove(node);\r\n        patch(null, vnode, container, next, parentComponent, parentSuspense, isSVGContainer(container));\r\n        return next;\r\n    };\r\n    const locateClosingAsyncAnchor = (node) => {\r\n        let match = 0;\r\n        while (node) {\r\n            node = nextSibling(node);\r\n            if (node && isComment(node)) {\r\n                if (node.data === '[')\r\n                    match++;\r\n                if (node.data === ']') {\r\n                    if (match === 0) {\r\n                        return nextSibling(node);\r\n                    }\r\n                    else {\r\n                        match--;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return node;\r\n    };\r\n    return [hydrate, hydrateNode];\r\n}\n\nlet supported;\r\nlet perf;\r\nfunction startMeasure(instance, type) {\r\n    if (instance.appContext.config.performance && isSupported()) {\r\n        perf.mark(`vue-${type}-${instance.uid}`);\r\n    }\r\n}\r\nfunction endMeasure(instance, type) {\r\n    if (instance.appContext.config.performance && isSupported()) {\r\n        const startTag = `vue-${type}-${instance.uid}`;\r\n        const endTag = startTag + `:end`;\r\n        perf.mark(endTag);\r\n        perf.measure(`<${formatComponentName(instance, instance.type)}> ${type}`, startTag, endTag);\r\n        perf.clearMarks(startTag);\r\n        perf.clearMarks(endTag);\r\n    }\r\n}\r\nfunction isSupported() {\r\n    if (supported !== undefined) {\r\n        return supported;\r\n    }\r\n    /* eslint-disable no-restricted-globals */\r\n    if (typeof window !== 'undefined' && window.performance) {\r\n        supported = true;\r\n        perf = window.performance;\r\n    }\r\n    else {\r\n        supported = false;\r\n    }\r\n    /* eslint-enable no-restricted-globals */\r\n    return supported;\r\n}\n\n/**\r\n * This is only called in esm-bundler builds.\r\n * It is called when a renderer is created, in `baseCreateRenderer` so that\r\n * importing runtime-core is side-effects free.\r\n *\r\n * istanbul-ignore-next\r\n */\r\nfunction initFeatureFlags() {\r\n    let needWarn = false;\r\n    if (typeof __VUE_OPTIONS_API__ !== 'boolean') {\r\n        needWarn = true;\r\n        getGlobalThis().__VUE_OPTIONS_API__ = true;\r\n    }\r\n    if (typeof __VUE_PROD_DEVTOOLS__ !== 'boolean') {\r\n        needWarn = true;\r\n        getGlobalThis().__VUE_PROD_DEVTOOLS__ = false;\r\n    }\r\n    if ((process.env.NODE_ENV !== 'production') && needWarn) {\r\n        console.warn(`You are running the esm-bundler build of Vue. It is recommended to ` +\r\n            `configure your bundler to explicitly replace feature flag globals ` +\r\n            `with boolean literals to get proper tree-shaking in the final bundle. ` +\r\n            `See http://link.vuejs.org/feature-flags for more details.`);\r\n    }\r\n}\n\nconst prodEffectOptions = {\r\n    scheduler: queueJob,\r\n    // #1801, #2043 component render effects should allow recursive updates\r\n    allowRecurse: true\r\n};\r\nfunction createDevEffectOptions(instance) {\r\n    return {\r\n        scheduler: queueJob,\r\n        allowRecurse: true,\r\n        onTrack: instance.rtc ? e => invokeArrayFns(instance.rtc, e) : void 0,\r\n        onTrigger: instance.rtg ? e => invokeArrayFns(instance.rtg, e) : void 0\r\n    };\r\n}\r\nconst queuePostRenderEffect =  queueEffectWithSuspense\r\n    ;\r\nconst setRef = (rawRef, oldRawRef, parentComponent, parentSuspense, vnode) => {\r\n    if (isArray(rawRef)) {\r\n        rawRef.forEach((r, i) => setRef(r, oldRawRef && (isArray(oldRawRef) ? oldRawRef[i] : oldRawRef), parentComponent, parentSuspense, vnode));\r\n        return;\r\n    }\r\n    let value;\r\n    if (!vnode) {\r\n        value = null;\r\n    }\r\n    else {\r\n        if (vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */) {\r\n            value = vnode.component.proxy;\r\n        }\r\n        else {\r\n            value = vnode.el;\r\n        }\r\n    }\r\n    const { i: owner, r: ref } = rawRef;\r\n    if ((process.env.NODE_ENV !== 'production') && !owner) {\r\n        warn(`Missing ref owner context. ref cannot be used on hoisted vnodes. ` +\r\n            `A vnode with ref must be created inside the render function.`);\r\n        return;\r\n    }\r\n    const oldRef = oldRawRef && oldRawRef.r;\r\n    const refs = owner.refs === EMPTY_OBJ ? (owner.refs = {}) : owner.refs;\r\n    const setupState = owner.setupState;\r\n    // unset old ref\r\n    if (oldRef != null && oldRef !== ref) {\r\n        if (isString(oldRef)) {\r\n            refs[oldRef] = null;\r\n            if (hasOwn(setupState, oldRef)) {\r\n                setupState[oldRef] = null;\r\n            }\r\n        }\r\n        else if (isRef(oldRef)) {\r\n            oldRef.value = null;\r\n        }\r\n    }\r\n    if (isString(ref)) {\r\n        const doSet = () => {\r\n            refs[ref] = value;\r\n            if (hasOwn(setupState, ref)) {\r\n                setupState[ref] = value;\r\n            }\r\n        };\r\n        // #1789: for non-null values, set them after render\r\n        // null values means this is unmount and it should not overwrite another\r\n        // ref with the same key\r\n        if (value) {\r\n            doSet.id = -1;\r\n            queuePostRenderEffect(doSet, parentSuspense);\r\n        }\r\n        else {\r\n            doSet();\r\n        }\r\n    }\r\n    else if (isRef(ref)) {\r\n        const doSet = () => {\r\n            ref.value = value;\r\n        };\r\n        if (value) {\r\n            doSet.id = -1;\r\n            queuePostRenderEffect(doSet, parentSuspense);\r\n        }\r\n        else {\r\n            doSet();\r\n        }\r\n    }\r\n    else if (isFunction(ref)) {\r\n        callWithErrorHandling(ref, parentComponent, 12 /* FUNCTION_REF */, [\r\n            value,\r\n            refs\r\n        ]);\r\n    }\r\n    else if ((process.env.NODE_ENV !== 'production')) {\r\n        warn('Invalid template ref type:', value, `(${typeof value})`);\r\n    }\r\n};\r\n/**\r\n * The createRenderer function accepts two generic arguments:\r\n * HostNode and HostElement, corresponding to Node and Element types in the\r\n * host environment. For example, for runtime-dom, HostNode would be the DOM\r\n * `Node` interface and HostElement would be the DOM `Element` interface.\r\n *\r\n * Custom renderers can pass in the platform specific types like this:\r\n *\r\n * ``` js\r\n * const { render, createApp } = createRenderer<Node, Element>({\r\n *   patchProp,\r\n *   ...nodeOps\r\n * })\r\n * ```\r\n */\r\nfunction createRenderer(options) {\r\n    return baseCreateRenderer(options);\r\n}\r\n// Separate API for creating hydration-enabled renderer.\r\n// Hydration logic is only used when calling this function, making it\r\n// tree-shakable.\r\nfunction createHydrationRenderer(options) {\r\n    return baseCreateRenderer(options, createHydrationFunctions);\r\n}\r\n// implementation\r\nfunction baseCreateRenderer(options, createHydrationFns) {\r\n    // compile-time feature flags check\r\n    {\r\n        initFeatureFlags();\r\n    }\r\n    const { insert: hostInsert, remove: hostRemove, patchProp: hostPatchProp, forcePatchProp: hostForcePatchProp, createElement: hostCreateElement, createText: hostCreateText, createComment: hostCreateComment, setText: hostSetText, setElementText: hostSetElementText, parentNode: hostParentNode, nextSibling: hostNextSibling, setScopeId: hostSetScopeId = NOOP, cloneNode: hostCloneNode, insertStaticContent: hostInsertStaticContent } = options;\r\n    // Note: functions inside this closure should use `const xxx = () => {}`\r\n    // style in order to prevent being inlined by minifiers.\r\n    const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, optimized = false) => {\r\n        // patching & not same type, unmount old tree\r\n        if (n1 && !isSameVNodeType(n1, n2)) {\r\n            anchor = getNextHostNode(n1);\r\n            unmount(n1, parentComponent, parentSuspense, true);\r\n            n1 = null;\r\n        }\r\n        if (n2.patchFlag === -2 /* BAIL */) {\r\n            optimized = false;\r\n            n2.dynamicChildren = null;\r\n        }\r\n        const { type, ref, shapeFlag } = n2;\r\n        switch (type) {\r\n            case Text:\r\n                processText(n1, n2, container, anchor);\r\n                break;\r\n            case Comment:\r\n                processCommentNode(n1, n2, container, anchor);\r\n                break;\r\n            case Static:\r\n                if (n1 == null) {\r\n                    mountStaticNode(n2, container, anchor, isSVG);\r\n                }\r\n                else if ((process.env.NODE_ENV !== 'production')) {\r\n                    patchStaticNode(n1, n2, container, isSVG);\r\n                }\r\n                break;\r\n            case Fragment:\r\n                processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\r\n                break;\r\n            default:\r\n                if (shapeFlag & 1 /* ELEMENT */) {\r\n                    processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\r\n                }\r\n                else if (shapeFlag & 6 /* COMPONENT */) {\r\n                    processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\r\n                }\r\n                else if (shapeFlag & 64 /* TELEPORT */) {\r\n                    type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized, internals);\r\n                }\r\n                else if ( shapeFlag & 128 /* SUSPENSE */) {\r\n                    type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized, internals);\r\n                }\r\n                else if ((process.env.NODE_ENV !== 'production')) {\r\n                    warn('Invalid VNode type:', type, `(${typeof type})`);\r\n                }\r\n        }\r\n        // set ref\r\n        if (ref != null && parentComponent) {\r\n            setRef(ref, n1 && n1.ref, parentComponent, parentSuspense, n2);\r\n        }\r\n    };\r\n    const processText = (n1, n2, container, anchor) => {\r\n        if (n1 == null) {\r\n            hostInsert((n2.el = hostCreateText(n2.children)), container, anchor);\r\n        }\r\n        else {\r\n            const el = (n2.el = n1.el);\r\n            if (n2.children !== n1.children) {\r\n                hostSetText(el, n2.children);\r\n            }\r\n        }\r\n    };\r\n    const processCommentNode = (n1, n2, container, anchor) => {\r\n        if (n1 == null) {\r\n            hostInsert((n2.el = hostCreateComment(n2.children || '')), container, anchor);\r\n        }\r\n        else {\r\n            // there's no support for dynamic comments\r\n            n2.el = n1.el;\r\n        }\r\n    };\r\n    const mountStaticNode = (n2, container, anchor, isSVG) => {\r\n        [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG);\r\n    };\r\n    /**\r\n     * Dev / HMR only\r\n     */\r\n    const patchStaticNode = (n1, n2, container, isSVG) => {\r\n        // static nodes are only patched during dev for HMR\r\n        if (n2.children !== n1.children) {\r\n            const anchor = hostNextSibling(n1.anchor);\r\n            // remove existing\r\n            removeStaticNode(n1);\r\n            [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG);\r\n        }\r\n        else {\r\n            n2.el = n1.el;\r\n            n2.anchor = n1.anchor;\r\n        }\r\n    };\r\n    /**\r\n     * Dev / HMR only\r\n     */\r\n    const moveStaticNode = (vnode, container, anchor) => {\r\n        let cur = vnode.el;\r\n        const end = vnode.anchor;\r\n        while (cur && cur !== end) {\r\n            const next = hostNextSibling(cur);\r\n            hostInsert(cur, container, anchor);\r\n            cur = next;\r\n        }\r\n        hostInsert(end, container, anchor);\r\n    };\r\n    /**\r\n     * Dev / HMR only\r\n     */\r\n    const removeStaticNode = (vnode) => {\r\n        let cur = vnode.el;\r\n        while (cur && cur !== vnode.anchor) {\r\n            const next = hostNextSibling(cur);\r\n            hostRemove(cur);\r\n            cur = next;\r\n        }\r\n        hostRemove(vnode.anchor);\r\n    };\r\n    const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {\r\n        isSVG = isSVG || n2.type === 'svg';\r\n        if (n1 == null) {\r\n            mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\r\n        }\r\n        else {\r\n            patchElement(n1, n2, parentComponent, parentSuspense, isSVG, optimized);\r\n        }\r\n    };\r\n    const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {\r\n        let el;\r\n        let vnodeHook;\r\n        const { type, props, shapeFlag, transition, scopeId, patchFlag, dirs } = vnode;\r\n        if (!(process.env.NODE_ENV !== 'production') &&\r\n            vnode.el &&\r\n            hostCloneNode !== undefined &&\r\n            patchFlag === -1 /* HOISTED */) {\r\n            // If a vnode has non-null el, it means it's being reused.\r\n            // Only static vnodes can be reused, so its mounted DOM nodes should be\r\n            // exactly the same, and we can simply do a clone here.\r\n            // only do this in production since cloned trees cannot be HMR updated.\r\n            el = vnode.el = hostCloneNode(vnode.el);\r\n        }\r\n        else {\r\n            el = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is);\r\n            // mount children first, since some props may rely on child content\r\n            // being already rendered, e.g. `<select value>`\r\n            if (shapeFlag & 8 /* TEXT_CHILDREN */) {\r\n                hostSetElementText(el, vnode.children);\r\n            }\r\n            else if (shapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n                mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG && type !== 'foreignObject', optimized || !!vnode.dynamicChildren);\r\n            }\r\n            if (dirs) {\r\n                invokeDirectiveHook(vnode, null, parentComponent, 'created');\r\n            }\r\n            // props\r\n            if (props) {\r\n                for (const key in props) {\r\n                    if (!isReservedProp(key)) {\r\n                        hostPatchProp(el, key, null, props[key], isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);\r\n                    }\r\n                }\r\n                if ((vnodeHook = props.onVnodeBeforeMount)) {\r\n                    invokeVNodeHook(vnodeHook, parentComponent, vnode);\r\n                }\r\n            }\r\n            // scopeId\r\n            setScopeId(el, scopeId, vnode, parentComponent);\r\n        }\r\n        if ((process.env.NODE_ENV !== 'production') || __VUE_PROD_DEVTOOLS__) {\r\n            Object.defineProperty(el, '__vnode', {\r\n                value: vnode,\r\n                enumerable: false\r\n            });\r\n            Object.defineProperty(el, '__vueParentComponent', {\r\n                value: parentComponent,\r\n                enumerable: false\r\n            });\r\n        }\r\n        if (dirs) {\r\n            invokeDirectiveHook(vnode, null, parentComponent, 'beforeMount');\r\n        }\r\n        // #1583 For inside suspense + suspense not resolved case, enter hook should call when suspense resolved\r\n        // #1689 For inside suspense + suspense resolved case, just call it\r\n        const needCallTransitionHooks = (!parentSuspense || (parentSuspense && !parentSuspense.pendingBranch)) &&\r\n            transition &&\r\n            !transition.persisted;\r\n        if (needCallTransitionHooks) {\r\n            transition.beforeEnter(el);\r\n        }\r\n        hostInsert(el, container, anchor);\r\n        if ((vnodeHook = props && props.onVnodeMounted) ||\r\n            needCallTransitionHooks ||\r\n            dirs) {\r\n            queuePostRenderEffect(() => {\r\n                vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);\r\n                needCallTransitionHooks && transition.enter(el);\r\n                dirs && invokeDirectiveHook(vnode, null, parentComponent, 'mounted');\r\n            }, parentSuspense);\r\n        }\r\n    };\r\n    const setScopeId = (el, scopeId, vnode, parentComponent) => {\r\n        if (scopeId) {\r\n            hostSetScopeId(el, scopeId);\r\n        }\r\n        if (parentComponent) {\r\n            const treeOwnerId = parentComponent.type.__scopeId;\r\n            // vnode's own scopeId and the current patched component's scopeId is\r\n            // different - this is a slot content node.\r\n            if (treeOwnerId && treeOwnerId !== scopeId) {\r\n                hostSetScopeId(el, treeOwnerId + '-s');\r\n            }\r\n            let subTree = parentComponent.subTree;\r\n            if ((process.env.NODE_ENV !== 'production') && subTree.type === Fragment) {\r\n                subTree =\r\n                    filterSingleRoot(subTree.children) || subTree;\r\n            }\r\n            if (vnode === subTree) {\r\n                setScopeId(el, parentComponent.vnode.scopeId, parentComponent.vnode, parentComponent.parent);\r\n            }\r\n        }\r\n    };\r\n    const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, optimized, start = 0) => {\r\n        for (let i = start; i < children.length; i++) {\r\n            const child = (children[i] = optimized\r\n                ? cloneIfMounted(children[i])\r\n                : normalizeVNode(children[i]));\r\n            patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\r\n        }\r\n    };\r\n    const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, optimized) => {\r\n        const el = (n2.el = n1.el);\r\n        let { patchFlag, dynamicChildren, dirs } = n2;\r\n        // #1426 take the old vnode's patch flag into account since user may clone a\r\n        // compiler-generated vnode, which de-opts to FULL_PROPS\r\n        patchFlag |= n1.patchFlag & 16 /* FULL_PROPS */;\r\n        const oldProps = n1.props || EMPTY_OBJ;\r\n        const newProps = n2.props || EMPTY_OBJ;\r\n        let vnodeHook;\r\n        if ((vnodeHook = newProps.onVnodeBeforeUpdate)) {\r\n            invokeVNodeHook(vnodeHook, parentComponent, n2, n1);\r\n        }\r\n        if (dirs) {\r\n            invokeDirectiveHook(n2, n1, parentComponent, 'beforeUpdate');\r\n        }\r\n        if ((process.env.NODE_ENV !== 'production') && (true ) && isHmrUpdating) {\r\n            // HMR updated, force full diff\r\n            patchFlag = 0;\r\n            optimized = false;\r\n            dynamicChildren = null;\r\n        }\r\n        if (patchFlag > 0) {\r\n            // the presence of a patchFlag means this element's render code was\r\n            // generated by the compiler and can take the fast path.\r\n            // in this path old node and new node are guaranteed to have the same shape\r\n            // (i.e. at the exact same position in the source template)\r\n            if (patchFlag & 16 /* FULL_PROPS */) {\r\n                // element props contain dynamic keys, full diff needed\r\n                patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);\r\n            }\r\n            else {\r\n                // class\r\n                // this flag is matched when the element has dynamic class bindings.\r\n                if (patchFlag & 2 /* CLASS */) {\r\n                    if (oldProps.class !== newProps.class) {\r\n                        hostPatchProp(el, 'class', null, newProps.class, isSVG);\r\n                    }\r\n                }\r\n                // style\r\n                // this flag is matched when the element has dynamic style bindings\r\n                if (patchFlag & 4 /* STYLE */) {\r\n                    hostPatchProp(el, 'style', oldProps.style, newProps.style, isSVG);\r\n                }\r\n                // props\r\n                // This flag is matched when the element has dynamic prop/attr bindings\r\n                // other than class and style. The keys of dynamic prop/attrs are saved for\r\n                // faster iteration.\r\n                // Note dynamic keys like :[foo]=\"bar\" will cause this optimization to\r\n                // bail out and go through a full diff because we need to unset the old key\r\n                if (patchFlag & 8 /* PROPS */) {\r\n                    // if the flag is present then dynamicProps must be non-null\r\n                    const propsToUpdate = n2.dynamicProps;\r\n                    for (let i = 0; i < propsToUpdate.length; i++) {\r\n                        const key = propsToUpdate[i];\r\n                        const prev = oldProps[key];\r\n                        const next = newProps[key];\r\n                        if (next !== prev ||\r\n                            (hostForcePatchProp && hostForcePatchProp(el, key))) {\r\n                            hostPatchProp(el, key, prev, next, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            // text\r\n            // This flag is matched when the element has only dynamic text children.\r\n            if (patchFlag & 1 /* TEXT */) {\r\n                if (n1.children !== n2.children) {\r\n                    hostSetElementText(el, n2.children);\r\n                }\r\n            }\r\n        }\r\n        else if (!optimized && dynamicChildren == null) {\r\n            // unoptimized, full diff\r\n            patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);\r\n        }\r\n        const areChildrenSVG = isSVG && n2.type !== 'foreignObject';\r\n        if (dynamicChildren) {\r\n            patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG);\r\n            if ((process.env.NODE_ENV !== 'production') &&\r\n                (true ) &&\r\n                parentComponent &&\r\n                parentComponent.type.__hmrId) {\r\n                traverseStaticChildren(n1, n2);\r\n            }\r\n        }\r\n        else if (!optimized) {\r\n            // full diff\r\n            patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG);\r\n        }\r\n        if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {\r\n            queuePostRenderEffect(() => {\r\n                vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);\r\n                dirs && invokeDirectiveHook(n2, n1, parentComponent, 'updated');\r\n            }, parentSuspense);\r\n        }\r\n    };\r\n    // The fast path for blocks.\r\n    const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG) => {\r\n        for (let i = 0; i < newChildren.length; i++) {\r\n            const oldVNode = oldChildren[i];\r\n            const newVNode = newChildren[i];\r\n            // Determine the container (parent element) for the patch.\r\n            const container = \r\n            // - In the case of a Fragment, we need to provide the actual parent\r\n            // of the Fragment itself so it can move its children.\r\n            oldVNode.type === Fragment ||\r\n                // - In the case of different nodes, there is going to be a replacement\r\n                // which also requires the correct parent container\r\n                !isSameVNodeType(oldVNode, newVNode) ||\r\n                // - In the case of a component, it could contain anything.\r\n                oldVNode.shapeFlag & 6 /* COMPONENT */ ||\r\n                oldVNode.shapeFlag & 64 /* TELEPORT */\r\n                ? hostParentNode(oldVNode.el)\r\n                : // In other cases, the parent container is not actually used so we\r\n                    // just pass the block element here to avoid a DOM parentNode call.\r\n                    fallbackContainer;\r\n            patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, true);\r\n        }\r\n    };\r\n    const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {\r\n        if (oldProps !== newProps) {\r\n            for (const key in newProps) {\r\n                if (isReservedProp(key))\r\n                    continue;\r\n                const next = newProps[key];\r\n                const prev = oldProps[key];\r\n                if (next !== prev ||\r\n                    (hostForcePatchProp && hostForcePatchProp(el, key))) {\r\n                    hostPatchProp(el, key, prev, next, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);\r\n                }\r\n            }\r\n            if (oldProps !== EMPTY_OBJ) {\r\n                for (const key in oldProps) {\r\n                    if (!isReservedProp(key) && !(key in newProps)) {\r\n                        hostPatchProp(el, key, oldProps[key], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n    const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {\r\n        const fragmentStartAnchor = (n2.el = n1 ? n1.el : hostCreateText(''));\r\n        const fragmentEndAnchor = (n2.anchor = n1 ? n1.anchor : hostCreateText(''));\r\n        let { patchFlag, dynamicChildren } = n2;\r\n        if (patchFlag > 0) {\r\n            optimized = true;\r\n        }\r\n        if ((process.env.NODE_ENV !== 'production') && isHmrUpdating) {\r\n            // HMR updated, force full diff\r\n            patchFlag = 0;\r\n            optimized = false;\r\n            dynamicChildren = null;\r\n        }\r\n        if (n1 == null) {\r\n            hostInsert(fragmentStartAnchor, container, anchor);\r\n            hostInsert(fragmentEndAnchor, container, anchor);\r\n            // a fragment can only have array children\r\n            // since they are either generated by the compiler, or implicitly created\r\n            // from arrays.\r\n            mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, optimized);\r\n        }\r\n        else {\r\n            if (patchFlag > 0 &&\r\n                patchFlag & 64 /* STABLE_FRAGMENT */ &&\r\n                dynamicChildren) {\r\n                // a stable fragment (template root or <template v-for>) doesn't need to\r\n                // patch children order, but it may contain dynamicChildren.\r\n                patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG);\r\n                if ((process.env.NODE_ENV !== 'production') && parentComponent && parentComponent.type.__hmrId) {\r\n                    traverseStaticChildren(n1, n2);\r\n                }\r\n                else if (\r\n                // #2080 if the stable fragment has a key, it's a <template v-for> that may\r\n                //  get moved around. Make sure all root level vnodes inherit el.\r\n                // #2134 or if it's a component root, it may also get moved around\r\n                // as the component is being moved.\r\n                n2.key != null ||\r\n                    (parentComponent && n2 === parentComponent.subTree)) {\r\n                    traverseStaticChildren(n1, n2, true /* shallow */);\r\n                }\r\n            }\r\n            else {\r\n                // keyed / unkeyed, or manual fragments.\r\n                // for keyed & unkeyed, since they are compiler generated from v-for,\r\n                // each child is guaranteed to be a block so the fragment will never\r\n                // have dynamicChildren.\r\n                patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, optimized);\r\n            }\r\n        }\r\n    };\r\n    const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {\r\n        if (n1 == null) {\r\n            if (n2.shapeFlag & 512 /* COMPONENT_KEPT_ALIVE */) {\r\n                parentComponent.ctx.activate(n2, container, anchor, isSVG, optimized);\r\n            }\r\n            else {\r\n                mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\r\n            }\r\n        }\r\n        else {\r\n            updateComponent(n1, n2, optimized);\r\n        }\r\n    };\r\n    const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {\r\n        const instance = (initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense));\r\n        if ((process.env.NODE_ENV !== 'production') && (true ) && instance.type.__hmrId) {\r\n            registerHMR(instance);\r\n        }\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            pushWarningContext(initialVNode);\r\n            startMeasure(instance, `mount`);\r\n        }\r\n        // inject renderer internals for keepAlive\r\n        if (isKeepAlive(initialVNode)) {\r\n            instance.ctx.renderer = internals;\r\n        }\r\n        // resolve props and slots for setup context\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            startMeasure(instance, `init`);\r\n        }\r\n        setupComponent(instance);\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            endMeasure(instance, `init`);\r\n        }\r\n        // setup() is async. This component relies on async logic to be resolved\r\n        // before proceeding\r\n        if ( instance.asyncDep) {\r\n            parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);\r\n            // Give it a placeholder if this is not hydration\r\n            // TODO handle self-defined fallback\r\n            if (!initialVNode.el) {\r\n                const placeholder = (instance.subTree = createVNode(Comment));\r\n                processCommentNode(null, placeholder, container, anchor);\r\n            }\r\n            return;\r\n        }\r\n        setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized);\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            popWarningContext();\r\n            endMeasure(instance, `mount`);\r\n        }\r\n    };\r\n    const updateComponent = (n1, n2, optimized) => {\r\n        const instance = (n2.component = n1.component);\r\n        if (shouldUpdateComponent(n1, n2, optimized)) {\r\n            if (\r\n                instance.asyncDep &&\r\n                !instance.asyncResolved) {\r\n                // async & still pending - just update props and slots\r\n                // since the component's reactive effect for render isn't set-up yet\r\n                if ((process.env.NODE_ENV !== 'production')) {\r\n                    pushWarningContext(n2);\r\n                }\r\n                updateComponentPreRender(instance, n2, optimized);\r\n                if ((process.env.NODE_ENV !== 'production')) {\r\n                    popWarningContext();\r\n                }\r\n                return;\r\n            }\r\n            else {\r\n                // normal update\r\n                instance.next = n2;\r\n                // in case the child component is also queued, remove it to avoid\r\n                // double updating the same child component in the same flush.\r\n                invalidateJob(instance.update);\r\n                // instance.update is the reactive effect runner.\r\n                instance.update();\r\n            }\r\n        }\r\n        else {\r\n            // no update needed. just copy over properties\r\n            n2.component = n1.component;\r\n            n2.el = n1.el;\r\n            instance.vnode = n2;\r\n        }\r\n    };\r\n    const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {\r\n        // create reactive effect for rendering\r\n        instance.update = effect(function componentEffect() {\r\n            if (!instance.isMounted) {\r\n                let vnodeHook;\r\n                const { el, props } = initialVNode;\r\n                const { bm, m, parent } = instance;\r\n                // beforeMount hook\r\n                if (bm) {\r\n                    invokeArrayFns(bm);\r\n                }\r\n                // onVnodeBeforeMount\r\n                if ((vnodeHook = props && props.onVnodeBeforeMount)) {\r\n                    invokeVNodeHook(vnodeHook, parent, initialVNode);\r\n                }\r\n                // render\r\n                if ((process.env.NODE_ENV !== 'production')) {\r\n                    startMeasure(instance, `render`);\r\n                }\r\n                const subTree = (instance.subTree = renderComponentRoot(instance));\r\n                if ((process.env.NODE_ENV !== 'production')) {\r\n                    endMeasure(instance, `render`);\r\n                }\r\n                if (el && hydrateNode) {\r\n                    if ((process.env.NODE_ENV !== 'production')) {\r\n                        startMeasure(instance, `hydrate`);\r\n                    }\r\n                    // vnode has adopted host node - perform hydration instead of mount.\r\n                    hydrateNode(initialVNode.el, subTree, instance, parentSuspense);\r\n                    if ((process.env.NODE_ENV !== 'production')) {\r\n                        endMeasure(instance, `hydrate`);\r\n                    }\r\n                }\r\n                else {\r\n                    if ((process.env.NODE_ENV !== 'production')) {\r\n                        startMeasure(instance, `patch`);\r\n                    }\r\n                    patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);\r\n                    if ((process.env.NODE_ENV !== 'production')) {\r\n                        endMeasure(instance, `patch`);\r\n                    }\r\n                    initialVNode.el = subTree.el;\r\n                }\r\n                // mounted hook\r\n                if (m) {\r\n                    queuePostRenderEffect(m, parentSuspense);\r\n                }\r\n                // onVnodeMounted\r\n                if ((vnodeHook = props && props.onVnodeMounted)) {\r\n                    queuePostRenderEffect(() => {\r\n                        invokeVNodeHook(vnodeHook, parent, initialVNode);\r\n                    }, parentSuspense);\r\n                }\r\n                // activated hook for keep-alive roots.\r\n                // #1742 activated hook must be accessed after first render\r\n                // since the hook may be injected by a child keep-alive\r\n                const { a } = instance;\r\n                if (a &&\r\n                    initialVNode.shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */) {\r\n                    queuePostRenderEffect(a, parentSuspense);\r\n                }\r\n                instance.isMounted = true;\r\n            }\r\n            else {\r\n                // updateComponent\r\n                // This is triggered by mutation of component's own state (next: null)\r\n                // OR parent calling processComponent (next: VNode)\r\n                let { next, bu, u, parent, vnode } = instance;\r\n                let originNext = next;\r\n                let vnodeHook;\r\n                if ((process.env.NODE_ENV !== 'production')) {\r\n                    pushWarningContext(next || instance.vnode);\r\n                }\r\n                if (next) {\r\n                    next.el = vnode.el;\r\n                    updateComponentPreRender(instance, next, optimized);\r\n                }\r\n                else {\r\n                    next = vnode;\r\n                }\r\n                // beforeUpdate hook\r\n                if (bu) {\r\n                    invokeArrayFns(bu);\r\n                }\r\n                // onVnodeBeforeUpdate\r\n                if ((vnodeHook = next.props && next.props.onVnodeBeforeUpdate)) {\r\n                    invokeVNodeHook(vnodeHook, parent, next, vnode);\r\n                }\r\n                // render\r\n                if ((process.env.NODE_ENV !== 'production')) {\r\n                    startMeasure(instance, `render`);\r\n                }\r\n                const nextTree = renderComponentRoot(instance);\r\n                if ((process.env.NODE_ENV !== 'production')) {\r\n                    endMeasure(instance, `render`);\r\n                }\r\n                const prevTree = instance.subTree;\r\n                instance.subTree = nextTree;\r\n                if ((process.env.NODE_ENV !== 'production')) {\r\n                    startMeasure(instance, `patch`);\r\n                }\r\n                patch(prevTree, nextTree, \r\n                // parent may have changed if it's in a teleport\r\n                hostParentNode(prevTree.el), \r\n                // anchor may have changed if it's in a fragment\r\n                getNextHostNode(prevTree), instance, parentSuspense, isSVG);\r\n                if ((process.env.NODE_ENV !== 'production')) {\r\n                    endMeasure(instance, `patch`);\r\n                }\r\n                next.el = nextTree.el;\r\n                if (originNext === null) {\r\n                    // self-triggered update. In case of HOC, update parent component\r\n                    // vnode el. HOC is indicated by parent instance's subTree pointing\r\n                    // to child component's vnode\r\n                    updateHOCHostEl(instance, nextTree.el);\r\n                }\r\n                // updated hook\r\n                if (u) {\r\n                    queuePostRenderEffect(u, parentSuspense);\r\n                }\r\n                // onVnodeUpdated\r\n                if ((vnodeHook = next.props && next.props.onVnodeUpdated)) {\r\n                    queuePostRenderEffect(() => {\r\n                        invokeVNodeHook(vnodeHook, parent, next, vnode);\r\n                    }, parentSuspense);\r\n                }\r\n                if ((process.env.NODE_ENV !== 'production') || __VUE_PROD_DEVTOOLS__) {\r\n                    devtoolsComponentUpdated(instance);\r\n                }\r\n                if ((process.env.NODE_ENV !== 'production')) {\r\n                    popWarningContext();\r\n                }\r\n            }\r\n        }, (process.env.NODE_ENV !== 'production') ? createDevEffectOptions(instance) : prodEffectOptions);\r\n    };\r\n    const updateComponentPreRender = (instance, nextVNode, optimized) => {\r\n        nextVNode.component = instance;\r\n        const prevProps = instance.vnode.props;\r\n        instance.vnode = nextVNode;\r\n        instance.next = null;\r\n        updateProps(instance, nextVNode.props, prevProps, optimized);\r\n        updateSlots(instance, nextVNode.children);\r\n        // props update may have triggered pre-flush watchers.\r\n        // flush them before the render update.\r\n        flushPreFlushCbs(undefined, instance.update);\r\n    };\r\n    const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized = false) => {\r\n        const c1 = n1 && n1.children;\r\n        const prevShapeFlag = n1 ? n1.shapeFlag : 0;\r\n        const c2 = n2.children;\r\n        const { patchFlag, shapeFlag } = n2;\r\n        // fast path\r\n        if (patchFlag > 0) {\r\n            if (patchFlag & 128 /* KEYED_FRAGMENT */) {\r\n                // this could be either fully-keyed or mixed (some keyed some not)\r\n                // presence of patchFlag means children are guaranteed to be arrays\r\n                patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\r\n                return;\r\n            }\r\n            else if (patchFlag & 256 /* UNKEYED_FRAGMENT */) {\r\n                // unkeyed\r\n                patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\r\n                return;\r\n            }\r\n        }\r\n        // children has 3 possibilities: text, array or no children.\r\n        if (shapeFlag & 8 /* TEXT_CHILDREN */) {\r\n            // text children fast path\r\n            if (prevShapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n                unmountChildren(c1, parentComponent, parentSuspense);\r\n            }\r\n            if (c2 !== c1) {\r\n                hostSetElementText(container, c2);\r\n            }\r\n        }\r\n        else {\r\n            if (prevShapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n                // prev children was array\r\n                if (shapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n                    // two arrays, cannot assume anything, do full diff\r\n                    patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\r\n                }\r\n                else {\r\n                    // no new children, just unmount old\r\n                    unmountChildren(c1, parentComponent, parentSuspense, true);\r\n                }\r\n            }\r\n            else {\r\n                // prev children was text OR null\r\n                // new children is array OR null\r\n                if (prevShapeFlag & 8 /* TEXT_CHILDREN */) {\r\n                    hostSetElementText(container, '');\r\n                }\r\n                // mount new if array\r\n                if (shapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n                    mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {\r\n        c1 = c1 || EMPTY_ARR;\r\n        c2 = c2 || EMPTY_ARR;\r\n        const oldLength = c1.length;\r\n        const newLength = c2.length;\r\n        const commonLength = Math.min(oldLength, newLength);\r\n        let i;\r\n        for (i = 0; i < commonLength; i++) {\r\n            const nextChild = (c2[i] = optimized\r\n                ? cloneIfMounted(c2[i])\r\n                : normalizeVNode(c2[i]));\r\n            patch(c1[i], nextChild, container, null, parentComponent, parentSuspense, isSVG, optimized);\r\n        }\r\n        if (oldLength > newLength) {\r\n            // remove old\r\n            unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);\r\n        }\r\n        else {\r\n            // mount new\r\n            mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized, commonLength);\r\n        }\r\n    };\r\n    // can be all-keyed or mixed\r\n    const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized) => {\r\n        let i = 0;\r\n        const l2 = c2.length;\r\n        let e1 = c1.length - 1; // prev ending index\r\n        let e2 = l2 - 1; // next ending index\r\n        // 1. sync from start\r\n        // (a b) c\r\n        // (a b) d e\r\n        while (i <= e1 && i <= e2) {\r\n            const n1 = c1[i];\r\n            const n2 = (c2[i] = optimized\r\n                ? cloneIfMounted(c2[i])\r\n                : normalizeVNode(c2[i]));\r\n            if (isSameVNodeType(n1, n2)) {\r\n                patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, optimized);\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n            i++;\r\n        }\r\n        // 2. sync from end\r\n        // a (b c)\r\n        // d e (b c)\r\n        while (i <= e1 && i <= e2) {\r\n            const n1 = c1[e1];\r\n            const n2 = (c2[e2] = optimized\r\n                ? cloneIfMounted(c2[e2])\r\n                : normalizeVNode(c2[e2]));\r\n            if (isSameVNodeType(n1, n2)) {\r\n                patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, optimized);\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n            e1--;\r\n            e2--;\r\n        }\r\n        // 3. common sequence + mount\r\n        // (a b)\r\n        // (a b) c\r\n        // i = 2, e1 = 1, e2 = 2\r\n        // (a b)\r\n        // c (a b)\r\n        // i = 0, e1 = -1, e2 = 0\r\n        if (i > e1) {\r\n            if (i <= e2) {\r\n                const nextPos = e2 + 1;\r\n                const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;\r\n                while (i <= e2) {\r\n                    patch(null, (c2[i] = optimized\r\n                        ? cloneIfMounted(c2[i])\r\n                        : normalizeVNode(c2[i])), container, anchor, parentComponent, parentSuspense, isSVG);\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n        // 4. common sequence + unmount\r\n        // (a b) c\r\n        // (a b)\r\n        // i = 2, e1 = 2, e2 = 1\r\n        // a (b c)\r\n        // (b c)\r\n        // i = 0, e1 = 0, e2 = -1\r\n        else if (i > e2) {\r\n            while (i <= e1) {\r\n                unmount(c1[i], parentComponent, parentSuspense, true);\r\n                i++;\r\n            }\r\n        }\r\n        // 5. unknown sequence\r\n        // [i ... e1 + 1]: a b [c d e] f g\r\n        // [i ... e2 + 1]: a b [e d c h] f g\r\n        // i = 2, e1 = 4, e2 = 5\r\n        else {\r\n            const s1 = i; // prev starting index\r\n            const s2 = i; // next starting index\r\n            // 5.1 build key:index map for newChildren\r\n            const keyToNewIndexMap = new Map();\r\n            for (i = s2; i <= e2; i++) {\r\n                const nextChild = (c2[i] = optimized\r\n                    ? cloneIfMounted(c2[i])\r\n                    : normalizeVNode(c2[i]));\r\n                if (nextChild.key != null) {\r\n                    if ((process.env.NODE_ENV !== 'production') && keyToNewIndexMap.has(nextChild.key)) {\r\n                        warn(`Duplicate keys found during update:`, JSON.stringify(nextChild.key), `Make sure keys are unique.`);\r\n                    }\r\n                    keyToNewIndexMap.set(nextChild.key, i);\r\n                }\r\n            }\r\n            // 5.2 loop through old children left to be patched and try to patch\r\n            // matching nodes & remove nodes that are no longer present\r\n            let j;\r\n            let patched = 0;\r\n            const toBePatched = e2 - s2 + 1;\r\n            let moved = false;\r\n            // used to track whether any node has moved\r\n            let maxNewIndexSoFar = 0;\r\n            // works as Map<newIndex, oldIndex>\r\n            // Note that oldIndex is offset by +1\r\n            // and oldIndex = 0 is a special value indicating the new node has\r\n            // no corresponding old node.\r\n            // used for determining longest stable subsequence\r\n            const newIndexToOldIndexMap = new Array(toBePatched);\r\n            for (i = 0; i < toBePatched; i++)\r\n                newIndexToOldIndexMap[i] = 0;\r\n            for (i = s1; i <= e1; i++) {\r\n                const prevChild = c1[i];\r\n                if (patched >= toBePatched) {\r\n                    // all new children have been patched so this can only be a removal\r\n                    unmount(prevChild, parentComponent, parentSuspense, true);\r\n                    continue;\r\n                }\r\n                let newIndex;\r\n                if (prevChild.key != null) {\r\n                    newIndex = keyToNewIndexMap.get(prevChild.key);\r\n                }\r\n                else {\r\n                    // key-less node, try to locate a key-less node of the same type\r\n                    for (j = s2; j <= e2; j++) {\r\n                        if (newIndexToOldIndexMap[j - s2] === 0 &&\r\n                            isSameVNodeType(prevChild, c2[j])) {\r\n                            newIndex = j;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                if (newIndex === undefined) {\r\n                    unmount(prevChild, parentComponent, parentSuspense, true);\r\n                }\r\n                else {\r\n                    newIndexToOldIndexMap[newIndex - s2] = i + 1;\r\n                    if (newIndex >= maxNewIndexSoFar) {\r\n                        maxNewIndexSoFar = newIndex;\r\n                    }\r\n                    else {\r\n                        moved = true;\r\n                    }\r\n                    patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, isSVG, optimized);\r\n                    patched++;\r\n                }\r\n            }\r\n            // 5.3 move and mount\r\n            // generate longest stable subsequence only when nodes have moved\r\n            const increasingNewIndexSequence = moved\r\n                ? getSequence(newIndexToOldIndexMap)\r\n                : EMPTY_ARR;\r\n            j = increasingNewIndexSequence.length - 1;\r\n            // looping backwards so that we can use last patched node as anchor\r\n            for (i = toBePatched - 1; i >= 0; i--) {\r\n                const nextIndex = s2 + i;\r\n                const nextChild = c2[nextIndex];\r\n                const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;\r\n                if (newIndexToOldIndexMap[i] === 0) {\r\n                    // mount new\r\n                    patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG);\r\n                }\r\n                else if (moved) {\r\n                    // move if:\r\n                    // There is no stable subsequence (e.g. a reverse)\r\n                    // OR current node is not among the stable sequence\r\n                    if (j < 0 || i !== increasingNewIndexSequence[j]) {\r\n                        move(nextChild, container, anchor, 2 /* REORDER */);\r\n                    }\r\n                    else {\r\n                        j--;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n    const move = (vnode, container, anchor, moveType, parentSuspense = null) => {\r\n        const { el, type, transition, children, shapeFlag } = vnode;\r\n        if (shapeFlag & 6 /* COMPONENT */) {\r\n            move(vnode.component.subTree, container, anchor, moveType);\r\n            return;\r\n        }\r\n        if ( shapeFlag & 128 /* SUSPENSE */) {\r\n            vnode.suspense.move(container, anchor, moveType);\r\n            return;\r\n        }\r\n        if (shapeFlag & 64 /* TELEPORT */) {\r\n            type.move(vnode, container, anchor, internals);\r\n            return;\r\n        }\r\n        if (type === Fragment) {\r\n            hostInsert(el, container, anchor);\r\n            for (let i = 0; i < children.length; i++) {\r\n                move(children[i], container, anchor, moveType);\r\n            }\r\n            hostInsert(vnode.anchor, container, anchor);\r\n            return;\r\n        }\r\n        // static node move can only happen when force updating HMR\r\n        if ((process.env.NODE_ENV !== 'production') && type === Static) {\r\n            moveStaticNode(vnode, container, anchor);\r\n            return;\r\n        }\r\n        // single nodes\r\n        const needTransition = moveType !== 2 /* REORDER */ &&\r\n            shapeFlag & 1 /* ELEMENT */ &&\r\n            transition;\r\n        if (needTransition) {\r\n            if (moveType === 0 /* ENTER */) {\r\n                transition.beforeEnter(el);\r\n                hostInsert(el, container, anchor);\r\n                queuePostRenderEffect(() => transition.enter(el), parentSuspense);\r\n            }\r\n            else {\r\n                const { leave, delayLeave, afterLeave } = transition;\r\n                const remove = () => hostInsert(el, container, anchor);\r\n                const performLeave = () => {\r\n                    leave(el, () => {\r\n                        remove();\r\n                        afterLeave && afterLeave();\r\n                    });\r\n                };\r\n                if (delayLeave) {\r\n                    delayLeave(el, remove, performLeave);\r\n                }\r\n                else {\r\n                    performLeave();\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            hostInsert(el, container, anchor);\r\n        }\r\n    };\r\n    const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {\r\n        const { type, props, ref, children, dynamicChildren, shapeFlag, patchFlag, dirs } = vnode;\r\n        // unset ref\r\n        if (ref != null && parentComponent) {\r\n            setRef(ref, null, parentComponent, parentSuspense, null);\r\n        }\r\n        if (shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */) {\r\n            parentComponent.ctx.deactivate(vnode);\r\n            return;\r\n        }\r\n        const shouldInvokeDirs = shapeFlag & 1 /* ELEMENT */ && dirs;\r\n        let vnodeHook;\r\n        if ((vnodeHook = props && props.onVnodeBeforeUnmount)) {\r\n            invokeVNodeHook(vnodeHook, parentComponent, vnode);\r\n        }\r\n        if (shapeFlag & 6 /* COMPONENT */) {\r\n            unmountComponent(vnode.component, parentSuspense, doRemove);\r\n        }\r\n        else {\r\n            if ( shapeFlag & 128 /* SUSPENSE */) {\r\n                vnode.suspense.unmount(parentSuspense, doRemove);\r\n                return;\r\n            }\r\n            if (shouldInvokeDirs) {\r\n                invokeDirectiveHook(vnode, null, parentComponent, 'beforeUnmount');\r\n            }\r\n            if (dynamicChildren &&\r\n                // #1153: fast path should not be taken for non-stable (v-for) fragments\r\n                (type !== Fragment ||\r\n                    (patchFlag > 0 && patchFlag & 64 /* STABLE_FRAGMENT */))) {\r\n                // fast path for block nodes: only need to unmount dynamic children.\r\n                unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);\r\n            }\r\n            else if (!optimized && shapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n                unmountChildren(children, parentComponent, parentSuspense);\r\n            }\r\n            // an unmounted teleport should always remove its children if not disabled\r\n            if (shapeFlag & 64 /* TELEPORT */ &&\r\n                (doRemove || !isTeleportDisabled(vnode.props))) {\r\n                vnode.type.remove(vnode, internals);\r\n            }\r\n            if (doRemove) {\r\n                remove(vnode);\r\n            }\r\n        }\r\n        if ((vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {\r\n            queuePostRenderEffect(() => {\r\n                vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);\r\n                shouldInvokeDirs &&\r\n                    invokeDirectiveHook(vnode, null, parentComponent, 'unmounted');\r\n            }, parentSuspense);\r\n        }\r\n    };\r\n    const remove = vnode => {\r\n        const { type, el, anchor, transition } = vnode;\r\n        if (type === Fragment) {\r\n            removeFragment(el, anchor);\r\n            return;\r\n        }\r\n        if ((process.env.NODE_ENV !== 'production') && type === Static) {\r\n            removeStaticNode(vnode);\r\n            return;\r\n        }\r\n        const performRemove = () => {\r\n            hostRemove(el);\r\n            if (transition && !transition.persisted && transition.afterLeave) {\r\n                transition.afterLeave();\r\n            }\r\n        };\r\n        if (vnode.shapeFlag & 1 /* ELEMENT */ &&\r\n            transition &&\r\n            !transition.persisted) {\r\n            const { leave, delayLeave } = transition;\r\n            const performLeave = () => leave(el, performRemove);\r\n            if (delayLeave) {\r\n                delayLeave(vnode.el, performRemove, performLeave);\r\n            }\r\n            else {\r\n                performLeave();\r\n            }\r\n        }\r\n        else {\r\n            performRemove();\r\n        }\r\n    };\r\n    const removeFragment = (cur, end) => {\r\n        // For fragments, directly remove all contained DOM nodes.\r\n        // (fragment child nodes cannot have transition)\r\n        let next;\r\n        while (cur !== end) {\r\n            next = hostNextSibling(cur);\r\n            hostRemove(cur);\r\n            cur = next;\r\n        }\r\n        hostRemove(end);\r\n    };\r\n    const unmountComponent = (instance, parentSuspense, doRemove) => {\r\n        if ((process.env.NODE_ENV !== 'production') && (true ) && instance.type.__hmrId) {\r\n            unregisterHMR(instance);\r\n        }\r\n        const { bum, effects, update, subTree, um } = instance;\r\n        // beforeUnmount hook\r\n        if (bum) {\r\n            invokeArrayFns(bum);\r\n        }\r\n        if (effects) {\r\n            for (let i = 0; i < effects.length; i++) {\r\n                stop(effects[i]);\r\n            }\r\n        }\r\n        // update may be null if a component is unmounted before its async\r\n        // setup has resolved.\r\n        if (update) {\r\n            stop(update);\r\n            unmount(subTree, instance, parentSuspense, doRemove);\r\n        }\r\n        // unmounted hook\r\n        if (um) {\r\n            queuePostRenderEffect(um, parentSuspense);\r\n        }\r\n        queuePostRenderEffect(() => {\r\n            instance.isUnmounted = true;\r\n        }, parentSuspense);\r\n        // A component with async dep inside a pending suspense is unmounted before\r\n        // its async dep resolves. This should remove the dep from the suspense, and\r\n        // cause the suspense to resolve immediately if that was the last dep.\r\n        if (\r\n            parentSuspense &&\r\n            parentSuspense.pendingBranch &&\r\n            !parentSuspense.isUnmounted &&\r\n            instance.asyncDep &&\r\n            !instance.asyncResolved &&\r\n            instance.suspenseId === parentSuspense.pendingId) {\r\n            parentSuspense.deps--;\r\n            if (parentSuspense.deps === 0) {\r\n                parentSuspense.resolve();\r\n            }\r\n        }\r\n        if ((process.env.NODE_ENV !== 'production') || __VUE_PROD_DEVTOOLS__) {\r\n            devtoolsComponentRemoved(instance);\r\n        }\r\n    };\r\n    const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {\r\n        for (let i = start; i < children.length; i++) {\r\n            unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);\r\n        }\r\n    };\r\n    const getNextHostNode = vnode => {\r\n        if (vnode.shapeFlag & 6 /* COMPONENT */) {\r\n            return getNextHostNode(vnode.component.subTree);\r\n        }\r\n        if ( vnode.shapeFlag & 128 /* SUSPENSE */) {\r\n            return vnode.suspense.next();\r\n        }\r\n        return hostNextSibling((vnode.anchor || vnode.el));\r\n    };\r\n    const render = (vnode, container) => {\r\n        if (vnode == null) {\r\n            if (container._vnode) {\r\n                unmount(container._vnode, null, null, true);\r\n            }\r\n        }\r\n        else {\r\n            patch(container._vnode || null, vnode, container);\r\n        }\r\n        flushPostFlushCbs();\r\n        container._vnode = vnode;\r\n    };\r\n    const internals = {\r\n        p: patch,\r\n        um: unmount,\r\n        m: move,\r\n        r: remove,\r\n        mt: mountComponent,\r\n        mc: mountChildren,\r\n        pc: patchChildren,\r\n        pbc: patchBlockChildren,\r\n        n: getNextHostNode,\r\n        o: options\r\n    };\r\n    let hydrate;\r\n    let hydrateNode;\r\n    if (createHydrationFns) {\r\n        [hydrate, hydrateNode] = createHydrationFns(internals);\r\n    }\r\n    return {\r\n        render,\r\n        hydrate,\r\n        createApp: createAppAPI(render, hydrate)\r\n    };\r\n}\r\nfunction invokeVNodeHook(hook, instance, vnode, prevVNode = null) {\r\n    callWithAsyncErrorHandling(hook, instance, 7 /* VNODE_HOOK */, [\r\n        vnode,\r\n        prevVNode\r\n    ]);\r\n}\r\n/**\r\n * #1156\r\n * When a component is HMR-enabled, we need to make sure that all static nodes\r\n * inside a block also inherit the DOM element from the previous tree so that\r\n * HMR updates (which are full updates) can retrieve the element for patching.\r\n *\r\n * #2080\r\n * Inside keyed `template` fragment static children, if a fragment is moved,\r\n * the children will always moved so that need inherit el form previous nodes\r\n * to ensure correct moved position.\r\n */\r\nfunction traverseStaticChildren(n1, n2, shallow = false) {\r\n    const ch1 = n1.children;\r\n    const ch2 = n2.children;\r\n    if (isArray(ch1) && isArray(ch2)) {\r\n        for (let i = 0; i < ch1.length; i++) {\r\n            // this is only called in the optimized path so array children are\r\n            // guaranteed to be vnodes\r\n            const c1 = ch1[i];\r\n            let c2 = ch2[i];\r\n            if (c2.shapeFlag & 1 /* ELEMENT */ && !c2.dynamicChildren) {\r\n                if (c2.patchFlag <= 0 || c2.patchFlag === 32 /* HYDRATE_EVENTS */) {\r\n                    c2 = ch2[i] = cloneIfMounted(ch2[i]);\r\n                    c2.el = c1.el;\r\n                }\r\n                if (!shallow)\r\n                    traverseStaticChildren(c1, c2);\r\n            }\r\n            // also inherit for comment nodes, but not placeholders (e.g. v-if which\r\n            // would have received .el during block patch)\r\n            if ((process.env.NODE_ENV !== 'production') && c2.type === Comment && !c2.el) {\r\n                c2.el = c1.el;\r\n            }\r\n        }\r\n    }\r\n}\r\n// https://en.wikipedia.org/wiki/Longest_increasing_subsequence\r\nfunction getSequence(arr) {\r\n    const p = arr.slice();\r\n    const result = [0];\r\n    let i, j, u, v, c;\r\n    const len = arr.length;\r\n    for (i = 0; i < len; i++) {\r\n        const arrI = arr[i];\r\n        if (arrI !== 0) {\r\n            j = result[result.length - 1];\r\n            if (arr[j] < arrI) {\r\n                p[i] = j;\r\n                result.push(i);\r\n                continue;\r\n            }\r\n            u = 0;\r\n            v = result.length - 1;\r\n            while (u < v) {\r\n                c = ((u + v) / 2) | 0;\r\n                if (arr[result[c]] < arrI) {\r\n                    u = c + 1;\r\n                }\r\n                else {\r\n                    v = c;\r\n                }\r\n            }\r\n            if (arrI < arr[result[u]]) {\r\n                if (u > 0) {\r\n                    p[i] = result[u - 1];\r\n                }\r\n                result[u] = i;\r\n            }\r\n        }\r\n    }\r\n    u = result.length;\r\n    v = result[u - 1];\r\n    while (u-- > 0) {\r\n        result[u] = v;\r\n        v = p[v];\r\n    }\r\n    return result;\r\n}\n\nconst isTeleport = (type) => type.__isTeleport;\r\nconst isTeleportDisabled = (props) => props && (props.disabled || props.disabled === '');\r\nconst resolveTarget = (props, select) => {\r\n    const targetSelector = props && props.to;\r\n    if (isString(targetSelector)) {\r\n        if (!select) {\r\n            (process.env.NODE_ENV !== 'production') &&\r\n                warn(`Current renderer does not support string target for Teleports. ` +\r\n                    `(missing querySelector renderer option)`);\r\n            return null;\r\n        }\r\n        else {\r\n            const target = select(targetSelector);\r\n            if (!target) {\r\n                (process.env.NODE_ENV !== 'production') &&\r\n                    warn(`Failed to locate Teleport target with selector \"${targetSelector}\". ` +\r\n                        `Note the target element must exist before the component is mounted - ` +\r\n                        `i.e. the target cannot be rendered by the component itself, and ` +\r\n                        `ideally should be outside of the entire Vue component tree.`);\r\n            }\r\n            return target;\r\n        }\r\n    }\r\n    else {\r\n        if ((process.env.NODE_ENV !== 'production') && !targetSelector && !isTeleportDisabled(props)) {\r\n            warn(`Invalid Teleport target: ${targetSelector}`);\r\n        }\r\n        return targetSelector;\r\n    }\r\n};\r\nconst TeleportImpl = {\r\n    __isTeleport: true,\r\n    process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized, internals) {\r\n        const { mc: mountChildren, pc: patchChildren, pbc: patchBlockChildren, o: { insert, querySelector, createText, createComment } } = internals;\r\n        const disabled = isTeleportDisabled(n2.props);\r\n        const { shapeFlag, children } = n2;\r\n        if (n1 == null) {\r\n            // insert anchors in the main view\r\n            const placeholder = (n2.el = (process.env.NODE_ENV !== 'production')\r\n                ? createComment('teleport start')\r\n                : createText(''));\r\n            const mainAnchor = (n2.anchor = (process.env.NODE_ENV !== 'production')\r\n                ? createComment('teleport end')\r\n                : createText(''));\r\n            insert(placeholder, container, anchor);\r\n            insert(mainAnchor, container, anchor);\r\n            const target = (n2.target = resolveTarget(n2.props, querySelector));\r\n            const targetAnchor = (n2.targetAnchor = createText(''));\r\n            if (target) {\r\n                insert(targetAnchor, target);\r\n            }\r\n            else if ((process.env.NODE_ENV !== 'production') && !disabled) {\r\n                warn('Invalid Teleport target on mount:', target, `(${typeof target})`);\r\n            }\r\n            const mount = (container, anchor) => {\r\n                // Teleport *always* has Array children. This is enforced in both the\r\n                // compiler and vnode children normalization.\r\n                if (shapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n                    mountChildren(children, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\r\n                }\r\n            };\r\n            if (disabled) {\r\n                mount(container, mainAnchor);\r\n            }\r\n            else if (target) {\r\n                mount(target, targetAnchor);\r\n            }\r\n        }\r\n        else {\r\n            // update content\r\n            n2.el = n1.el;\r\n            const mainAnchor = (n2.anchor = n1.anchor);\r\n            const target = (n2.target = n1.target);\r\n            const targetAnchor = (n2.targetAnchor = n1.targetAnchor);\r\n            const wasDisabled = isTeleportDisabled(n1.props);\r\n            const currentContainer = wasDisabled ? container : target;\r\n            const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;\r\n            if (n2.dynamicChildren) {\r\n                // fast path when the teleport happens to be a block root\r\n                patchBlockChildren(n1.dynamicChildren, n2.dynamicChildren, currentContainer, parentComponent, parentSuspense, isSVG);\r\n                // even in block tree mode we need to make sure all root-level nodes\r\n                // in the teleport inherit previous DOM references so that they can\r\n                // be moved in future patches.\r\n                traverseStaticChildren(n1, n2, true);\r\n            }\r\n            else if (!optimized) {\r\n                patchChildren(n1, n2, currentContainer, currentAnchor, parentComponent, parentSuspense, isSVG);\r\n            }\r\n            if (disabled) {\r\n                if (!wasDisabled) {\r\n                    // enabled -> disabled\r\n                    // move into main container\r\n                    moveTeleport(n2, container, mainAnchor, internals, 1 /* TOGGLE */);\r\n                }\r\n            }\r\n            else {\r\n                // target changed\r\n                if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {\r\n                    const nextTarget = (n2.target = resolveTarget(n2.props, querySelector));\r\n                    if (nextTarget) {\r\n                        moveTeleport(n2, nextTarget, null, internals, 0 /* TARGET_CHANGE */);\r\n                    }\r\n                    else if ((process.env.NODE_ENV !== 'production')) {\r\n                        warn('Invalid Teleport target on update:', target, `(${typeof target})`);\r\n                    }\r\n                }\r\n                else if (wasDisabled) {\r\n                    // disabled -> enabled\r\n                    // move into teleport target\r\n                    moveTeleport(n2, target, targetAnchor, internals, 1 /* TOGGLE */);\r\n                }\r\n            }\r\n        }\r\n    },\r\n    remove(vnode, { r: remove, o: { remove: hostRemove } }) {\r\n        const { shapeFlag, children, anchor } = vnode;\r\n        hostRemove(anchor);\r\n        if (shapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n            for (let i = 0; i < children.length; i++) {\r\n                remove(children[i]);\r\n            }\r\n        }\r\n    },\r\n    move: moveTeleport,\r\n    hydrate: hydrateTeleport\r\n};\r\nfunction moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2 /* REORDER */) {\r\n    // move target anchor if this is a target change.\r\n    if (moveType === 0 /* TARGET_CHANGE */) {\r\n        insert(vnode.targetAnchor, container, parentAnchor);\r\n    }\r\n    const { el, anchor, shapeFlag, children, props } = vnode;\r\n    const isReorder = moveType === 2 /* REORDER */;\r\n    // move main view anchor if this is a re-order.\r\n    if (isReorder) {\r\n        insert(el, container, parentAnchor);\r\n    }\r\n    // if this is a re-order and teleport is enabled (content is in target)\r\n    // do not move children. So the opposite is: only move children if this\r\n    // is not a reorder, or the teleport is disabled\r\n    if (!isReorder || isTeleportDisabled(props)) {\r\n        // Teleport has either Array children or no children.\r\n        if (shapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n            for (let i = 0; i < children.length; i++) {\r\n                move(children[i], container, parentAnchor, 2 /* REORDER */);\r\n            }\r\n        }\r\n    }\r\n    // move main view anchor if this is a re-order.\r\n    if (isReorder) {\r\n        insert(anchor, container, parentAnchor);\r\n    }\r\n}\r\nfunction hydrateTeleport(node, vnode, parentComponent, parentSuspense, optimized, { o: { nextSibling, parentNode, querySelector } }, hydrateChildren) {\r\n    const target = (vnode.target = resolveTarget(vnode.props, querySelector));\r\n    if (target) {\r\n        // if multiple teleports rendered to the same target element, we need to\r\n        // pick up from where the last teleport finished instead of the first node\r\n        const targetNode = target._lpa || target.firstChild;\r\n        if (vnode.shapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n            if (isTeleportDisabled(vnode.props)) {\r\n                vnode.anchor = hydrateChildren(nextSibling(node), vnode, parentNode(node), parentComponent, parentSuspense, optimized);\r\n                vnode.targetAnchor = targetNode;\r\n            }\r\n            else {\r\n                vnode.anchor = nextSibling(node);\r\n                vnode.targetAnchor = hydrateChildren(targetNode, vnode, target, parentComponent, parentSuspense, optimized);\r\n            }\r\n            target._lpa =\r\n                vnode.targetAnchor && nextSibling(vnode.targetAnchor);\r\n        }\r\n    }\r\n    return vnode.anchor && nextSibling(vnode.anchor);\r\n}\r\n// Force-casted public typing for h and TSX props inference\r\nconst Teleport = TeleportImpl;\n\nconst COMPONENTS = 'components';\r\nconst DIRECTIVES = 'directives';\r\n/**\r\n * @private\r\n */\r\nfunction resolveComponent(name) {\r\n    return resolveAsset(COMPONENTS, name) || name;\r\n}\r\nconst NULL_DYNAMIC_COMPONENT = Symbol();\r\n/**\r\n * @private\r\n */\r\nfunction resolveDynamicComponent(component) {\r\n    if (isString(component)) {\r\n        return resolveAsset(COMPONENTS, component, false) || component;\r\n    }\r\n    else {\r\n        // invalid types will fallthrough to createVNode and raise warning\r\n        return (component || NULL_DYNAMIC_COMPONENT);\r\n    }\r\n}\r\n/**\r\n * @private\r\n */\r\nfunction resolveDirective(name) {\r\n    return resolveAsset(DIRECTIVES, name);\r\n}\r\n// implementation\r\nfunction resolveAsset(type, name, warnMissing = true) {\r\n    const instance = currentRenderingInstance || currentInstance;\r\n    if (instance) {\r\n        const Component = instance.type;\r\n        // self name has highest priority\r\n        if (type === COMPONENTS) {\r\n            const selfName = Component.displayName || Component.name;\r\n            if (selfName &&\r\n                (selfName === name ||\r\n                    selfName === camelize(name) ||\r\n                    selfName === capitalize(camelize(name)))) {\r\n                return Component;\r\n            }\r\n        }\r\n        const res = \r\n        // local registration\r\n        // check instance[type] first for components with mixin or extends.\r\n        resolve(instance[type] || Component[type], name) ||\r\n            // global registration\r\n            resolve(instance.appContext[type], name);\r\n        if ((process.env.NODE_ENV !== 'production') && warnMissing && !res) {\r\n            warn(`Failed to resolve ${type.slice(0, -1)}: ${name}`);\r\n        }\r\n        return res;\r\n    }\r\n    else if ((process.env.NODE_ENV !== 'production')) {\r\n        warn(`resolve${capitalize(type.slice(0, -1))} ` +\r\n            `can only be used in render() or setup().`);\r\n    }\r\n}\r\nfunction resolve(registry, name) {\r\n    return (registry &&\r\n        (registry[name] ||\r\n            registry[camelize(name)] ||\r\n            registry[capitalize(camelize(name))]));\r\n}\n\nconst Fragment = Symbol((process.env.NODE_ENV !== 'production') ? 'Fragment' : undefined);\r\nconst Text = Symbol((process.env.NODE_ENV !== 'production') ? 'Text' : undefined);\r\nconst Comment = Symbol((process.env.NODE_ENV !== 'production') ? 'Comment' : undefined);\r\nconst Static = Symbol((process.env.NODE_ENV !== 'production') ? 'Static' : undefined);\r\n// Since v-if and v-for are the two possible ways node structure can dynamically\r\n// change, once we consider v-if branches and each v-for fragment a block, we\r\n// can divide a template into nested blocks, and within each block the node\r\n// structure would be stable. This allows us to skip most children diffing\r\n// and only worry about the dynamic nodes (indicated by patch flags).\r\nconst blockStack = [];\r\nlet currentBlock = null;\r\n/**\r\n * Open a block.\r\n * This must be called before `createBlock`. It cannot be part of `createBlock`\r\n * because the children of the block are evaluated before `createBlock` itself\r\n * is called. The generated code typically looks like this:\r\n *\r\n * ```js\r\n * function render() {\r\n *   return (openBlock(),createBlock('div', null, [...]))\r\n * }\r\n * ```\r\n * disableTracking is true when creating a v-for fragment block, since a v-for\r\n * fragment always diffs its children.\r\n *\r\n * @private\r\n */\r\nfunction openBlock(disableTracking = false) {\r\n    blockStack.push((currentBlock = disableTracking ? null : []));\r\n}\r\nfunction closeBlock() {\r\n    blockStack.pop();\r\n    currentBlock = blockStack[blockStack.length - 1] || null;\r\n}\r\n// Whether we should be tracking dynamic child nodes inside a block.\r\n// Only tracks when this value is > 0\r\n// We are not using a simple boolean because this value may need to be\r\n// incremented/decremented by nested usage of v-once (see below)\r\nlet shouldTrack = 1;\r\n/**\r\n * Block tracking sometimes needs to be disabled, for example during the\r\n * creation of a tree that needs to be cached by v-once. The compiler generates\r\n * code like this:\r\n *\r\n * ``` js\r\n * _cache[1] || (\r\n *   setBlockTracking(-1),\r\n *   _cache[1] = createVNode(...),\r\n *   setBlockTracking(1),\r\n *   _cache[1]\r\n * )\r\n * ```\r\n *\r\n * @private\r\n */\r\nfunction setBlockTracking(value) {\r\n    shouldTrack += value;\r\n}\r\n/**\r\n * Create a block root vnode. Takes the same exact arguments as `createVNode`.\r\n * A block root keeps track of dynamic nodes within the block in the\r\n * `dynamicChildren` array.\r\n *\r\n * @private\r\n */\r\nfunction createBlock(type, props, children, patchFlag, dynamicProps) {\r\n    const vnode = createVNode(type, props, children, patchFlag, dynamicProps, true /* isBlock: prevent a block from tracking itself */);\r\n    // save current block children on the block vnode\r\n    vnode.dynamicChildren = currentBlock || EMPTY_ARR;\r\n    // close block\r\n    closeBlock();\r\n    // a block is always going to be patched, so track it as a child of its\r\n    // parent block\r\n    if (shouldTrack > 0 && currentBlock) {\r\n        currentBlock.push(vnode);\r\n    }\r\n    return vnode;\r\n}\r\nfunction isVNode(value) {\r\n    return value ? value.__v_isVNode === true : false;\r\n}\r\nfunction isSameVNodeType(n1, n2) {\r\n    if ((process.env.NODE_ENV !== 'production') &&\r\n        n2.shapeFlag & 6 /* COMPONENT */ &&\r\n        hmrDirtyComponents.has(n2.type)) {\r\n        // HMR only: if the component has been hot-updated, force a reload.\r\n        return false;\r\n    }\r\n    return n1.type === n2.type && n1.key === n2.key;\r\n}\r\nlet vnodeArgsTransformer;\r\n/**\r\n * Internal API for registering an arguments transform for createVNode\r\n * used for creating stubs in the test-utils\r\n * It is *internal* but needs to be exposed for test-utils to pick up proper\r\n * typings\r\n */\r\nfunction transformVNodeArgs(transformer) {\r\n    vnodeArgsTransformer = transformer;\r\n}\r\nconst createVNodeWithArgsTransform = (...args) => {\r\n    return _createVNode(...(vnodeArgsTransformer\r\n        ? vnodeArgsTransformer(args, currentRenderingInstance)\r\n        : args));\r\n};\r\nconst InternalObjectKey = `__vInternal`;\r\nconst normalizeKey = ({ key }) => key != null ? key : null;\r\nconst normalizeRef = ({ ref }) => {\r\n    return (ref != null\r\n        ? isArray(ref)\r\n            ? ref\r\n            : { i: currentRenderingInstance, r: ref }\r\n        : null);\r\n};\r\nconst createVNode = ((process.env.NODE_ENV !== 'production')\r\n    ? createVNodeWithArgsTransform\r\n    : _createVNode);\r\nfunction _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {\r\n    if (!type || type === NULL_DYNAMIC_COMPONENT) {\r\n        if ((process.env.NODE_ENV !== 'production') && !type) {\r\n            warn(`Invalid vnode type when creating vnode: ${type}.`);\r\n        }\r\n        type = Comment;\r\n    }\r\n    if (isVNode(type)) {\r\n        // createVNode receiving an existing vnode. This happens in cases like\r\n        // <component :is=\"vnode\"/>\r\n        // #2078 make sure to merge refs during the clone instead of overwriting it\r\n        const cloned = cloneVNode(type, props, true /* mergeRef: true */);\r\n        if (children) {\r\n            normalizeChildren(cloned, children);\r\n        }\r\n        return cloned;\r\n    }\r\n    // class component normalization.\r\n    if (isClassComponent(type)) {\r\n        type = type.__vccOpts;\r\n    }\r\n    // class & style normalization.\r\n    if (props) {\r\n        // for reactive or proxy objects, we need to clone it to enable mutation.\r\n        if (isProxy(props) || InternalObjectKey in props) {\r\n            props = extend({}, props);\r\n        }\r\n        let { class: klass, style } = props;\r\n        if (klass && !isString(klass)) {\r\n            props.class = normalizeClass(klass);\r\n        }\r\n        if (isObject(style)) {\r\n            // reactive state objects need to be cloned since they are likely to be\r\n            // mutated\r\n            if (isProxy(style) && !isArray(style)) {\r\n                style = extend({}, style);\r\n            }\r\n            props.style = normalizeStyle(style);\r\n        }\r\n    }\r\n    // encode the vnode type information into a bitmap\r\n    const shapeFlag = isString(type)\r\n        ? 1 /* ELEMENT */\r\n        :  isSuspense(type)\r\n            ? 128 /* SUSPENSE */\r\n            : isTeleport(type)\r\n                ? 64 /* TELEPORT */\r\n                : isObject(type)\r\n                    ? 4 /* STATEFUL_COMPONENT */\r\n                    : isFunction(type)\r\n                        ? 2 /* FUNCTIONAL_COMPONENT */\r\n                        : 0;\r\n    if ((process.env.NODE_ENV !== 'production') && shapeFlag & 4 /* STATEFUL_COMPONENT */ && isProxy(type)) {\r\n        type = toRaw(type);\r\n        warn(`Vue received a Component which was made a reactive object. This can ` +\r\n            `lead to unnecessary performance overhead, and should be avoided by ` +\r\n            `marking the component with \\`markRaw\\` or using \\`shallowRef\\` ` +\r\n            `instead of \\`ref\\`.`, `\\nComponent that was made reactive: `, type);\r\n    }\r\n    const vnode = {\r\n        __v_isVNode: true,\r\n        [\"__v_skip\" /* SKIP */]: true,\r\n        type,\r\n        props,\r\n        key: props && normalizeKey(props),\r\n        ref: props && normalizeRef(props),\r\n        scopeId: currentScopeId,\r\n        children: null,\r\n        component: null,\r\n        suspense: null,\r\n        ssContent: null,\r\n        ssFallback: null,\r\n        dirs: null,\r\n        transition: null,\r\n        el: null,\r\n        anchor: null,\r\n        target: null,\r\n        targetAnchor: null,\r\n        staticCount: 0,\r\n        shapeFlag,\r\n        patchFlag,\r\n        dynamicProps,\r\n        dynamicChildren: null,\r\n        appContext: null\r\n    };\r\n    // validate key\r\n    if ((process.env.NODE_ENV !== 'production') && vnode.key !== vnode.key) {\r\n        warn(`VNode created with invalid key (NaN). VNode type:`, vnode.type);\r\n    }\r\n    normalizeChildren(vnode, children);\r\n    // normalize suspense children\r\n    if ( shapeFlag & 128 /* SUSPENSE */) {\r\n        const { content, fallback } = normalizeSuspenseChildren(vnode);\r\n        vnode.ssContent = content;\r\n        vnode.ssFallback = fallback;\r\n    }\r\n    if (shouldTrack > 0 &&\r\n        // avoid a block node from tracking itself\r\n        !isBlockNode &&\r\n        // has current parent block\r\n        currentBlock &&\r\n        // presence of a patch flag indicates this node needs patching on updates.\r\n        // component nodes also should always be patched, because even if the\r\n        // component doesn't need to update, it needs to persist the instance on to\r\n        // the next vnode so that it can be properly unmounted later.\r\n        (patchFlag > 0 || shapeFlag & 6 /* COMPONENT */) &&\r\n        // the EVENTS flag is only for hydration and if it is the only flag, the\r\n        // vnode should not be considered dynamic due to handler caching.\r\n        patchFlag !== 32 /* HYDRATE_EVENTS */) {\r\n        currentBlock.push(vnode);\r\n    }\r\n    return vnode;\r\n}\r\nfunction cloneVNode(vnode, extraProps, mergeRef = false) {\r\n    // This is intentionally NOT using spread or extend to avoid the runtime\r\n    // key enumeration cost.\r\n    const { props, ref, patchFlag } = vnode;\r\n    const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;\r\n    return {\r\n        __v_isVNode: true,\r\n        [\"__v_skip\" /* SKIP */]: true,\r\n        type: vnode.type,\r\n        props: mergedProps,\r\n        key: mergedProps && normalizeKey(mergedProps),\r\n        ref: extraProps && extraProps.ref\r\n            ? // #2078 in the case of <component :is=\"vnode\" ref=\"extra\"/>\r\n                // if the vnode itself already has a ref, cloneVNode will need to merge\r\n                // the refs so the single vnode can be set on multiple refs\r\n                mergeRef && ref\r\n                    ? isArray(ref)\r\n                        ? ref.concat(normalizeRef(extraProps))\r\n                        : [ref, normalizeRef(extraProps)]\r\n                    : normalizeRef(extraProps)\r\n            : ref,\r\n        scopeId: vnode.scopeId,\r\n        children: vnode.children,\r\n        target: vnode.target,\r\n        targetAnchor: vnode.targetAnchor,\r\n        staticCount: vnode.staticCount,\r\n        shapeFlag: vnode.shapeFlag,\r\n        // if the vnode is cloned with extra props, we can no longer assume its\r\n        // existing patch flag to be reliable and need to add the FULL_PROPS flag.\r\n        // note: perserve flag for fragments since they use the flag for children\r\n        // fast paths only.\r\n        patchFlag: extraProps && vnode.type !== Fragment\r\n            ? patchFlag === -1 // hoisted node\r\n                ? 16 /* FULL_PROPS */\r\n                : patchFlag | 16 /* FULL_PROPS */\r\n            : patchFlag,\r\n        dynamicProps: vnode.dynamicProps,\r\n        dynamicChildren: vnode.dynamicChildren,\r\n        appContext: vnode.appContext,\r\n        dirs: vnode.dirs,\r\n        transition: vnode.transition,\r\n        // These should technically only be non-null on mounted VNodes. However,\r\n        // they *should* be copied for kept-alive vnodes. So we just always copy\r\n        // them since them being non-null during a mount doesn't affect the logic as\r\n        // they will simply be overwritten.\r\n        component: vnode.component,\r\n        suspense: vnode.suspense,\r\n        ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),\r\n        ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),\r\n        el: vnode.el,\r\n        anchor: vnode.anchor\r\n    };\r\n}\r\n/**\r\n * @private\r\n */\r\nfunction createTextVNode(text = ' ', flag = 0) {\r\n    return createVNode(Text, null, text, flag);\r\n}\r\n/**\r\n * @private\r\n */\r\nfunction createStaticVNode(content, numberOfNodes) {\r\n    // A static vnode can contain multiple stringified elements, and the number\r\n    // of elements is necessary for hydration.\r\n    const vnode = createVNode(Static, null, content);\r\n    vnode.staticCount = numberOfNodes;\r\n    return vnode;\r\n}\r\n/**\r\n * @private\r\n */\r\nfunction createCommentVNode(text = '', \r\n// when used as the v-else branch, the comment node must be created as a\r\n// block to ensure correct updates.\r\nasBlock = false) {\r\n    return asBlock\r\n        ? (openBlock(), createBlock(Comment, null, text))\r\n        : createVNode(Comment, null, text);\r\n}\r\nfunction normalizeVNode(child) {\r\n    if (child == null || typeof child === 'boolean') {\r\n        // empty placeholder\r\n        return createVNode(Comment);\r\n    }\r\n    else if (isArray(child)) {\r\n        // fragment\r\n        return createVNode(Fragment, null, child);\r\n    }\r\n    else if (typeof child === 'object') {\r\n        // already vnode, this should be the most common since compiled templates\r\n        // always produce all-vnode children arrays\r\n        return child.el === null ? child : cloneVNode(child);\r\n    }\r\n    else {\r\n        // strings and numbers\r\n        return createVNode(Text, null, String(child));\r\n    }\r\n}\r\n// optimized normalization for template-compiled render fns\r\nfunction cloneIfMounted(child) {\r\n    return child.el === null ? child : cloneVNode(child);\r\n}\r\nfunction normalizeChildren(vnode, children) {\r\n    let type = 0;\r\n    const { shapeFlag } = vnode;\r\n    if (children == null) {\r\n        children = null;\r\n    }\r\n    else if (isArray(children)) {\r\n        type = 16 /* ARRAY_CHILDREN */;\r\n    }\r\n    else if (typeof children === 'object') {\r\n        if (shapeFlag & 1 /* ELEMENT */ || shapeFlag & 64 /* TELEPORT */) {\r\n            // Normalize slot to plain children for plain element and Teleport\r\n            const slot = children.default;\r\n            if (slot) {\r\n                // _c marker is added by withCtx() indicating this is a compiled slot\r\n                slot._c && setCompiledSlotRendering(1);\r\n                normalizeChildren(vnode, slot());\r\n                slot._c && setCompiledSlotRendering(-1);\r\n            }\r\n            return;\r\n        }\r\n        else {\r\n            type = 32 /* SLOTS_CHILDREN */;\r\n            const slotFlag = children._;\r\n            if (!slotFlag && !(InternalObjectKey in children)) {\r\n                children._ctx = currentRenderingInstance;\r\n            }\r\n            else if (slotFlag === 3 /* FORWARDED */ && currentRenderingInstance) {\r\n                // a child component receives forwarded slots from the parent.\r\n                // its slot type is determined by its parent's slot type.\r\n                if (currentRenderingInstance.vnode.patchFlag & 1024 /* DYNAMIC_SLOTS */) {\r\n                    children._ = 2 /* DYNAMIC */;\r\n                    vnode.patchFlag |= 1024 /* DYNAMIC_SLOTS */;\r\n                }\r\n                else {\r\n                    children._ = 1 /* STABLE */;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else if (isFunction(children)) {\r\n        children = { default: children, _ctx: currentRenderingInstance };\r\n        type = 32 /* SLOTS_CHILDREN */;\r\n    }\r\n    else {\r\n        children = String(children);\r\n        // force teleport children to array so it can be moved around\r\n        if (shapeFlag & 64 /* TELEPORT */) {\r\n            type = 16 /* ARRAY_CHILDREN */;\r\n            children = [createTextVNode(children)];\r\n        }\r\n        else {\r\n            type = 8 /* TEXT_CHILDREN */;\r\n        }\r\n    }\r\n    vnode.children = children;\r\n    vnode.shapeFlag |= type;\r\n}\r\nfunction mergeProps(...args) {\r\n    const ret = extend({}, args[0]);\r\n    for (let i = 1; i < args.length; i++) {\r\n        const toMerge = args[i];\r\n        for (const key in toMerge) {\r\n            if (key === 'class') {\r\n                if (ret.class !== toMerge.class) {\r\n                    ret.class = normalizeClass([ret.class, toMerge.class]);\r\n                }\r\n            }\r\n            else if (key === 'style') {\r\n                ret.style = normalizeStyle([ret.style, toMerge.style]);\r\n            }\r\n            else if (isOn(key)) {\r\n                const existing = ret[key];\r\n                const incoming = toMerge[key];\r\n                if (existing !== incoming) {\r\n                    ret[key] = existing\r\n                        ? [].concat(existing, toMerge[key])\r\n                        : incoming;\r\n                }\r\n            }\r\n            else {\r\n                ret[key] = toMerge[key];\r\n            }\r\n        }\r\n    }\r\n    return ret;\r\n}\n\nfunction provide(key, value) {\r\n    if (!currentInstance) {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            warn(`provide() can only be used inside setup().`);\r\n        }\r\n    }\r\n    else {\r\n        let provides = currentInstance.provides;\r\n        // by default an instance inherits its parent's provides object\r\n        // but when it needs to provide values of its own, it creates its\r\n        // own provides object using parent provides object as prototype.\r\n        // this way in `inject` we can simply look up injections from direct\r\n        // parent and let the prototype chain do the work.\r\n        const parentProvides = currentInstance.parent && currentInstance.parent.provides;\r\n        if (parentProvides === provides) {\r\n            provides = currentInstance.provides = Object.create(parentProvides);\r\n        }\r\n        // TS doesn't allow symbol as index type\r\n        provides[key] = value;\r\n    }\r\n}\r\nfunction inject(key, defaultValue, treatDefaultAsFactory = false) {\r\n    // fallback to `currentRenderingInstance` so that this can be called in\r\n    // a functional component\r\n    const instance = currentInstance || currentRenderingInstance;\r\n    if (instance) {\r\n        const provides = instance.provides;\r\n        if (key in provides) {\r\n            // TS doesn't allow symbol as index type\r\n            return provides[key];\r\n        }\r\n        else if (arguments.length > 1) {\r\n            return treatDefaultAsFactory && isFunction(defaultValue)\r\n                ? defaultValue()\r\n                : defaultValue;\r\n        }\r\n        else if ((process.env.NODE_ENV !== 'production')) {\r\n            warn(`injection \"${String(key)}\" not found.`);\r\n        }\r\n    }\r\n    else if ((process.env.NODE_ENV !== 'production')) {\r\n        warn(`inject() can only be used inside setup() or functional components.`);\r\n    }\r\n}\n\nfunction createDuplicateChecker() {\r\n    const cache = Object.create(null);\r\n    return (type, key) => {\r\n        if (cache[key]) {\r\n            warn(`${type} property \"${key}\" is already defined in ${cache[key]}.`);\r\n        }\r\n        else {\r\n            cache[key] = type;\r\n        }\r\n    };\r\n}\r\nlet isInBeforeCreate = false;\r\nfunction applyOptions(instance, options, deferredData = [], deferredWatch = [], deferredProvide = [], asMixin = false) {\r\n    const { \r\n    // composition\r\n    mixins, extends: extendsOptions, \r\n    // state\r\n    data: dataOptions, computed: computedOptions, methods, watch: watchOptions, provide: provideOptions, inject: injectOptions, \r\n    // assets\r\n    components, directives, \r\n    // lifecycle\r\n    beforeMount, mounted, beforeUpdate, updated, activated, deactivated, beforeDestroy, beforeUnmount, destroyed, unmounted, render, renderTracked, renderTriggered, errorCaptured } = options;\r\n    const publicThis = instance.proxy;\r\n    const ctx = instance.ctx;\r\n    const globalMixins = instance.appContext.mixins;\r\n    if (asMixin && render && instance.render === NOOP) {\r\n        instance.render = render;\r\n    }\r\n    // applyOptions is called non-as-mixin once per instance\r\n    if (!asMixin) {\r\n        isInBeforeCreate = true;\r\n        callSyncHook('beforeCreate', \"bc\" /* BEFORE_CREATE */, options, instance, globalMixins);\r\n        isInBeforeCreate = false;\r\n        // global mixins are applied first\r\n        applyMixins(instance, globalMixins, deferredData, deferredWatch, deferredProvide);\r\n    }\r\n    // extending a base component...\r\n    if (extendsOptions) {\r\n        applyOptions(instance, extendsOptions, deferredData, deferredWatch, deferredProvide, true);\r\n    }\r\n    // local mixins\r\n    if (mixins) {\r\n        applyMixins(instance, mixins, deferredData, deferredWatch, deferredProvide);\r\n    }\r\n    const checkDuplicateProperties = (process.env.NODE_ENV !== 'production') ? createDuplicateChecker() : null;\r\n    if ((process.env.NODE_ENV !== 'production')) {\r\n        const [propsOptions] = instance.propsOptions;\r\n        if (propsOptions) {\r\n            for (const key in propsOptions) {\r\n                checkDuplicateProperties(\"Props\" /* PROPS */, key);\r\n            }\r\n        }\r\n    }\r\n    // options initialization order (to be consistent with Vue 2):\r\n    // - props (already done outside of this function)\r\n    // - inject\r\n    // - methods\r\n    // - data (deferred since it relies on `this` access)\r\n    // - computed\r\n    // - watch (deferred since it relies on `this` access)\r\n    if (injectOptions) {\r\n        if (isArray(injectOptions)) {\r\n            for (let i = 0; i < injectOptions.length; i++) {\r\n                const key = injectOptions[i];\r\n                ctx[key] = inject(key);\r\n                if ((process.env.NODE_ENV !== 'production')) {\r\n                    checkDuplicateProperties(\"Inject\" /* INJECT */, key);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            for (const key in injectOptions) {\r\n                const opt = injectOptions[key];\r\n                if (isObject(opt)) {\r\n                    ctx[key] = inject(opt.from || key, opt.default, true /* treat default function as factory */);\r\n                }\r\n                else {\r\n                    ctx[key] = inject(opt);\r\n                }\r\n                if ((process.env.NODE_ENV !== 'production')) {\r\n                    checkDuplicateProperties(\"Inject\" /* INJECT */, key);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (methods) {\r\n        for (const key in methods) {\r\n            const methodHandler = methods[key];\r\n            if (isFunction(methodHandler)) {\r\n                ctx[key] = methodHandler.bind(publicThis);\r\n                if ((process.env.NODE_ENV !== 'production')) {\r\n                    checkDuplicateProperties(\"Methods\" /* METHODS */, key);\r\n                }\r\n            }\r\n            else if ((process.env.NODE_ENV !== 'production')) {\r\n                warn(`Method \"${key}\" has type \"${typeof methodHandler}\" in the component definition. ` +\r\n                    `Did you reference the function correctly?`);\r\n            }\r\n        }\r\n    }\r\n    if (!asMixin) {\r\n        if (deferredData.length) {\r\n            deferredData.forEach(dataFn => resolveData(instance, dataFn, publicThis));\r\n        }\r\n        if (dataOptions) {\r\n            resolveData(instance, dataOptions, publicThis);\r\n        }\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            const rawData = toRaw(instance.data);\r\n            for (const key in rawData) {\r\n                checkDuplicateProperties(\"Data\" /* DATA */, key);\r\n                // expose data on ctx during dev\r\n                if (key[0] !== '$' && key[0] !== '_') {\r\n                    Object.defineProperty(ctx, key, {\r\n                        configurable: true,\r\n                        enumerable: true,\r\n                        get: () => rawData[key],\r\n                        set: NOOP\r\n                    });\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else if (dataOptions) {\r\n        deferredData.push(dataOptions);\r\n    }\r\n    if (computedOptions) {\r\n        for (const key in computedOptions) {\r\n            const opt = computedOptions[key];\r\n            const get = isFunction(opt)\r\n                ? opt.bind(publicThis, publicThis)\r\n                : isFunction(opt.get)\r\n                    ? opt.get.bind(publicThis, publicThis)\r\n                    : NOOP;\r\n            if ((process.env.NODE_ENV !== 'production') && get === NOOP) {\r\n                warn(`Computed property \"${key}\" has no getter.`);\r\n            }\r\n            const set = !isFunction(opt) && isFunction(opt.set)\r\n                ? opt.set.bind(publicThis)\r\n                : (process.env.NODE_ENV !== 'production')\r\n                    ? () => {\r\n                        warn(`Write operation failed: computed property \"${key}\" is readonly.`);\r\n                    }\r\n                    : NOOP;\r\n            const c = computed({\r\n                get,\r\n                set\r\n            });\r\n            Object.defineProperty(ctx, key, {\r\n                enumerable: true,\r\n                configurable: true,\r\n                get: () => c.value,\r\n                set: v => (c.value = v)\r\n            });\r\n            if ((process.env.NODE_ENV !== 'production')) {\r\n                checkDuplicateProperties(\"Computed\" /* COMPUTED */, key);\r\n            }\r\n        }\r\n    }\r\n    if (watchOptions) {\r\n        deferredWatch.push(watchOptions);\r\n    }\r\n    if (!asMixin && deferredWatch.length) {\r\n        deferredWatch.forEach(watchOptions => {\r\n            for (const key in watchOptions) {\r\n                createWatcher(watchOptions[key], ctx, publicThis, key);\r\n            }\r\n        });\r\n    }\r\n    if (provideOptions) {\r\n        deferredProvide.push(provideOptions);\r\n    }\r\n    if (!asMixin && deferredProvide.length) {\r\n        deferredProvide.forEach(provideOptions => {\r\n            const provides = isFunction(provideOptions)\r\n                ? provideOptions.call(publicThis)\r\n                : provideOptions;\r\n            for (const key in provides) {\r\n                provide(key, provides[key]);\r\n            }\r\n        });\r\n    }\r\n    // asset options.\r\n    // To reduce memory usage, only components with mixins or extends will have\r\n    // resolved asset registry attached to instance.\r\n    if (asMixin) {\r\n        if (components) {\r\n            extend(instance.components ||\r\n                (instance.components = extend({}, instance.type.components)), components);\r\n        }\r\n        if (directives) {\r\n            extend(instance.directives ||\r\n                (instance.directives = extend({}, instance.type.directives)), directives);\r\n        }\r\n    }\r\n    // lifecycle options\r\n    if (!asMixin) {\r\n        callSyncHook('created', \"c\" /* CREATED */, options, instance, globalMixins);\r\n    }\r\n    if (beforeMount) {\r\n        onBeforeMount(beforeMount.bind(publicThis));\r\n    }\r\n    if (mounted) {\r\n        onMounted(mounted.bind(publicThis));\r\n    }\r\n    if (beforeUpdate) {\r\n        onBeforeUpdate(beforeUpdate.bind(publicThis));\r\n    }\r\n    if (updated) {\r\n        onUpdated(updated.bind(publicThis));\r\n    }\r\n    if (activated) {\r\n        onActivated(activated.bind(publicThis));\r\n    }\r\n    if (deactivated) {\r\n        onDeactivated(deactivated.bind(publicThis));\r\n    }\r\n    if (errorCaptured) {\r\n        onErrorCaptured(errorCaptured.bind(publicThis));\r\n    }\r\n    if (renderTracked) {\r\n        onRenderTracked(renderTracked.bind(publicThis));\r\n    }\r\n    if (renderTriggered) {\r\n        onRenderTriggered(renderTriggered.bind(publicThis));\r\n    }\r\n    if ((process.env.NODE_ENV !== 'production') && beforeDestroy) {\r\n        warn(`\\`beforeDestroy\\` has been renamed to \\`beforeUnmount\\`.`);\r\n    }\r\n    if (beforeUnmount) {\r\n        onBeforeUnmount(beforeUnmount.bind(publicThis));\r\n    }\r\n    if ((process.env.NODE_ENV !== 'production') && destroyed) {\r\n        warn(`\\`destroyed\\` has been renamed to \\`unmounted\\`.`);\r\n    }\r\n    if (unmounted) {\r\n        onUnmounted(unmounted.bind(publicThis));\r\n    }\r\n}\r\nfunction callSyncHook(name, type, options, instance, globalMixins) {\r\n    callHookFromMixins(name, type, globalMixins, instance);\r\n    const { extends: base, mixins } = options;\r\n    if (base) {\r\n        callHookFromExtends(name, type, base, instance);\r\n    }\r\n    if (mixins) {\r\n        callHookFromMixins(name, type, mixins, instance);\r\n    }\r\n    const selfHook = options[name];\r\n    if (selfHook) {\r\n        callWithAsyncErrorHandling(selfHook.bind(instance.proxy), instance, type);\r\n    }\r\n}\r\nfunction callHookFromExtends(name, type, base, instance) {\r\n    if (base.extends) {\r\n        callHookFromExtends(name, type, base.extends, instance);\r\n    }\r\n    const baseHook = base[name];\r\n    if (baseHook) {\r\n        callWithAsyncErrorHandling(baseHook.bind(instance.proxy), instance, type);\r\n    }\r\n}\r\nfunction callHookFromMixins(name, type, mixins, instance) {\r\n    for (let i = 0; i < mixins.length; i++) {\r\n        const chainedMixins = mixins[i].mixins;\r\n        if (chainedMixins) {\r\n            callHookFromMixins(name, type, chainedMixins, instance);\r\n        }\r\n        const fn = mixins[i][name];\r\n        if (fn) {\r\n            callWithAsyncErrorHandling(fn.bind(instance.proxy), instance, type);\r\n        }\r\n    }\r\n}\r\nfunction applyMixins(instance, mixins, deferredData, deferredWatch, deferredProvide) {\r\n    for (let i = 0; i < mixins.length; i++) {\r\n        applyOptions(instance, mixins[i], deferredData, deferredWatch, deferredProvide, true);\r\n    }\r\n}\r\nfunction resolveData(instance, dataFn, publicThis) {\r\n    if ((process.env.NODE_ENV !== 'production') && !isFunction(dataFn)) {\r\n        warn(`The data option must be a function. ` +\r\n            `Plain object usage is no longer supported.`);\r\n    }\r\n    const data = dataFn.call(publicThis, publicThis);\r\n    if ((process.env.NODE_ENV !== 'production') && isPromise(data)) {\r\n        warn(`data() returned a Promise - note data() cannot be async; If you ` +\r\n            `intend to perform data fetching before component renders, use ` +\r\n            `async setup() + <Suspense>.`);\r\n    }\r\n    if (!isObject(data)) {\r\n        (process.env.NODE_ENV !== 'production') && warn(`data() should return an object.`);\r\n    }\r\n    else if (instance.data === EMPTY_OBJ) {\r\n        instance.data = reactive(data);\r\n    }\r\n    else {\r\n        // existing data: this is a mixin or extends.\r\n        extend(instance.data, data);\r\n    }\r\n}\r\nfunction createWatcher(raw, ctx, publicThis, key) {\r\n    const getter = key.includes('.')\r\n        ? createPathGetter(publicThis, key)\r\n        : () => publicThis[key];\r\n    if (isString(raw)) {\r\n        const handler = ctx[raw];\r\n        if (isFunction(handler)) {\r\n            watch(getter, handler);\r\n        }\r\n        else if ((process.env.NODE_ENV !== 'production')) {\r\n            warn(`Invalid watch handler specified by key \"${raw}\"`, handler);\r\n        }\r\n    }\r\n    else if (isFunction(raw)) {\r\n        watch(getter, raw.bind(publicThis));\r\n    }\r\n    else if (isObject(raw)) {\r\n        if (isArray(raw)) {\r\n            raw.forEach(r => createWatcher(r, ctx, publicThis, key));\r\n        }\r\n        else {\r\n            const handler = isFunction(raw.handler)\r\n                ? raw.handler.bind(publicThis)\r\n                : ctx[raw.handler];\r\n            if (isFunction(handler)) {\r\n                watch(getter, handler, raw);\r\n            }\r\n            else if ((process.env.NODE_ENV !== 'production')) {\r\n                warn(`Invalid watch handler specified by key \"${raw.handler}\"`, handler);\r\n            }\r\n        }\r\n    }\r\n    else if ((process.env.NODE_ENV !== 'production')) {\r\n        warn(`Invalid watch option: \"${key}\"`, raw);\r\n    }\r\n}\r\nfunction createPathGetter(ctx, path) {\r\n    const segments = path.split('.');\r\n    return () => {\r\n        let cur = ctx;\r\n        for (let i = 0; i < segments.length && cur; i++) {\r\n            cur = cur[segments[i]];\r\n        }\r\n        return cur;\r\n    };\r\n}\r\nfunction resolveMergedOptions(instance) {\r\n    const raw = instance.type;\r\n    const { __merged, mixins, extends: extendsOptions } = raw;\r\n    if (__merged)\r\n        return __merged;\r\n    const globalMixins = instance.appContext.mixins;\r\n    if (!globalMixins.length && !mixins && !extendsOptions)\r\n        return raw;\r\n    const options = {};\r\n    globalMixins.forEach(m => mergeOptions(options, m, instance));\r\n    mergeOptions(options, raw, instance);\r\n    return (raw.__merged = options);\r\n}\r\nfunction mergeOptions(to, from, instance) {\r\n    const strats = instance.appContext.config.optionMergeStrategies;\r\n    const { mixins, extends: extendsOptions } = from;\r\n    extendsOptions && mergeOptions(to, extendsOptions, instance);\r\n    mixins &&\r\n        mixins.forEach((m) => mergeOptions(to, m, instance));\r\n    for (const key in from) {\r\n        if (strats && hasOwn(strats, key)) {\r\n            to[key] = strats[key](to[key], from[key], instance.proxy, key);\r\n        }\r\n        else {\r\n            to[key] = from[key];\r\n        }\r\n    }\r\n}\n\nconst publicPropertiesMap = extend(Object.create(null), {\r\n    $: i => i,\r\n    $el: i => i.vnode.el,\r\n    $data: i => i.data,\r\n    $props: i => ((process.env.NODE_ENV !== 'production') ? shallowReadonly(i.props) : i.props),\r\n    $attrs: i => ((process.env.NODE_ENV !== 'production') ? shallowReadonly(i.attrs) : i.attrs),\r\n    $slots: i => ((process.env.NODE_ENV !== 'production') ? shallowReadonly(i.slots) : i.slots),\r\n    $refs: i => ((process.env.NODE_ENV !== 'production') ? shallowReadonly(i.refs) : i.refs),\r\n    $parent: i => i.parent && i.parent.proxy,\r\n    $root: i => i.root && i.root.proxy,\r\n    $emit: i => i.emit,\r\n    $options: i => (__VUE_OPTIONS_API__ ? resolveMergedOptions(i) : i.type),\r\n    $forceUpdate: i => () => queueJob(i.update),\r\n    $nextTick: i => nextTick.bind(i.proxy),\r\n    $watch: i => (__VUE_OPTIONS_API__ ? instanceWatch.bind(i) : NOOP)\r\n});\r\nconst PublicInstanceProxyHandlers = {\r\n    get({ _: instance }, key) {\r\n        const { ctx, setupState, data, props, accessCache, type, appContext } = instance;\r\n        // let @vue/reactivity know it should never observe Vue public instances.\r\n        if (key === \"__v_skip\" /* SKIP */) {\r\n            return true;\r\n        }\r\n        // for internal formatters to know that this is a Vue instance\r\n        if ((process.env.NODE_ENV !== 'production') && key === '__isVue') {\r\n            return true;\r\n        }\r\n        // data / props / ctx\r\n        // This getter gets called for every property access on the render context\r\n        // during render and is a major hotspot. The most expensive part of this\r\n        // is the multiple hasOwn() calls. It's much faster to do a simple property\r\n        // access on a plain object, so we use an accessCache object (with null\r\n        // prototype) to memoize what access type a key corresponds to.\r\n        let normalizedProps;\r\n        if (key[0] !== '$') {\r\n            const n = accessCache[key];\r\n            if (n !== undefined) {\r\n                switch (n) {\r\n                    case 0 /* SETUP */:\r\n                        return setupState[key];\r\n                    case 1 /* DATA */:\r\n                        return data[key];\r\n                    case 3 /* CONTEXT */:\r\n                        return ctx[key];\r\n                    case 2 /* PROPS */:\r\n                        return props[key];\r\n                    // default: just fallthrough\r\n                }\r\n            }\r\n            else if (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) {\r\n                accessCache[key] = 0 /* SETUP */;\r\n                return setupState[key];\r\n            }\r\n            else if (data !== EMPTY_OBJ && hasOwn(data, key)) {\r\n                accessCache[key] = 1 /* DATA */;\r\n                return data[key];\r\n            }\r\n            else if (\r\n            // only cache other properties when instance has declared (thus stable)\r\n            // props\r\n            (normalizedProps = instance.propsOptions[0]) &&\r\n                hasOwn(normalizedProps, key)) {\r\n                accessCache[key] = 2 /* PROPS */;\r\n                return props[key];\r\n            }\r\n            else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {\r\n                accessCache[key] = 3 /* CONTEXT */;\r\n                return ctx[key];\r\n            }\r\n            else if (!__VUE_OPTIONS_API__ || !isInBeforeCreate) {\r\n                accessCache[key] = 4 /* OTHER */;\r\n            }\r\n        }\r\n        const publicGetter = publicPropertiesMap[key];\r\n        let cssModule, globalProperties;\r\n        // public $xxx properties\r\n        if (publicGetter) {\r\n            if (key === '$attrs') {\r\n                track(instance, \"get\" /* GET */, key);\r\n                (process.env.NODE_ENV !== 'production') && markAttrsAccessed();\r\n            }\r\n            return publicGetter(instance);\r\n        }\r\n        else if (\r\n        // css module (injected by vue-loader)\r\n        (cssModule = type.__cssModules) &&\r\n            (cssModule = cssModule[key])) {\r\n            return cssModule;\r\n        }\r\n        else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {\r\n            // user may set custom properties to `this` that start with `$`\r\n            accessCache[key] = 3 /* CONTEXT */;\r\n            return ctx[key];\r\n        }\r\n        else if (\r\n        // global properties\r\n        ((globalProperties = appContext.config.globalProperties),\r\n            hasOwn(globalProperties, key))) {\r\n            return globalProperties[key];\r\n        }\r\n        else if ((process.env.NODE_ENV !== 'production') &&\r\n            currentRenderingInstance &&\r\n            (!isString(key) ||\r\n                // #1091 avoid internal isRef/isVNode checks on component instance leading\r\n                // to infinite warning loop\r\n                key.indexOf('__v') !== 0)) {\r\n            if (data !== EMPTY_OBJ &&\r\n                (key[0] === '$' || key[0] === '_') &&\r\n                hasOwn(data, key)) {\r\n                warn(`Property ${JSON.stringify(key)} must be accessed via $data because it starts with a reserved ` +\r\n                    `character (\"$\" or \"_\") and is not proxied on the render context.`);\r\n            }\r\n            else {\r\n                warn(`Property ${JSON.stringify(key)} was accessed during render ` +\r\n                    `but is not defined on instance.`);\r\n            }\r\n        }\r\n    },\r\n    set({ _: instance }, key, value) {\r\n        const { data, setupState, ctx } = instance;\r\n        if (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) {\r\n            setupState[key] = value;\r\n        }\r\n        else if (data !== EMPTY_OBJ && hasOwn(data, key)) {\r\n            data[key] = value;\r\n        }\r\n        else if (key in instance.props) {\r\n            (process.env.NODE_ENV !== 'production') &&\r\n                warn(`Attempting to mutate prop \"${key}\". Props are readonly.`, instance);\r\n            return false;\r\n        }\r\n        if (key[0] === '$' && key.slice(1) in instance) {\r\n            (process.env.NODE_ENV !== 'production') &&\r\n                warn(`Attempting to mutate public property \"${key}\". ` +\r\n                    `Properties starting with $ are reserved and readonly.`, instance);\r\n            return false;\r\n        }\r\n        else {\r\n            if ((process.env.NODE_ENV !== 'production') && key in instance.appContext.config.globalProperties) {\r\n                Object.defineProperty(ctx, key, {\r\n                    enumerable: true,\r\n                    configurable: true,\r\n                    value\r\n                });\r\n            }\r\n            else {\r\n                ctx[key] = value;\r\n            }\r\n        }\r\n        return true;\r\n    },\r\n    has({ _: { data, setupState, accessCache, ctx, appContext, propsOptions } }, key) {\r\n        let normalizedProps;\r\n        return (accessCache[key] !== undefined ||\r\n            (data !== EMPTY_OBJ && hasOwn(data, key)) ||\r\n            (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) ||\r\n            ((normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key)) ||\r\n            hasOwn(ctx, key) ||\r\n            hasOwn(publicPropertiesMap, key) ||\r\n            hasOwn(appContext.config.globalProperties, key));\r\n    }\r\n};\r\nif ((process.env.NODE_ENV !== 'production') && !false) {\r\n    PublicInstanceProxyHandlers.ownKeys = (target) => {\r\n        warn(`Avoid app logic that relies on enumerating keys on a component instance. ` +\r\n            `The keys will be empty in production mode to avoid performance overhead.`);\r\n        return Reflect.ownKeys(target);\r\n    };\r\n}\r\nconst RuntimeCompiledPublicInstanceProxyHandlers = extend({}, PublicInstanceProxyHandlers, {\r\n    get(target, key) {\r\n        // fast path for unscopables when using `with` block\r\n        if (key === Symbol.unscopables) {\r\n            return;\r\n        }\r\n        return PublicInstanceProxyHandlers.get(target, key, target);\r\n    },\r\n    has(_, key) {\r\n        const has = key[0] !== '_' && !isGloballyWhitelisted(key);\r\n        if ((process.env.NODE_ENV !== 'production') && !has && PublicInstanceProxyHandlers.has(_, key)) {\r\n            warn(`Property ${JSON.stringify(key)} should not start with _ which is a reserved prefix for Vue internals.`);\r\n        }\r\n        return has;\r\n    }\r\n});\r\n// In dev mode, the proxy target exposes the same properties as seen on `this`\r\n// for easier console inspection. In prod mode it will be an empty object so\r\n// these properties definitions can be skipped.\r\nfunction createRenderContext(instance) {\r\n    const target = {};\r\n    // expose internal instance for proxy handlers\r\n    Object.defineProperty(target, `_`, {\r\n        configurable: true,\r\n        enumerable: false,\r\n        get: () => instance\r\n    });\r\n    // expose public properties\r\n    Object.keys(publicPropertiesMap).forEach(key => {\r\n        Object.defineProperty(target, key, {\r\n            configurable: true,\r\n            enumerable: false,\r\n            get: () => publicPropertiesMap[key](instance),\r\n            // intercepted by the proxy so no need for implementation,\r\n            // but needed to prevent set errors\r\n            set: NOOP\r\n        });\r\n    });\r\n    // expose global properties\r\n    const { globalProperties } = instance.appContext.config;\r\n    Object.keys(globalProperties).forEach(key => {\r\n        Object.defineProperty(target, key, {\r\n            configurable: true,\r\n            enumerable: false,\r\n            get: () => globalProperties[key],\r\n            set: NOOP\r\n        });\r\n    });\r\n    return target;\r\n}\r\n// dev only\r\nfunction exposePropsOnRenderContext(instance) {\r\n    const { ctx, propsOptions: [propsOptions] } = instance;\r\n    if (propsOptions) {\r\n        Object.keys(propsOptions).forEach(key => {\r\n            Object.defineProperty(ctx, key, {\r\n                enumerable: true,\r\n                configurable: true,\r\n                get: () => instance.props[key],\r\n                set: NOOP\r\n            });\r\n        });\r\n    }\r\n}\r\n// dev only\r\nfunction exposeSetupStateOnRenderContext(instance) {\r\n    const { ctx, setupState } = instance;\r\n    Object.keys(toRaw(setupState)).forEach(key => {\r\n        if (key[0] === '$' || key[0] === '_') {\r\n            warn(`setup() return property ${JSON.stringify(key)} should not start with \"$\" or \"_\" ` +\r\n                `which are reserved prefixes for Vue internals.`);\r\n            return;\r\n        }\r\n        Object.defineProperty(ctx, key, {\r\n            enumerable: true,\r\n            configurable: true,\r\n            get: () => setupState[key],\r\n            set: NOOP\r\n        });\r\n    });\r\n}\n\nconst emptyAppContext = createAppContext();\r\nlet uid$1 = 0;\r\nfunction createComponentInstance(vnode, parent, suspense) {\r\n    const type = vnode.type;\r\n    // inherit parent app context - or - if root, adopt from root vnode\r\n    const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;\r\n    const instance = {\r\n        uid: uid$1++,\r\n        vnode,\r\n        type,\r\n        parent,\r\n        appContext,\r\n        root: null,\r\n        next: null,\r\n        subTree: null,\r\n        update: null,\r\n        render: null,\r\n        proxy: null,\r\n        withProxy: null,\r\n        effects: null,\r\n        provides: parent ? parent.provides : Object.create(appContext.provides),\r\n        accessCache: null,\r\n        renderCache: [],\r\n        // local resovled assets\r\n        components: null,\r\n        directives: null,\r\n        // resolved props and emits options\r\n        propsOptions: normalizePropsOptions(type, appContext),\r\n        emitsOptions: normalizeEmitsOptions(type, appContext),\r\n        // emit\r\n        emit: null,\r\n        emitted: null,\r\n        // state\r\n        ctx: EMPTY_OBJ,\r\n        data: EMPTY_OBJ,\r\n        props: EMPTY_OBJ,\r\n        attrs: EMPTY_OBJ,\r\n        slots: EMPTY_OBJ,\r\n        refs: EMPTY_OBJ,\r\n        setupState: EMPTY_OBJ,\r\n        setupContext: null,\r\n        // suspense related\r\n        suspense,\r\n        suspenseId: suspense ? suspense.pendingId : 0,\r\n        asyncDep: null,\r\n        asyncResolved: false,\r\n        // lifecycle hooks\r\n        // not using enums here because it results in computed properties\r\n        isMounted: false,\r\n        isUnmounted: false,\r\n        isDeactivated: false,\r\n        bc: null,\r\n        c: null,\r\n        bm: null,\r\n        m: null,\r\n        bu: null,\r\n        u: null,\r\n        um: null,\r\n        bum: null,\r\n        da: null,\r\n        a: null,\r\n        rtg: null,\r\n        rtc: null,\r\n        ec: null\r\n    };\r\n    if ((process.env.NODE_ENV !== 'production')) {\r\n        instance.ctx = createRenderContext(instance);\r\n    }\r\n    else {\r\n        instance.ctx = { _: instance };\r\n    }\r\n    instance.root = parent ? parent.root : instance;\r\n    instance.emit = emit.bind(null, instance);\r\n    if ((process.env.NODE_ENV !== 'production') || __VUE_PROD_DEVTOOLS__) {\r\n        devtoolsComponentAdded(instance);\r\n    }\r\n    return instance;\r\n}\r\nlet currentInstance = null;\r\nconst getCurrentInstance = () => currentInstance || currentRenderingInstance;\r\nconst setCurrentInstance = (instance) => {\r\n    currentInstance = instance;\r\n};\r\nconst isBuiltInTag = /*#__PURE__*/ makeMap('slot,component');\r\nfunction validateComponentName(name, config) {\r\n    const appIsNativeTag = config.isNativeTag || NO;\r\n    if (isBuiltInTag(name) || appIsNativeTag(name)) {\r\n        warn('Do not use built-in or reserved HTML elements as component id: ' + name);\r\n    }\r\n}\r\nlet isInSSRComponentSetup = false;\r\nfunction setupComponent(instance, isSSR = false) {\r\n    isInSSRComponentSetup = isSSR;\r\n    const { props, children, shapeFlag } = instance.vnode;\r\n    const isStateful = shapeFlag & 4 /* STATEFUL_COMPONENT */;\r\n    initProps(instance, props, isStateful, isSSR);\r\n    initSlots(instance, children);\r\n    const setupResult = isStateful\r\n        ? setupStatefulComponent(instance, isSSR)\r\n        : undefined;\r\n    isInSSRComponentSetup = false;\r\n    return setupResult;\r\n}\r\nfunction setupStatefulComponent(instance, isSSR) {\r\n    const Component = instance.type;\r\n    if ((process.env.NODE_ENV !== 'production')) {\r\n        if (Component.name) {\r\n            validateComponentName(Component.name, instance.appContext.config);\r\n        }\r\n        if (Component.components) {\r\n            const names = Object.keys(Component.components);\r\n            for (let i = 0; i < names.length; i++) {\r\n                validateComponentName(names[i], instance.appContext.config);\r\n            }\r\n        }\r\n        if (Component.directives) {\r\n            const names = Object.keys(Component.directives);\r\n            for (let i = 0; i < names.length; i++) {\r\n                validateDirectiveName(names[i]);\r\n            }\r\n        }\r\n    }\r\n    // 0. create render proxy property access cache\r\n    instance.accessCache = {};\r\n    // 1. create public instance / render proxy\r\n    // also mark it raw so it's never observed\r\n    instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);\r\n    if ((process.env.NODE_ENV !== 'production')) {\r\n        exposePropsOnRenderContext(instance);\r\n    }\r\n    // 2. call setup()\r\n    const { setup } = Component;\r\n    if (setup) {\r\n        const setupContext = (instance.setupContext =\r\n            setup.length > 1 ? createSetupContext(instance) : null);\r\n        currentInstance = instance;\r\n        pauseTracking();\r\n        const setupResult = callWithErrorHandling(setup, instance, 0 /* SETUP_FUNCTION */, [(process.env.NODE_ENV !== 'production') ? shallowReadonly(instance.props) : instance.props, setupContext]);\r\n        resetTracking();\r\n        currentInstance = null;\r\n        if (isPromise(setupResult)) {\r\n            if (isSSR) {\r\n                // return the promise so server-renderer can wait on it\r\n                return setupResult.then((resolvedResult) => {\r\n                    handleSetupResult(instance, resolvedResult);\r\n                });\r\n            }\r\n            else {\r\n                // async setup returned Promise.\r\n                // bail here and wait for re-entry.\r\n                instance.asyncDep = setupResult;\r\n            }\r\n        }\r\n        else {\r\n            handleSetupResult(instance, setupResult);\r\n        }\r\n    }\r\n    else {\r\n        finishComponentSetup(instance);\r\n    }\r\n}\r\nfunction handleSetupResult(instance, setupResult, isSSR) {\r\n    if (isFunction(setupResult)) {\r\n        // setup returned an inline render function\r\n        instance.render = setupResult;\r\n    }\r\n    else if (isObject(setupResult)) {\r\n        if ((process.env.NODE_ENV !== 'production') && isVNode(setupResult)) {\r\n            warn(`setup() should not return VNodes directly - ` +\r\n                `return a render function instead.`);\r\n        }\r\n        // setup returned bindings.\r\n        // assuming a render function compiled from template is present.\r\n        if ((process.env.NODE_ENV !== 'production') || __VUE_PROD_DEVTOOLS__) {\r\n            instance.devtoolsRawSetupState = setupResult;\r\n        }\r\n        instance.setupState = proxyRefs(setupResult);\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            exposeSetupStateOnRenderContext(instance);\r\n        }\r\n    }\r\n    else if ((process.env.NODE_ENV !== 'production') && setupResult !== undefined) {\r\n        warn(`setup() should return an object. Received: ${setupResult === null ? 'null' : typeof setupResult}`);\r\n    }\r\n    finishComponentSetup(instance);\r\n}\r\nlet compile;\r\n/**\r\n * For runtime-dom to register the compiler.\r\n * Note the exported method uses any to avoid d.ts relying on the compiler types.\r\n */\r\nfunction registerRuntimeCompiler(_compile) {\r\n    compile = _compile;\r\n}\r\nfunction finishComponentSetup(instance, isSSR) {\r\n    const Component = instance.type;\r\n    // template / render function normalization\r\n    if (!instance.render) {\r\n        // could be set from setup()\r\n        if (compile && Component.template && !Component.render) {\r\n            if ((process.env.NODE_ENV !== 'production')) {\r\n                startMeasure(instance, `compile`);\r\n            }\r\n            Component.render = compile(Component.template, {\r\n                isCustomElement: instance.appContext.config.isCustomElement,\r\n                delimiters: Component.delimiters\r\n            });\r\n            if ((process.env.NODE_ENV !== 'production')) {\r\n                endMeasure(instance, `compile`);\r\n            }\r\n        }\r\n        instance.render = (Component.render || NOOP);\r\n        // for runtime-compiled render functions using `with` blocks, the render\r\n        // proxy used needs a different `has` handler which is more performant and\r\n        // also only allows a whitelist of globals to fallthrough.\r\n        if (instance.render._rc) {\r\n            instance.withProxy = new Proxy(instance.ctx, RuntimeCompiledPublicInstanceProxyHandlers);\r\n        }\r\n    }\r\n    // support for 2.x options\r\n    if (__VUE_OPTIONS_API__) {\r\n        currentInstance = instance;\r\n        applyOptions(instance, Component);\r\n        currentInstance = null;\r\n    }\r\n    // warn missing template/render\r\n    if ((process.env.NODE_ENV !== 'production') && !Component.render && instance.render === NOOP) {\r\n        /* istanbul ignore if */\r\n        if (!compile && Component.template) {\r\n            warn(`Component provided template option but ` +\r\n                `runtime compilation is not supported in this build of Vue.` +\r\n                ( ` Configure your bundler to alias \"vue\" to \"vue/dist/vue.esm-bundler.js\".`\r\n                    ) /* should not happen */);\r\n        }\r\n        else {\r\n            warn(`Component is missing template or render function.`);\r\n        }\r\n    }\r\n}\r\nconst attrHandlers = {\r\n    get: (target, key) => {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            markAttrsAccessed();\r\n        }\r\n        return target[key];\r\n    },\r\n    set: () => {\r\n        warn(`setupContext.attrs is readonly.`);\r\n        return false;\r\n    },\r\n    deleteProperty: () => {\r\n        warn(`setupContext.attrs is readonly.`);\r\n        return false;\r\n    }\r\n};\r\nfunction createSetupContext(instance) {\r\n    if ((process.env.NODE_ENV !== 'production')) {\r\n        // We use getters in dev in case libs like test-utils overwrite instance\r\n        // properties (overwrites should not be done in prod)\r\n        return Object.freeze({\r\n            get attrs() {\r\n                return new Proxy(instance.attrs, attrHandlers);\r\n            },\r\n            get slots() {\r\n                return shallowReadonly(instance.slots);\r\n            },\r\n            get emit() {\r\n                return (event, ...args) => instance.emit(event, ...args);\r\n            }\r\n        });\r\n    }\r\n    else {\r\n        return {\r\n            attrs: instance.attrs,\r\n            slots: instance.slots,\r\n            emit: instance.emit\r\n        };\r\n    }\r\n}\r\n// record effects created during a component's setup() so that they can be\r\n// stopped when the component unmounts\r\nfunction recordInstanceBoundEffect(effect) {\r\n    if (currentInstance) {\r\n        (currentInstance.effects || (currentInstance.effects = [])).push(effect);\r\n    }\r\n}\r\nconst classifyRE = /(?:^|[-_])(\\w)/g;\r\nconst classify = (str) => str.replace(classifyRE, c => c.toUpperCase()).replace(/[-_]/g, '');\r\n/* istanbul ignore next */\r\nfunction formatComponentName(instance, Component, isRoot = false) {\r\n    let name = isFunction(Component)\r\n        ? Component.displayName || Component.name\r\n        : Component.name;\r\n    if (!name && Component.__file) {\r\n        const match = Component.__file.match(/([^/\\\\]+)\\.vue$/);\r\n        if (match) {\r\n            name = match[1];\r\n        }\r\n    }\r\n    if (!name && instance && instance.parent) {\r\n        // try to infer the name based on reverse resolution\r\n        const inferFromRegistry = (registry) => {\r\n            for (const key in registry) {\r\n                if (registry[key] === Component) {\r\n                    return key;\r\n                }\r\n            }\r\n        };\r\n        name =\r\n            inferFromRegistry(instance.components ||\r\n                instance.parent.type.components) || inferFromRegistry(instance.appContext.components);\r\n    }\r\n    return name ? classify(name) : isRoot ? `App` : `Anonymous`;\r\n}\r\nfunction isClassComponent(value) {\r\n    return isFunction(value) && '__vccOpts' in value;\r\n}\n\nfunction computed(getterOrOptions) {\r\n    const c = computed$1(getterOrOptions);\r\n    recordInstanceBoundEffect(c.effect);\r\n    return c;\r\n}\n\n// implementation, close to no-op\r\nfunction defineComponent(options) {\r\n    return isFunction(options) ? { setup: options, name: options.name } : options;\r\n}\n\nfunction defineAsyncComponent(source) {\r\n    if (isFunction(source)) {\r\n        source = { loader: source };\r\n    }\r\n    const { loader, loadingComponent: loadingComponent, errorComponent: errorComponent, delay = 200, timeout, // undefined = never times out\r\n    suspensible = true, onError: userOnError } = source;\r\n    let pendingRequest = null;\r\n    let resolvedComp;\r\n    let retries = 0;\r\n    const retry = () => {\r\n        retries++;\r\n        pendingRequest = null;\r\n        return load();\r\n    };\r\n    const load = () => {\r\n        let thisRequest;\r\n        return (pendingRequest ||\r\n            (thisRequest = pendingRequest = loader()\r\n                .catch(err => {\r\n                err = err instanceof Error ? err : new Error(String(err));\r\n                if (userOnError) {\r\n                    return new Promise((resolve, reject) => {\r\n                        const userRetry = () => resolve(retry());\r\n                        const userFail = () => reject(err);\r\n                        userOnError(err, userRetry, userFail, retries + 1);\r\n                    });\r\n                }\r\n                else {\r\n                    throw err;\r\n                }\r\n            })\r\n                .then((comp) => {\r\n                if (thisRequest !== pendingRequest && pendingRequest) {\r\n                    return pendingRequest;\r\n                }\r\n                if ((process.env.NODE_ENV !== 'production') && !comp) {\r\n                    warn(`Async component loader resolved to undefined. ` +\r\n                        `If you are using retry(), make sure to return its return value.`);\r\n                }\r\n                // interop module default\r\n                if (comp &&\r\n                    (comp.__esModule || comp[Symbol.toStringTag] === 'Module')) {\r\n                    comp = comp.default;\r\n                }\r\n                if ((process.env.NODE_ENV !== 'production') && comp && !isObject(comp) && !isFunction(comp)) {\r\n                    throw new Error(`Invalid async component load result: ${comp}`);\r\n                }\r\n                resolvedComp = comp;\r\n                return comp;\r\n            })));\r\n    };\r\n    return defineComponent({\r\n        __asyncLoader: load,\r\n        name: 'AsyncComponentWrapper',\r\n        setup() {\r\n            const instance = currentInstance;\r\n            // already resolved\r\n            if (resolvedComp) {\r\n                return () => createInnerComp(resolvedComp, instance);\r\n            }\r\n            const onError = (err) => {\r\n                pendingRequest = null;\r\n                handleError(err, instance, 13 /* ASYNC_COMPONENT_LOADER */, !errorComponent /* do not throw in dev if user provided error component */);\r\n            };\r\n            // suspense-controlled or SSR.\r\n            if (( suspensible && instance.suspense) ||\r\n                (false )) {\r\n                return load()\r\n                    .then(comp => {\r\n                    return () => createInnerComp(comp, instance);\r\n                })\r\n                    .catch(err => {\r\n                    onError(err);\r\n                    return () => errorComponent\r\n                        ? createVNode(errorComponent, {\r\n                            error: err\r\n                        })\r\n                        : null;\r\n                });\r\n            }\r\n            const loaded = ref(false);\r\n            const error = ref();\r\n            const delayed = ref(!!delay);\r\n            if (delay) {\r\n                setTimeout(() => {\r\n                    delayed.value = false;\r\n                }, delay);\r\n            }\r\n            if (timeout != null) {\r\n                setTimeout(() => {\r\n                    if (!loaded.value && !error.value) {\r\n                        const err = new Error(`Async component timed out after ${timeout}ms.`);\r\n                        onError(err);\r\n                        error.value = err;\r\n                    }\r\n                }, timeout);\r\n            }\r\n            load()\r\n                .then(() => {\r\n                loaded.value = true;\r\n            })\r\n                .catch(err => {\r\n                onError(err);\r\n                error.value = err;\r\n            });\r\n            return () => {\r\n                if (loaded.value && resolvedComp) {\r\n                    return createInnerComp(resolvedComp, instance);\r\n                }\r\n                else if (error.value && errorComponent) {\r\n                    return createVNode(errorComponent, {\r\n                        error: error.value\r\n                    });\r\n                }\r\n                else if (loadingComponent && !delayed.value) {\r\n                    return createVNode(loadingComponent);\r\n                }\r\n            };\r\n        }\r\n    });\r\n}\r\nfunction createInnerComp(comp, { vnode: { props, children } }) {\r\n    return createVNode(comp, props, children);\r\n}\n\n// Actual implementation\r\nfunction h(type, propsOrChildren, children) {\r\n    const l = arguments.length;\r\n    if (l === 2) {\r\n        if (isObject(propsOrChildren) && !isArray(propsOrChildren)) {\r\n            // single vnode without props\r\n            if (isVNode(propsOrChildren)) {\r\n                return createVNode(type, null, [propsOrChildren]);\r\n            }\r\n            // props without children\r\n            return createVNode(type, propsOrChildren);\r\n        }\r\n        else {\r\n            // omit props\r\n            return createVNode(type, null, propsOrChildren);\r\n        }\r\n    }\r\n    else {\r\n        if (l > 3) {\r\n            children = Array.prototype.slice.call(arguments, 2);\r\n        }\r\n        else if (l === 3 && isVNode(children)) {\r\n            children = [children];\r\n        }\r\n        return createVNode(type, propsOrChildren, children);\r\n    }\r\n}\n\nconst ssrContextKey = Symbol((process.env.NODE_ENV !== 'production') ? `ssrContext` : ``);\r\nconst useSSRContext = () => {\r\n    {\r\n        const ctx = inject(ssrContextKey);\r\n        if (!ctx) {\r\n            warn(`Server rendering context not provided. Make sure to only call ` +\r\n                `useSsrContext() conditionally in the server build.`);\r\n        }\r\n        return ctx;\r\n    }\r\n};\n\nfunction initCustomFormatter() {\r\n    if (!(process.env.NODE_ENV !== 'production') || !true) {\r\n        return;\r\n    }\r\n    const vueStyle = { style: 'color:#3ba776' };\r\n    const numberStyle = { style: 'color:#0b1bc9' };\r\n    const stringStyle = { style: 'color:#b62e24' };\r\n    const keywordStyle = { style: 'color:#9d288c' };\r\n    // custom formatter for Chrome\r\n    // https://www.mattzeunert.com/2016/02/19/custom-chrome-devtools-object-formatters.html\r\n    const formatter = {\r\n        header(obj) {\r\n            // TODO also format ComponentPublicInstance & ctx.slots/attrs in setup\r\n            if (!isObject(obj)) {\r\n                return null;\r\n            }\r\n            if (obj.__isVue) {\r\n                return ['div', vueStyle, `VueInstance`];\r\n            }\r\n            else if (isRef(obj)) {\r\n                return [\r\n                    'div',\r\n                    {},\r\n                    ['span', vueStyle, genRefFlag(obj)],\r\n                    '<',\r\n                    formatValue(obj.value),\r\n                    `>`\r\n                ];\r\n            }\r\n            else if (isReactive(obj)) {\r\n                return [\r\n                    'div',\r\n                    {},\r\n                    ['span', vueStyle, 'Reactive'],\r\n                    '<',\r\n                    formatValue(obj),\r\n                    `>${isReadonly(obj) ? ` (readonly)` : ``}`\r\n                ];\r\n            }\r\n            else if (isReadonly(obj)) {\r\n                return [\r\n                    'div',\r\n                    {},\r\n                    ['span', vueStyle, 'Readonly'],\r\n                    '<',\r\n                    formatValue(obj),\r\n                    '>'\r\n                ];\r\n            }\r\n            return null;\r\n        },\r\n        hasBody(obj) {\r\n            return obj && obj.__isVue;\r\n        },\r\n        body(obj) {\r\n            if (obj && obj.__isVue) {\r\n                return [\r\n                    'div',\r\n                    {},\r\n                    ...formatInstance(obj.$)\r\n                ];\r\n            }\r\n        }\r\n    };\r\n    function formatInstance(instance) {\r\n        const blocks = [];\r\n        if (instance.type.props && instance.props) {\r\n            blocks.push(createInstanceBlock('props', toRaw(instance.props)));\r\n        }\r\n        if (instance.setupState !== EMPTY_OBJ) {\r\n            blocks.push(createInstanceBlock('setup', instance.setupState));\r\n        }\r\n        if (instance.data !== EMPTY_OBJ) {\r\n            blocks.push(createInstanceBlock('data', toRaw(instance.data)));\r\n        }\r\n        const computed = extractKeys(instance, 'computed');\r\n        if (computed) {\r\n            blocks.push(createInstanceBlock('computed', computed));\r\n        }\r\n        const injected = extractKeys(instance, 'inject');\r\n        if (injected) {\r\n            blocks.push(createInstanceBlock('injected', injected));\r\n        }\r\n        blocks.push([\r\n            'div',\r\n            {},\r\n            [\r\n                'span',\r\n                {\r\n                    style: keywordStyle.style + ';opacity:0.66'\r\n                },\r\n                '$ (internal): '\r\n            ],\r\n            ['object', { object: instance }]\r\n        ]);\r\n        return blocks;\r\n    }\r\n    function createInstanceBlock(type, target) {\r\n        target = extend({}, target);\r\n        if (!Object.keys(target).length) {\r\n            return ['span', {}];\r\n        }\r\n        return [\r\n            'div',\r\n            { style: 'line-height:1.25em;margin-bottom:0.6em' },\r\n            [\r\n                'div',\r\n                {\r\n                    style: 'color:#476582'\r\n                },\r\n                type\r\n            ],\r\n            [\r\n                'div',\r\n                {\r\n                    style: 'padding-left:1.25em'\r\n                },\r\n                ...Object.keys(target).map(key => {\r\n                    return [\r\n                        'div',\r\n                        {},\r\n                        ['span', keywordStyle, key + ': '],\r\n                        formatValue(target[key], false)\r\n                    ];\r\n                })\r\n            ]\r\n        ];\r\n    }\r\n    function formatValue(v, asRaw = true) {\r\n        if (typeof v === 'number') {\r\n            return ['span', numberStyle, v];\r\n        }\r\n        else if (typeof v === 'string') {\r\n            return ['span', stringStyle, JSON.stringify(v)];\r\n        }\r\n        else if (typeof v === 'boolean') {\r\n            return ['span', keywordStyle, v];\r\n        }\r\n        else if (isObject(v)) {\r\n            return ['object', { object: asRaw ? toRaw(v) : v }];\r\n        }\r\n        else {\r\n            return ['span', stringStyle, String(v)];\r\n        }\r\n    }\r\n    function extractKeys(instance, type) {\r\n        const Comp = instance.type;\r\n        if (isFunction(Comp)) {\r\n            return;\r\n        }\r\n        const extracted = {};\r\n        for (const key in instance.ctx) {\r\n            if (isKeyOfType(Comp, key, type)) {\r\n                extracted[key] = instance.ctx[key];\r\n            }\r\n        }\r\n        return extracted;\r\n    }\r\n    function isKeyOfType(Comp, key, type) {\r\n        const opts = Comp[type];\r\n        if ((isArray(opts) && opts.includes(key)) ||\r\n            (isObject(opts) && key in opts)) {\r\n            return true;\r\n        }\r\n        if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {\r\n            return true;\r\n        }\r\n        if (Comp.mixins && Comp.mixins.some(m => isKeyOfType(m, key, type))) {\r\n            return true;\r\n        }\r\n    }\r\n    function genRefFlag(v) {\r\n        if (v._shallow) {\r\n            return `ShallowRef`;\r\n        }\r\n        if (v.effect) {\r\n            return `ComputedRef`;\r\n        }\r\n        return `Ref`;\r\n    }\r\n    /* eslint-disable no-restricted-globals */\r\n    if (window.devtoolsFormatters) {\r\n        window.devtoolsFormatters.push(formatter);\r\n    }\r\n    else {\r\n        window.devtoolsFormatters = [formatter];\r\n    }\r\n}\n\n/**\r\n * Actual implementation\r\n */\r\nfunction renderList(source, renderItem) {\r\n    let ret;\r\n    if (isArray(source) || isString(source)) {\r\n        ret = new Array(source.length);\r\n        for (let i = 0, l = source.length; i < l; i++) {\r\n            ret[i] = renderItem(source[i], i);\r\n        }\r\n    }\r\n    else if (typeof source === 'number') {\r\n        if ((process.env.NODE_ENV !== 'production') && !Number.isInteger(source)) {\r\n            warn(`The v-for range expect an integer value but got ${source}.`);\r\n            return [];\r\n        }\r\n        ret = new Array(source);\r\n        for (let i = 0; i < source; i++) {\r\n            ret[i] = renderItem(i + 1, i);\r\n        }\r\n    }\r\n    else if (isObject(source)) {\r\n        if (source[Symbol.iterator]) {\r\n            ret = Array.from(source, renderItem);\r\n        }\r\n        else {\r\n            const keys = Object.keys(source);\r\n            ret = new Array(keys.length);\r\n            for (let i = 0, l = keys.length; i < l; i++) {\r\n                const key = keys[i];\r\n                ret[i] = renderItem(source[key], key, i);\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        ret = [];\r\n    }\r\n    return ret;\r\n}\n\n/**\r\n * For prefixing keys in v-on=\"obj\" with \"on\"\r\n * @private\r\n */\r\nfunction toHandlers(obj) {\r\n    const ret = {};\r\n    if ((process.env.NODE_ENV !== 'production') && !isObject(obj)) {\r\n        warn(`v-on with no argument expects an object value.`);\r\n        return ret;\r\n    }\r\n    for (const key in obj) {\r\n        ret[`on${capitalize(key)}`] = obj[key];\r\n    }\r\n    return ret;\r\n}\n\n/**\r\n * Compiler runtime helper for creating dynamic slots object\r\n * @private\r\n */\r\nfunction createSlots(slots, dynamicSlots) {\r\n    for (let i = 0; i < dynamicSlots.length; i++) {\r\n        const slot = dynamicSlots[i];\r\n        // array of dynamic slot generated by <template v-for=\"...\" #[...]>\r\n        if (isArray(slot)) {\r\n            for (let j = 0; j < slot.length; j++) {\r\n                slots[slot[j].name] = slot[j].fn;\r\n            }\r\n        }\r\n        else if (slot) {\r\n            // conditional single slot generated by <template v-if=\"...\" #foo>\r\n            slots[slot.name] = slot.fn;\r\n        }\r\n    }\r\n    return slots;\r\n}\n\n// Core API ------------------------------------------------------------------\r\nconst version = \"3.0.1\";\r\n/**\r\n * SSR utils for \\@vue/server-renderer. Only exposed in cjs builds.\r\n * @internal\r\n */\r\nconst ssrUtils = ( null);\n\nexport { BaseTransition, Comment, Fragment, KeepAlive, Static, Suspense, Teleport, Text, callWithAsyncErrorHandling, callWithErrorHandling, cloneVNode, computed, createBlock, createCommentVNode, createHydrationRenderer, createRenderer, createSlots, createStaticVNode, createTextVNode, createVNode, defineAsyncComponent, defineComponent, devtools, getCurrentInstance, getTransitionRawChildren, h, handleError, initCustomFormatter, inject, isVNode, mergeProps, nextTick, onActivated, onBeforeMount, onBeforeUnmount, onBeforeUpdate, onDeactivated, onErrorCaptured, onMounted, onRenderTracked, onRenderTriggered, onUnmounted, onUpdated, openBlock, popScopeId, provide, pushScopeId, queuePostFlushCb, registerRuntimeCompiler, renderList, renderSlot, resolveComponent, resolveDirective, resolveDynamicComponent, resolveTransitionHooks, setBlockTracking, setDevtoolsHook, setTransitionHooks, ssrContextKey, ssrUtils, toHandlers, transformVNodeArgs, useSSRContext, useTransitionState, version, warn, watch, watchEffect, withCtx, withDirectives, withScopeId };\n"]},"metadata":{},"sourceType":"module"}